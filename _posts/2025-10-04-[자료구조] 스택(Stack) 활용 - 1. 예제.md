---
layout: post
title: "[자료구조] 스택(Stack) 활용 - 1. 예제"
date: 2025-10-04 23:10:00 +0900
categories: [자료구조, 스택]
tags: [자료구조, 스택, Stack, 문제해결, 괄호매칭, 후위표기법, 알고리즘, 예제]
author: LimJongHan
toc: true
---

# 📖 관련된 내 포스팅
- [[자료구조] 자료구조와 알고리즘 개요]({% post_url 2025-10-02-[자료구조] 자료구조와 알고리즘 개요 %})
- [[자료구조] 스택(Stack)]({% post_url 2025-10-04-[자료구조] 스택(Stack) %})

# 📝 내용

## 개요

스택의 LIFO(Last In, First Out) 특성은 다양한 문제 해결에 매우 유용합니다. 이번 포스트에서는 스택을 활용한 기본적인 문제 해결 예제들을 살펴보겠습니다. 각 예제는 스택의 핵심 개념을 이해하고 실제 문제에 어떻게 적용할 수 있는지 보여줍니다.

**다룰 예제들:**
- 괄호 매칭 검사 (가장 기본적이고 중요한 예제)
- 후위 표기법 계산 (스택의 전형적인 활용)
- 문자열 역순 출력 (간단한 스택 활용)
- 회문 검사 (스택과 큐의 조합)
- 중위 표기법을 후위 표기법으로 변환

## 1. 괄호 매칭 검사

괄호 매칭은 스택의 가장 대표적인 활용 예제입니다. 주어진 문자열에서 괄호가 올바르게 매칭되는지 확인하는 문제입니다.

### 1-1 기본 괄호 매칭 (소괄호만)

```python
def is_balanced_basic(expression):
    """
    기본적인 괄호 매칭 검사 (소괄호만)
    Args:
        expression (str): 검사할 수식 문자열
    Returns:
        bool: 괄호가 올바르게 매칭되면 True, 아니면 False
    """
    stack = []
    
    for char in expression:
        if char == '(':
            stack.append(char)  # 여는 괄호는 스택에 추가
        elif char == ')':
            if not stack:  # 스택이 비어있으면 매칭되는 여는 괄호가 없음
                return False
            stack.pop()  # 여는 괄호와 매칭되므로 제거
    
    return len(stack) == 0  # 모든 괄호가 매칭되면 스택이 비어있어야 함

# 테스트
test_cases = [
    "((()))",      # True
    "()()()",      # True
    "((())",       # False
    "())",         # False
    "((()()))",    # True
    "(()))",       # False
    ""             # True
]

for test in test_cases:
    result = is_balanced_basic(test)
    print(f"'{test}' -> {result}")
```

### 1-2 다양한 괄호 매칭 (소괄호, 대괄호, 중괄호)

```python
def is_balanced_advanced(expression):
    """
    다양한 괄호 매칭 검사 (소괄호, 대괄호, 중괄호)
    Args:
        expression (str): 검사할 수식 문자열
    Returns:
        bool: 괄호가 올바르게 매칭되면 True, 아니면 False
    """
    stack = []
    matching = {
        ')': '(',
        ']': '[',
        '}': '{'
    }
    
    for char in expression:
        if char in matching.values():  # 여는 괄호
            stack.append(char)
        elif char in matching.keys():  # 닫는 괄호
            if not stack or stack[-1] != matching[char]:
                return False
            stack.pop()
        # 괄호가 아닌 문자는 무시
    
    return len(stack) == 0

# 테스트
test_cases = [
    "()[]{}",           # True
    "([{}])",           # True
    "([)]",             # False
    "{[()]}",           # True
    "((())",            # False
    "([{}]))",          # False
    "a + (b * [c + d])" # True
]

for test in test_cases:
    result = is_balanced_advanced(test)
    print(f"'{test}' -> {result}")
```

### 1-3 괄호 매칭 검사 (상세 정보 포함)

```python
def check_parentheses_detailed(expression):
    """
    괄호 매칭 검사 (상세한 오류 정보 제공)
    Args:
        expression (str): 검사할 수식 문자열
    Returns:
        tuple: (is_valid, error_info)
    """
    stack = []
    matching = {
        ')': '(',
        ']': '[',
        '}': '{'
    }
    
    for i, char in enumerate(expression):
        if char in matching.values():  # 여는 괄호
            stack.append((char, i))
        elif char in matching.keys():  # 닫는 괄호
            if not stack:
                return False, f"위치 {i}: 닫는 괄호 '{char}'에 매칭되는 여는 괄호가 없습니다"
            
            last_open, pos = stack[-1]
            if last_open != matching[char]:
                return False, f"위치 {i}: 괄호 타입이 맞지 않습니다. '{last_open}'와 '{char}'"
            
            stack.pop()
    
    if stack:
        remaining_char, pos = stack[0]
        return False, f"위치 {pos}: 여는 괄호 '{remaining_char}'에 대응되는 닫는 괄호가 없습니다"
    
    return True, "올바른 괄호 매칭입니다"

# 테스트
test_expressions = [
    "((()))",
    "([{}])",
    "([)]",
    "((())",
    "())",
    "{[()]}",
    "a + (b * [c + d])"
]

for expr in test_expressions:
    is_valid, message = check_parentheses_detailed(expr)
    print(f"'{expr}' -> {is_valid}: {message}")
```

## 2. 후위 표기법 (Reverse Polish Notation) 계산

후위 표기법은 연산자가 피연산자 뒤에 오는 표기법으로, 스택을 이용하면 매우 쉽게 계산할 수 있습니다.

### 2-1 기본 후위 표기법 계산기

```python
def evaluate_postfix(expression):
    """
    후위 표기법 수식 계산
    Args:
        expression (str): 후위 표기법으로 된 수식 (공백으로 구분)
    Returns:
        float: 계산 결과
    """
    stack = []
    operators = {'+', '-', '*', '/', '^'}
    
    tokens = expression.split()
    
    for token in tokens:
        if token in operators:
            # 연산자인 경우: 스택에서 두 개의 피연산자를 꺼내서 계산
            if len(stack) < 2:
                raise ValueError("피연산자 부족")
            
            b = stack.pop()  # 두 번째 피연산자
            a = stack.pop()  # 첫 번째 피연산자
            
            if token == '+':
                result = a + b
            elif token == '-':
                result = a - b
            elif token == '*':
                result = a * b
            elif token == '/':
                if b == 0:
                    raise ValueError("0으로 나누기 불가")
                result = a / b
            elif token == '^':
                result = a ** b
            
            stack.append(result)
        else:
            # 피연산자인 경우: 스택에 추가
            try:
                number = float(token)
                stack.append(number)
            except ValueError:
                raise ValueError(f"잘못된 토큰: {token}")
    
    if len(stack) != 1:
        raise ValueError("수식이 올바르지 않습니다")
    
    return stack[0]

# 테스트
test_expressions = [
    "3 4 +",           # 3 + 4 = 7
    "3 4 + 2 *",       # (3 + 4) * 2 = 14
    "15 7 1 1 + - / 3 * 2 1 1 + + -",  # 복잡한 수식
    "5 1 2 + 4 * + 3 -",  # 5 + (1 + 2) * 4 - 3 = 14
    "2 3 ^",           # 2^3 = 8
]

for expr in test_expressions:
    try:
        result = evaluate_postfix(expr)
        print(f"'{expr}' = {result}")
    except Exception as e:
        print(f"'{expr}' -> 오류: {e}")
```

### 2-2 중위 표기법을 후위 표기법으로 변환

```python
def infix_to_postfix(expression):
    """
    중위 표기법을 후위 표기법으로 변환 (Shunting Yard 알고리즘)
    Args:
        expression (str): 중위 표기법 수식
    Returns:
        str: 후위 표기법 수식
    """
    stack = []
    output = []
    
    # 연산자 우선순위
    precedence = {
        '^': 4,
        '*': 3,
        '/': 3,
        '+': 2,
        '-': 2,
        '(': 0
    }
    
    i = 0
    while i < len(expression):
        char = expression[i]
        
        if char.isdigit():
            # 숫자인 경우: 연속된 숫자를 모두 읽음
            num = ""
            while i < len(expression) and (expression[i].isdigit() or expression[i] == '.'):
                num += expression[i]
                i += 1
            output.append(num)
            continue
        
        elif char == '(':
            stack.append(char)
        
        elif char == ')':
            # 닫는 괄호: 여는 괄호를 만날 때까지 모든 연산자를 출력
            while stack and stack[-1] != '(':
                output.append(stack.pop())
            stack.pop()  # 여는 괄호 제거
        
        elif char in precedence:
            # 연산자인 경우: 우선순위에 따라 스택 처리
            while (stack and stack[-1] != '(' and 
                   precedence[stack[-1]] >= precedence[char]):
                output.append(stack.pop())
            stack.append(char)
        
        i += 1
    
    # 남은 연산자들을 모두 출력
    while stack:
        output.append(stack.pop())
    
    return ' '.join(output)

# 테스트
test_expressions = [
    "3 + 4",
    "3 + 4 * 2",
    "(3 + 4) * 2",
    "3 * (4 + 2)",
    "2 ^ 3",
    "3 + 4 * 2 / (1 - 5) ^ 2"
]

for expr in test_expressions:
    postfix = infix_to_postfix(expr)
    print(f"중위: {expr}")
    print(f"후위: {postfix}")
    
    try:
        result = evaluate_postfix(postfix)
        print(f"결과: {result}")
    except Exception as e:
        print(f"계산 오류: {e}")
    print("-" * 40)
```

## 3. 문자열 역순 출력

스택의 LIFO 특성을 이용하여 문자열을 역순으로 출력하는 간단한 예제입니다.

```python
def reverse_string_stack(text):
    """
    스택을 사용하여 문자열을 역순으로 출력
    Args:
        text (str): 역순으로 만들 문자열
    Returns:
        str: 역순으로 변환된 문자열
    """
    stack = []
    
    # 모든 문자를 스택에 추가
    for char in text:
        stack.append(char)
    
    # 스택에서 문자를 하나씩 꺼내어 역순 문자열 생성
    reversed_text = ""
    while stack:
        reversed_text += stack.pop()
    
    return reversed_text

# 테스트
test_strings = [
    "Hello",
    "World",
    "Python",
    "Stack",
    "12345",
    "안녕하세요"
]

for text in test_strings:
    reversed_text = reverse_string_stack(text)
    print(f"원본: {text} -> 역순: {reversed_text}")

# Python 내장 함수와 비교
print("\n=== Python 내장 함수와 비교 ===")
for text in test_strings:
    stack_result = reverse_string_stack(text)
    builtin_result = text[::-1]  # Python 슬라이싱
    print(f"'{text}': 스택={stack_result}, 내장함수={builtin_result}, 일치={stack_result == builtin_result}")
```

## 4. 회문(Palindrome) 검사

회문은 앞에서부터 읽어도 뒤에서부터 읽어도 같은 문자열입니다. 스택을 이용하여 회문을 검사할 수 있습니다.

```python
def is_palindrome_stack(text):
    """
    스택을 사용하여 회문 검사
    Args:
        text (str): 검사할 문자열
    Returns:
        bool: 회문이면 True, 아니면 False
    """
    # 대소문자 구분 없이, 공백과 특수문자 제거
    cleaned_text = ''.join(char.lower() for char in text if char.isalnum())
    
    if not cleaned_text:
        return True
    
    # 문자열의 절반을 스택에 추가
    stack = []
    length = len(cleaned_text)
    mid = length // 2
    
    for i in range(mid):
        stack.append(cleaned_text[i])
    
    # 홀수 길이인 경우 중간 문자 건너뛰기
    start = mid + 1 if length % 2 == 1 else mid
    
    # 나머지 절반과 스택의 내용 비교
    for i in range(start, length):
        if stack.pop() != cleaned_text[i]:
            return False
    
    return True

# 테스트
test_strings = [
    "racecar",           # True
    "level",             # True
    "deified",           # True
    "hello",             # False
    "world",             # False
    "A man a plan a canal Panama",  # True
    "Was it a car or a cat I saw?",  # True
    "No lemon, no melon",  # True
    "12321",             # True
    "12345",             # False
    "",                  # True (빈 문자열)
    "a",                 # True (한 글자)
]

for text in test_strings:
    result = is_palindrome_stack(text)
    print(f"'{text}' -> 회문: {result}")

# 더 효율적인 방법과 비교
def is_palindrome_efficient(text):
    """더 효율적인 회문 검사 (투 포인터 방식)"""
    cleaned_text = ''.join(char.lower() for char in text if char.isalnum())
    
    left = 0
    right = len(cleaned_text) - 1
    
    while left < right:
        if cleaned_text[left] != cleaned_text[right]:
            return False
        left += 1
        right -= 1
    
    return True

print("\n=== 효율성 비교 ===")
for text in test_strings[:5]:  # 처음 5개만 테스트
    stack_result = is_palindrome_stack(text)
    efficient_result = is_palindrome_efficient(text)
    print(f"'{text}': 스택={stack_result}, 효율적={efficient_result}, 일치={stack_result == efficient_result}")
```

## 5. 스택을 이용한 중복 문자 제거

연속된 중복 문자를 제거하는 문제입니다.

```python
def remove_duplicates_stack(text):
    """
    스택을 사용하여 연속된 중복 문자 제거
    Args:
        text (str): 처리할 문자열
    Returns:
        str: 중복이 제거된 문자열
    """
    if not text:
        return text
    
    stack = []
    
    for char in text:
        if stack and stack[-1] == char:
            # 연속된 중복 문자 발견: 스택에서 제거
            stack.pop()
        else:
            # 새로운 문자 또는 중복이 아닌 문자: 스택에 추가
            stack.append(char)
    
    return ''.join(stack)

# 테스트
test_strings = [
    "abbaca",        # "ca"
    "azxxzy",        # "ay"
    "aabccba",       # ""
    "abcd",          # "abcd" (중복 없음)
    "aabbcc",        # ""
    "aaabccba",      # ""
    "leetcode",      # "letcod"
]

for text in test_strings:
    result = remove_duplicates_stack(text)
    print(f"'{text}' -> '{result}'")

# 시각적 설명
def remove_duplicates_with_explanation(text):
    """중복 제거 과정을 시각적으로 보여주는 함수"""
    print(f"\n처리할 문자열: '{text}'")
    stack = []
    
    for i, char in enumerate(text):
        print(f"단계 {i+1}: 문자 '{char}' 처리")
        
        if stack and stack[-1] == char:
            removed = stack.pop()
            print(f"  -> 중복 발견! '{removed}' 제거")
        else:
            stack.append(char)
            print(f"  -> '{char}' 추가")
        
        print(f"  -> 현재 스택: {stack}")
    
    result = ''.join(stack)
    print(f"최종 결과: '{result}'")
    return result

# 상세한 설명과 함께 테스트
remove_duplicates_with_explanation("abbaca")
```

## 정리

이번 포스트에서는 스택을 활용한 기본적인 문제 해결 예제들을 살펴보았습니다.

**핵심 예제 정리**
1. **괄호 매칭**: 스택의 가장 전형적인 활용, LIFO 특성의 완벽한 예시
2. **후위 표기법**: 수식 계산에서 스택의 중요성, 중위→후위 변환
3. **문자열 역순**: 스택의 기본 개념 이해를 위한 간단한 예제
4. **회문 검사**: 스택을 이용한 문자열 분석 방법
5. **중복 문자 제거**: 스택을 이용한 문자열 처리 최적화

**스택 활용의 핵심 원칙**
- **LIFO 특성 활용**: 마지막에 들어온 것을 먼저 처리해야 하는 상황
- **임시 저장소**: 처리 순서가 중요한 데이터의 임시 저장
- **상태 관리**: 이전 상태를 기억해야 하는 알고리즘

**다음 학습 계획**
다음 포스트에서는 스택의 고급 활용과 알고리즘 최적화에 대해 알아보겠습니다:
- [[자료구조] 스택(Stack) 활용 - 2. 고급 활용]({% post_url 2025-10-04-[자료구조] 스택(Stack) 활용 - 2. 고급 활용 %}) - 재귀, DFS, 메모리 스택 등
- [[자료구조] 스택(Stack) 활용 - 3. 실무 활용]({% post_url 2025-10-04-[자료구조] 스택(Stack) 활용 - 3. 실무 활용 %}) - 브라우저 히스토리, 실행 취소, 웹 서버 등

# 📚 레퍼런스
- [Stack Applications - GeeksforGeeks](https://www.geeksforgeeks.org/stack-data-structure/)
- [Parentheses Matching - LeetCode](https://leetcode.com/problems/valid-parentheses/)
- [Reverse Polish Notation - Wikipedia](https://en.wikipedia.org/wiki/Reverse_Polish_notation)
- [Shunting Yard Algorithm - Wikipedia](https://en.wikipedia.org/wiki/Shunting_yard_algorithm)

---
*이 포스트는 자료구조 학습 과정을 정리한 내용입니다.*
