---
layout: post
title: "[자료구조] 스택(Stack) - 활용 - 2"
date: 2025-10-04 23:15:00 +0900
categories: [자료구조, 스택]
tags: [자료구조, 스택, Stack, 재귀, DFS, 메모리스택, 호출스택, 알고리즘, 최적화]
author: LimJongHan
toc: true
---

# 📖 관련된 내 포스팅
- [[자료구조] 자료구조와 알고리즘 개요]({% post_url 2025-10-02-[자료구조] 자료구조와 알고리즘 개요 %})
- [[자료구조] 스택(Stack) - 기본 예제]({% post_url 2025-10-04-[자료구조] 스택(Stack) - 기본 예제 %})
- [[자료구조] 스택(Stack) - 활용 - 1]({% post_url 2025-10-04-[자료구조] 스택(Stack) - 활용 - 1 %})

# 📝 내용

## 개요

스택의 고급 활용에서는 재귀와 호출 스택, 깊이 우선 탐색(DFS), 그리고 스택을 이용한 알고리즘 최적화 기법들을 다룹니다. 이러한 고급 기법들은 컴퓨터 과학의 핵심 개념이며, 실제 알고리즘 문제 해결에서 매우 중요한 역할을 합니다.

**다룰 고급 활용들:**
- **재귀와 호출 스택**: 함수 호출의 메커니즘과 스택 오버플로우
- **깊이 우선 탐색(DFS)**: 그래프와 트리 탐색에서의 스택 활용
- **스택 기반 알고리즘 최적화**: 재귀를 반복문으로 변환
- **메모리 스택과 실행 컨텍스트**: 프로그램 실행 시 스택의 역할
- **고급 문제 해결**: 복잡한 알고리즘에서의 스택 활용

## 1. 재귀와 호출 스택 (Call Stack)

재귀 함수의 실행은 내부적으로 호출 스택을 사용합니다. 이는 스택의 LIFO 특성을 완벽하게 보여주는 예시입니다.

### 1-1 재귀 함수의 호출 스택 이해

```python
def factorial_recursive(n):
    """
    재귀를 이용한 팩토리얼 계산
    각 호출이 스택에 쌓이는 과정을 시각화
    """
    print(f"factorial({n}) 호출됨")
    
    # 기본 케이스 (Base Case)
    if n <= 1:
        print(f"factorial({n}) = 1 (기본 케이스)")
        return 1
    
    # 재귀 케이스 (Recursive Case)
    print(f"factorial({n})에서 factorial({n-1}) 호출")
    result = n * factorial_recursive(n - 1)
    print(f"factorial({n}) = {n} * {result // n} = {result}")
    return result

# 테스트
print("=== 재귀 호출 스택 시각화 ===")
result = factorial_recursive(4)
print(f"최종 결과: {result}")

# 호출 스택의 메모리 사용량 시뮬레이션
def factorial_with_stack_trace(n, depth=0):
    """호출 스택의 깊이를 시각화하는 팩토리얼 함수"""
    indent = "  " * depth
    print(f"{indent}호출 스택 깊이 {depth}: factorial({n}) 진입")
    
    if n <= 1:
        print(f"{indent}호출 스택 깊이 {depth}: factorial({n}) = 1 (기본 케이스)")
        return 1
    
    print(f"{indent}호출 스택 깊이 {depth}: factorial({n-1}) 호출 준비")
    result = n * factorial_with_stack_trace(n - 1, depth + 1)
    print(f"{indent}호출 스택 깊이 {depth}: factorial({n}) = {result} 완료")
    return result

print("\n=== 호출 스택 깊이 시각화 ===")
result = factorial_with_stack_trace(4)
```

### 1-2 재귀를 스택을 이용한 반복문으로 변환

```python
def factorial_iterative_with_stack(n):
    """
    스택을 이용하여 재귀를 반복문으로 변환한 팩토리얼
    Args:
        n (int): 계산할 팩토리얼의 값
    Returns:
        int: n!의 값
    """
    if n <= 1:
        return 1
    
    # 호출 스택을 시뮬레이션하는 스택
    call_stack = []
    call_stack.append(('compute', n, 1))  # (작업타입, 값, 부분결과)
    
    result = 1
    
    while call_stack:
        operation, value, partial = call_stack.pop()
        
        if operation == 'compute':
            if value <= 1:
                result = partial
            else:
                # 재귀 호출을 스택 작업으로 변환
                call_stack.append(('multiply', value, partial))
                call_stack.append(('compute', value - 1, 1))
        
        elif operation == 'multiply':
            result = value * result
    
    return result

# 테스트
print("=== 스택을 이용한 반복적 팩토리얼 ===")
for i in range(1, 6):
    recursive_result = factorial_recursive(i)
    iterative_result = factorial_iterative_with_stack(i)
    print(f"n={i}: 재귀={recursive_result}, 반복={iterative_result}, 일치={recursive_result == iterative_result}")

# 피보나치 수열의 재귀 vs 스택 변환
def fibonacci_recursive(n):
    """재귀를 이용한 피보나치 수열"""
    if n <= 1:
        return n
    return fibonacci_recursive(n - 1) + fibonacci_recursive(n - 2)

def fibonacci_iterative_with_stack(n):
    """
    스택을 이용한 피보나치 수열 (중복 계산 방지)
    메모이제이션과 유사한 효과
    """
    if n <= 1:
        return n
    
    # 계산 결과를 저장할 딕셔너리 (메모이제이션)
    memo = {}
    
    # 계산할 값들을 스택에 저장
    stack = [n]
    visited = set()
    
    while stack:
        current = stack[-1]
        
        if current in memo:
            stack.pop()
            continue
        
        if current <= 1:
            memo[current] = current
            stack.pop()
            continue
        
        # 필요한 이전 값들이 계산되었는지 확인
        if (current - 1) in memo and (current - 2) in memo:
            memo[current] = memo[current - 1] + memo[current - 2]
            stack.pop()
        else:
            # 필요한 값들을 스택에 추가 (역순으로)
            if (current - 2) not in memo and (current - 2) not in visited:
                stack.append(current - 2)
                visited.add(current - 2)
            if (current - 1) not in memo and (current - 1) not in visited:
                stack.append(current - 1)
                visited.add(current - 1)
    
    return memo[n]

# 테스트
print("\n=== 피보나치 수열 비교 ===")
for i in range(10):
    recursive_result = fibonacci_recursive(i)
    iterative_result = fibonacci_iterative_with_stack(i)
    print(f"F({i}): 재귀={recursive_result}, 스택={iterative_result}, 일치={recursive_result == iterative_result}")
```

## 2. 깊이 우선 탐색 (DFS)에서의 스택 활용

DFS는 그래프나 트리를 탐색할 때 사용되는 알고리즘으로, 스택의 개념과 밀접한 관련이 있습니다.

### 2-1 그래프의 DFS 구현 (스택 사용)

```python
from collections import defaultdict

class Graph:
    """인접 리스트를 이용한 그래프 구현"""
    def __init__(self):
        self.graph = defaultdict(list)
    
    def add_edge(self, u, v):
        """간선 추가"""
        self.graph[u].append(v)
        self.graph[v].append(u)  # 무방향 그래프
    
    def dfs_recursive(self, start, visited=None):
        """재귀를 이용한 DFS"""
        if visited is None:
            visited = set()
        
        visited.add(start)
        print(f"방문: {start}")
        
        for neighbor in self.graph[start]:
            if neighbor not in visited:
                self.dfs_recursive(neighbor, visited)
        
        return visited
    
    def dfs_iterative_with_stack(self, start):
        """
        스택을 이용한 DFS (재귀 대신 반복문 사용)
        Args:
            start: 시작 정점
        Returns:
            set: 방문한 정점들의 집합
        """
        visited = set()
        stack = [start]
        
        while stack:
            vertex = stack.pop()
            
            if vertex not in visited:
                visited.add(vertex)
                print(f"방문: {vertex}")
                
                # 인접한 정점들을 스택에 추가 (역순으로 추가하여 순서 유지)
                for neighbor in reversed(self.graph[vertex]):
                    if neighbor not in visited:
                        stack.append(neighbor)
        
        return visited
    
    def dfs_path_finding(self, start, target):
        """
        스택을 이용한 경로 탐색
        Args:
            start: 시작 정점
            target: 목표 정점
        Returns:
            list: 시작점에서 목표점까지의 경로, 경로가 없으면 None
        """
        stack = [(start, [start])]  # (현재 정점, 경로)
        visited = set()
        
        while stack:
            current, path = stack.pop()
            
            if current == target:
                return path
            
            if current not in visited:
                visited.add(current)
                
                for neighbor in self.graph[current]:
                    if neighbor not in visited:
                        stack.append((neighbor, path + [neighbor]))
        
        return None

# 테스트
graph = Graph()
graph.add_edge(0, 1)
graph.add_edge(0, 2)
graph.add_edge(1, 2)
graph.add_edge(2, 0)
graph.add_edge(2, 3)
graph.add_edge(3, 3)

print("=== 그래프 DFS 비교 ===")
print("그래프 구조:")
for vertex, neighbors in graph.graph.items():
    print(f"{vertex}: {neighbors}")

print("\n재귀 DFS:")
graph.dfs_recursive(2)

print("\n스택 DFS:")
graph.dfs_iterative_with_stack(2)

print("\n경로 탐색 (0 -> 3):")
path = graph.dfs_path_finding(0, 3)
print(f"경로: {path}")
```

### 2-2 트리의 DFS 구현

```python
class TreeNode:
    """트리 노드 클래스"""
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class TreeDFS:
    """트리의 DFS 구현"""
    
    @staticmethod
    def dfs_preorder_recursive(root):
        """재귀를 이용한 전위 순회 (Root -> Left -> Right)"""
        if not root:
            return []
        
        result = [root.val]
        result.extend(TreeDFS.dfs_preorder_recursive(root.left))
        result.extend(TreeDFS.dfs_preorder_recursive(root.right))
        return result
    
    @staticmethod
    def dfs_preorder_iterative(root):
        """스택을 이용한 전위 순회"""
        if not root:
            return []
        
        result = []
        stack = [root]
        
        while stack:
            node = stack.pop()
            result.append(node.val)
            
            # 오른쪽을 먼저 스택에 추가 (왼쪽이 먼저 처리되도록)
            if node.right:
                stack.append(node.right)
            if node.left:
                stack.append(node.left)
        
        return result
    
    @staticmethod
    def dfs_inorder_recursive(root):
        """재귀를 이용한 중위 순회 (Left -> Root -> Right)"""
        if not root:
            return []
        
        result = []
        result.extend(TreeDFS.dfs_inorder_recursive(root.left))
        result.append(root.val)
        result.extend(TreeDFS.dfs_inorder_recursive(root.right))
        return result
    
    @staticmethod
    def dfs_inorder_iterative(root):
        """스택을 이용한 중위 순회"""
        if not root:
            return []
        
        result = []
        stack = []
        current = root
        
        while stack or current:
            # 현재 노드의 모든 왼쪽 자식들을 스택에 추가
            while current:
                stack.append(current)
                current = current.left
            
            # 스택에서 노드를 꺼내서 처리
            current = stack.pop()
            result.append(current.val)
            
            # 오른쪽 서브트리로 이동
            current = current.right
        
        return result
    
    @staticmethod
    def dfs_postorder_recursive(root):
        """재귀를 이용한 후위 순회 (Left -> Right -> Root)"""
        if not root:
            return []
        
        result = []
        result.extend(TreeDFS.dfs_postorder_recursive(root.left))
        result.extend(TreeDFS.dfs_postorder_recursive(root.right))
        result.append(root.val)
        return result
    
    @staticmethod
    def dfs_postorder_iterative(root):
        """스택을 이용한 후위 순회"""
        if not root:
            return []
        
        result = []
        stack = []
        last_visited = None
        current = root
        
        while stack or current:
            if current:
                stack.append(current)
                current = current.left
            else:
                peek_node = stack[-1]
                if peek_node.right and last_visited != peek_node.right:
                    current = peek_node.right
                else:
                    result.append(peek_node.val)
                    last_visited = stack.pop()
        
        return result

# 테스트용 트리 생성
def create_test_tree():
    """테스트용 이진 트리 생성
           1
          / \
         2   3
        / \
       4   5
    """
    root = TreeNode(1)
    root.left = TreeNode(2)
    root.right = TreeNode(3)
    root.left.left = TreeNode(4)
    root.left.right = TreeNode(5)
    return root

# 테스트
tree = create_test_tree()

print("=== 트리 DFS 순회 비교 ===")
print("트리 구조:")
print("    1")
print("   / \\")
print("  2   3")
print(" / \\")
print("4   5")

print("\n전위 순회 (Root -> Left -> Right):")
recursive_pre = TreeDFS.dfs_preorder_recursive(tree)
iterative_pre = TreeDFS.dfs_preorder_iterative(tree)
print(f"재귀: {recursive_pre}")
print(f"반복: {iterative_pre}")
print(f"일치: {recursive_pre == iterative_pre}")

print("\n중위 순회 (Left -> Root -> Right):")
recursive_in = TreeDFS.dfs_inorder_recursive(tree)
iterative_in = TreeDFS.dfs_inorder_iterative(tree)
print(f"재귀: {recursive_in}")
print(f"반복: {iterative_in}")
print(f"일치: {recursive_in == iterative_in}")

print("\n후위 순회 (Left -> Right -> Root):")
recursive_post = TreeDFS.dfs_postorder_recursive(tree)
iterative_post = TreeDFS.dfs_postorder_iterative(tree)
print(f"재귀: {recursive_post}")
print(f"반복: {iterative_post}")
print(f"일치: {recursive_post == iterative_post}")
```

## 3. 스택 기반 알고리즘 최적화

스택을 이용하여 재귀 알고리즘을 반복 알고리즘으로 변환하면 메모리 사용량을 줄이고 스택 오버플로우를 방지할 수 있습니다.

### 3-1 하노이 탑 문제의 스택 변환

```python
def hanoi_recursive(n, source, target, auxiliary):
    """재귀를 이용한 하노이 탑"""
    if n == 1:
        print(f"원판 1을 {source}에서 {target}로 이동")
        return
    
    hanoi_recursive(n - 1, source, auxiliary, target)
    print(f"원판 {n}을 {source}에서 {target}로 이동")
    hanoi_recursive(n - 1, auxiliary, target, source)

def hanoi_iterative_with_stack(n, source, target, auxiliary):
    """
    스택을 이용한 하노이 탑 (재귀를 반복문으로 변환)
    Args:
        n: 원판의 개수
        source: 시작 기둥
        target: 목표 기둥
        auxiliary: 보조 기둥
    """
    # 스택에 저장할 정보: (원판수, 시작기둥, 목표기둥, 보조기둥)
    stack = [(n, source, target, auxiliary)]
    
    while stack:
        disks, src, tgt, aux = stack.pop()
        
        if disks == 1:
            print(f"원판 1을 {src}에서 {tgt}로 이동")
        else:
            # 재귀 호출 순서를 역순으로 스택에 추가
            # 1. auxiliary에서 target으로 이동 (hanoi(n-1, aux, target, source))
            stack.append((disks - 1, aux, tgt, src))
            
            # 2. 가장 큰 원판 이동
            stack.append((1, src, tgt, aux))
            
            # 3. source에서 auxiliary로 이동 (hanoi(n-1, source, aux, target))
            stack.append((disks - 1, src, aux, tgt))

# 테스트
print("=== 하노이 탑 비교 ===")
n = 3

print("재귀 방법:")
hanoi_recursive(n, 'A', 'C', 'B')

print("\n스택 방법:")
hanoi_iterative_with_stack(n, 'A', 'C', 'B')
```

### 3-2 스택 오버플로우 방지와 메모리 최적화

```python
import sys

def fibonacci_recursive_limited(n, max_depth=1000):
    """재귀 깊이 제한이 있는 피보나치 (스택 오버플로우 방지)"""
    if n > max_depth:
        print(f"재귀 깊이 제한 ({max_depth}) 초과, 스택 방식으로 전환")
        return fibonacci_iterative_optimized(n)
    
    if n <= 1:
        return n
    
    return fibonacci_recursive_limited(n - 1, max_depth) + fibonacci_recursive_limited(n - 2, max_depth)

def fibonacci_iterative_optimized(n):
    """최적화된 반복적 피보나치 (메모리 효율적)"""
    if n <= 1:
        return n
    
    # 두 개의 변수만 사용하여 메모리 절약
    a, b = 0, 1
    for _ in range(2, n + 1):
        a, b = b, a + b
    
    return b

def fibonacci_with_memory_management(n):
    """메모리 관리를 고려한 피보나치"""
    # 큰 수에 대해서는 반복적 방법 사용
    if n > 50:
        return fibonacci_iterative_optimized(n)
    
    # 작은 수에 대해서는 재귀 사용 (코드 간결성)
    if n <= 1:
        return n
    
    return fibonacci_with_memory_management(n - 1) + fibonacci_with_memory_management(n - 2)

# 테스트
print("=== 메모리 최적화 비교 ===")

# 작은 수 테스트
small_n = 10
recursive_result = fibonacci_recursive_limited(small_n)
iterative_result = fibonacci_iterative_optimized(small_n)
print(f"n={small_n}: 재귀={recursive_result}, 반복={iterative_result}")

# 큰 수 테스트
large_n = 1000
print(f"\nn={large_n} (큰 수):")
try:
    # 재귀 방식은 스택 오버플로우 위험
    print("재귀 방식은 스택 오버플로우 위험이 있어 스킵")
except:
    print("재귀 방식에서 오류 발생")

iterative_result = fibonacci_iterative_optimized(large_n)
print(f"반복 방식: {iterative_result}")

# 메모리 사용량 비교
import psutil
import os

def get_memory_usage():
    """현재 프로세스의 메모리 사용량 반환 (MB)"""
    process = psutil.Process(os.getpid())
    return process.memory_info().rss / 1024 / 1024

print(f"\n현재 메모리 사용량: {get_memory_usage():.2f} MB")
```

## 4. 고급 스택 알고리즘

### 4-1 모노톤 스택 (Monotonic Stack)

```python
def next_greater_element(nums):
    """
    모노톤 스택을 이용한 다음 큰 원소 찾기
    각 원소에 대해 오른쪽에서 첫 번째로 큰 원소를 찾음
    Args:
        nums (list): 정수 배열
    Returns:
        list: 각 위치의 다음 큰 원소 (없으면 -1)
    """
    n = len(nums)
    result = [-1] * n
    stack = []  # 인덱스를 저장하는 스택
    
    for i in range(n):
        # 현재 원소가 스택의 top 원소보다 큰 경우
        while stack and nums[stack[-1]] < nums[i]:
            index = stack.pop()
            result[index] = nums[i]
        
        stack.append(i)
    
    return result

def next_smaller_element(nums):
    """
    모노톤 스택을 이용한 다음 작은 원소 찾기
    """
    n = len(nums)
    result = [-1] * n
    stack = []
    
    for i in range(n):
        while stack and nums[stack[-1]] > nums[i]:
            index = stack.pop()
            result[index] = nums[i]
        
        stack.append(i)
    
    return result

# 테스트
test_array = [2, 1, 2, 4, 3, 1]
print("=== 모노톤 스택 예제 ===")
print(f"원본 배열: {test_array}")

next_greater = next_greater_element(test_array)
print(f"다음 큰 원소: {next_greater}")

next_smaller = next_smaller_element(test_array)
print(f"다음 작은 원소: {next_smaller}")

# 시각적 설명
def explain_monotonic_stack(nums):
    """모노톤 스택 동작 과정 설명"""
    print(f"\n모노톤 스택 동작 과정 (배열: {nums}):")
    n = len(nums)
    stack = []
    
    for i in range(n):
        print(f"\n인덱스 {i}, 원소 {nums[i]} 처리:")
        print(f"현재 스택 (인덱스): {stack}")
        
        while stack and nums[stack[-1]] < nums[i]:
            popped_index = stack.pop()
            print(f"  스택에서 {popped_index} 제거: nums[{popped_index}]={nums[popped_index]} < nums[{i}]={nums[i]}")
        
        stack.append(i)
        print(f"  {i} 추가 후 스택: {stack}")

explain_monotonic_stack([2, 1, 2, 4, 3, 1])
```

### 4-2 스택을 이용한 히스토그램 최대 직사각형

```python
def largest_rectangle_area(heights):
    """
    스택을 이용한 히스토그램에서 최대 직사각형 넓이 구하기
    Args:
        heights (list): 히스토그램의 높이 배열
    Returns:
        int: 최대 직사각형의 넓이
    """
    stack = []
    max_area = 0
    
    for i, height in enumerate(heights):
        # 현재 높이가 스택의 top 높이보다 작은 경우
        while stack and heights[stack[-1]] > height:
            h = heights[stack.pop()]
            width = i if not stack else i - stack[-1] - 1
            max_area = max(max_area, h * width)
        
        stack.append(i)
    
    # 스택에 남은 원소들 처리
    while stack:
        h = heights[stack.pop()]
        width = len(heights) if not stack else len(heights) - stack[-1] - 1
        max_area = max(max_area, h * width)
    
    return max_area

# 테스트
test_heights = [2, 1, 5, 6, 2, 3]
print("=== 히스토그램 최대 직사각형 ===")
print(f"히스토그램 높이: {test_heights}")
max_area = largest_rectangle_area(test_heights)
print(f"최대 직사각형 넓이: {max_area}")

# 시각적 표현
def visualize_histogram(heights):
    """히스토그램을 시각적으로 표현"""
    print("\n히스토그램 시각화:")
    max_height = max(heights) if heights else 0
    
    for level in range(max_height, 0, -1):
        line = ""
        for height in heights:
            if height >= level:
                line += "█ "
            else:
                line += "  "
        print(line)
    
    # 인덱스 표시
    index_line = ""
    for i in range(len(heights)):
        index_line += f"{i} "
    print(index_line)

visualize_histogram(test_heights)
```

## 정리

이번 포스트에서는 스택의 고급 활용과 알고리즘 최적화 기법들을 살펴보았습니다.

**고급 활용 정리**
1. **재귀와 호출 스택**: 함수 호출 메커니즘의 이해와 스택 오버플로우 방지
2. **DFS 알고리즘**: 그래프와 트리 탐색에서 스택의 핵심 역할
3. **알고리즘 최적화**: 재귀를 반복문으로 변환하여 메모리 효율성 향상
4. **모노톤 스택**: 특정 조건을 만족하는 원소들을 효율적으로 찾는 기법
5. **고급 문제 해결**: 히스토그램, 하노이 탑 등 복잡한 문제의 스택 활용

**스택 고급 활용의 핵심 원칙**
- **메모리 효율성**: 재귀 대신 반복문 사용으로 스택 오버플로우 방지
- **상태 관리**: 복잡한 알고리즘에서 이전 상태를 스택으로 관리
- **최적화**: 모노톤 스택 등 특수한 스택 구조로 알고리즘 성능 향상
- **문제 분해**: 큰 문제를 작은 문제로 나누어 스택으로 순차 처리

**다음 학습 계획**
다음 포스트에서는 스택의 실무 활용과 실제 프로젝트에서의 적용 사례를 알아보겠습니다:
- [[자료구조] 스택(Stack) - 활용 - 3]({% post_url 2025-10-04-[자료구조] 스택(Stack) - 활용 - 3 %}) - 브라우저 히스토리, 실행 취소, 웹 서버, 계산기 등

# 📚 레퍼런스
- [Call Stack - MDN Web Docs](https://developer.mozilla.org/en-US/docs/Glossary/Call_stack)
- [Depth-First Search - Wikipedia](https://en.wikipedia.org/wiki/Depth-first_search)
- [Monotonic Stack - LeetCode](https://leetcode.com/tag/monotonic-stack/)
- [Largest Rectangle in Histogram - LeetCode](https://leetcode.com/problems/largest-rectangle-in-histogram/)

---
*이 포스트는 자료구조 학습 과정을 정리한 내용입니다.*
