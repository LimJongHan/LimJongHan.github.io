---
layout: post
title: "[학습] [자료구조] 자료구조와 알고리즘 개요"
date: 2025-10-02 10:00:00 +0900
categories: [학습, 자료구조]
tags: [자료구조, 알고리즘, 추상자료형, 시간복잡도, 빅오표기법]
author: LimJongHan
---
# 📖 관련된 내 포스팅
- 첫 번째 학습 포스트입니다.

# 📝 내용

## 개요

자료구조와 알고리즘은 컴퓨터 과학의 핵심 기초 지식입니다. 프로그래밍을 배우는 모든 개발자들이 반드시 알아야 하는 필수 개념으로, 효율적인 프로그램을 작성하는 데 있어 가장 중요한 기반이 됩니다.

**왜 자료구조와 알고리즘을 배워야 할까요?**
- 🚀 **성능 최적화**: 같은 문제를 해결하더라도 더 빠르고 효율적인 방법을 찾을 수 있습니다
- 🧠 **문제 해결 능력**: 복잡한 문제를 체계적으로 접근하고 해결할 수 있는 사고력을 기릅니다
- 💼 **취업 준비**: 대부분의 IT 기업에서 코딩 테스트나 면접에서 필수적으로 다루는 주제입니다
- 🔧 **실무 적용**: 실제 프로젝트에서 데이터를 효율적으로 관리하고 처리할 수 있습니다

이번 포스트에서는 자료구조와 알고리즘의 기본 개념, 추상자료형, 그리고 알고리즘 성능 분석에 대해 자세히 알아보겠습니다.

## 핵심 내용

#### 2-1 자료구조 개요

##### 2-1-1 자료구조와 알고리즘 개요

**자료구조(Data Structure)**란?
- 데이터를 효율적으로 저장하고 관리하는 방법
- 데이터의 논리적 관계와 물리적 저장 방식을 정의
- 프로그램의 성능에 직접적인 영향을 미침

**알고리즘(Algorithm)**이란?
- 문제를 해결하기 위한 단계별 절차
- 입력을 받아서 출력을 생성하는 명확한 규칙의 집합
- 유한한 시간 내에 종료되어야 함

**자료구조와 알고리즘의 관계**
```
자료구조 + 알고리즘 = 프로그램
```
- 자료구조는 알고리즘의 재료가 되고, 알고리즘은 자료구조를 활용하여 문제를 해결
- 서로 밀접한 관계를 가지며, 적절한 자료구조 선택이 알고리즘의 효율성을 좌우

**실제 예시로 이해하기**
```python
# 나쁜 예: 리스트에서 특정 값 찾기 (O(n))
def find_value_bad(data_list, target):
    for i in range(len(data_list)):
        if data_list[i] == target:
            return i
    return -1

# 좋은 예: 정렬된 리스트에서 이진 탐색 (O(log n))
def find_value_good(sorted_list, target):
    left, right = 0, len(sorted_list) - 1
    while left <= right:
        mid = (left + right) // 2
        if sorted_list[mid] == target:
            return mid
        elif sorted_list[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return -1
```

##### 2-1-2 추상자료형

**추상화(Abstraction)**
- 복잡한 시스템을 간략화된 기술 또는 명세로 표현
- 시스템의 핵심적인 구조나 동작에만 집중
- 불필요한 세부사항은 숨기고 중요한 부분만 강조

**자료형(Data Type)**
- 데이터의 집합과 그 데이터에 대한 연산의 집합
- 예: 정수형(int) = {..., -2, -1, 0, 1, 2, ...} + {+, -, *, /, ==, !=, ...}

**추상자료형(Abstract Data Type, ADT)**
- 데이터 타입을 추상적(수학적)으로 정의한 것
- **"무엇(What)"**을 정의: 데이터나 연산이 무엇인가를 정의
- **"어떻게(How)"**는 정의하지 않음: 구현 방법은 숨김
- 객체를 담으려는 공간의 type을 ADT라고 함

**ADT의 특징**
1. **캡슐화**: 데이터와 연산을 하나의 단위로 묶음
2. **정보 은닉**: 구현 세부사항을 외부에서 볼 수 없게 함
3. **재사용성**: 다양한 방식으로 구현 가능
4. **표준화**: 인터페이스가 명확하게 정의됨

**실무에서의 ADT 예시**
- Python의 `list`, `dict`, `set`
- NumPy의 `ndarray`
- Pandas의 `DataFrame`, `Series`
- 데이터베이스의 테이블 구조

**구체적인 ADT 예시: 정수 집합**

```python
# ADT: 정수 집합 (Integer Set)
class IntegerSet:
    """
    데이터: 1에서 시작하여 INT_MAX까지의 순서화된 정수의 부분 범위
    연산: 집합에 대한 기본 연산들
    """
    
    def __init__(self):
        self.elements = set()
    
    def add(self, x, y):
        """x+y가 INT_MAX보다 작으면 x+y를 반환"""
        result = x + y
        if result < 2**31 - 1:  # INT_MAX 대신 Python의 최대값
            self.elements.add(result)
            return result
        return None
    
    def distance(self, x, y):
        """x가 y보다 크면 x-y를 반환하고 작으면 y-x를 반환"""
        return abs(x - y)
    
    def equal(self, x, y):
        """x와 y가 같은 값이면 TRUE, 아니면 FALSE를 반환"""
        return x == y
    
    def successor(self, x):
        """x가 INT_MAX보다 작으면 x+1을 반환한다."""
        if x < 2**31 - 1:
            return x + 1
        return None
```

**다른 ADT 예시들**
```python
# 스택(Stack) ADT
class Stack:
    """LIFO(Last In, First Out) 구조"""
    def __init__(self):
        self.items = []
    
    def push(self, item):    # 삽입
        self.items.append(item)
    
    def pop(self):           # 삭제
        return self.items.pop() if self.items else None
    
    def peek(self):          # 맨 위 원소 확인
        return self.items[-1] if self.items else None
    
    def is_empty(self):      # 비어있는지 확인
        return len(self.items) == 0

# 큐(Queue) ADT  
class Queue:
    """FIFO(First In, First Out) 구조"""
    def __init__(self):
        self.items = []
    
    def enqueue(self, item):  # 삽입
        self.items.append(item)
    
    def dequeue(self):        # 삭제
        return self.items.pop(0) if self.items else None
    
    def front(self):          # 맨 앞 원소 확인
        return self.items[0] if self.items else None
    
    def is_empty(self):       # 비어있는지 확인
        return len(self.items) == 0
```

**추상자료형과 자료구조의 관계**
- 자료구조는 추상자료형을 프로그래밍 언어로 구현한 것
- 먼저 각 자료구조의 추상 자료형을 소개
- 추상 자료형의 구현 → Python 언어를 사용
  - 추상 자료형의 데이터: Class 사용
  - 추상 자료형의 연산: 메서드(함수)를 사용
- 다른 방법: 객체지향언어(C++, Java 등)

**ADT vs 자료구조 비교**
| 구분 | ADT | 자료구조 |
|------|-----|----------|
| 정의 | 추상적 명세 | 구체적 구현 |
| 관심사 | "무엇"을 할 수 있는가 | "어떻게" 구현할 것인가 |
| 예시 | 스택의 인터페이스 | 배열로 구현한 스택, 연결리스트로 구현한 스택 |

**메모리와 변수에 대한 이해**
- **Type**: 정수형(int), 문자형(char), 실수형(float), ...
- **Variable vs Value**: `a = 10`에서 `a`는 변수(Variable), `10`은 값(Value)
- **메모리 할당**: 변수는 메모리 공간이 필요
  - `int`: 4byte (32bit 시스템)
  - `char`: 1byte
  - `float`: 4byte
  - `double`: 8byte

**실무에서의 ADT 활용**
```python
# 웹 개발에서의 스택 활용 예시
def check_html_tags(html_string):
    """HTML 태그의 올바른 중첩을 확인하는 함수"""
    stack = Stack()
    i = 0
    
    while i < len(html_string):
        if html_string[i] == '<':
            # 태그 시작
            if html_string[i+1] == '/':
                # 닫는 태그
                tag_end = html_string.find('>', i)
                tag = html_string[i+2:tag_end]
                if stack.is_empty() or stack.pop() != tag:
                    return False
            else:
                # 여는 태그
                tag_end = html_string.find('>', i)
                tag = html_string[i+1:tag_end]
                stack.push(tag)
            i = tag_end + 1
        else:
            i += 1
    
    return stack.is_empty()  # 모든 태그가 올바르게 닫혔는지 확인
```

#### 2-2 알고리즘 개요

##### 2-2-1 알고리즘 표현

알고리즘을 표현하는 방법은 여러 가지가 있으며, 각각의 장단점이 있습니다.

1. **자연어 표현**
   - 장점: 이해하기 쉽고 직관적
   - 단점: 모호할 수 있고, 정확한 구현이 어려움
   - 예시: "두 수를 비교해서 큰 수를 반환한다"

2. **Flowchart 표현**
   - 장점: 시각적으로 이해하기 쉬움, 제어 흐름이 명확
   - 단점: 복잡한 알고리즘은 다이어그램이 복잡해짐
   - 예시: 시작 → 입력 → 처리 → 판단 → 출력 → 종료

3. **Pseudo-code 표현**
   - 장점: 프로그래밍 언어에 독립적, 핵심 로직에 집중 가능
   - 단점: 표준화된 문법이 없어 개인차가 있음
   - 예시:
   ```
   ALGORITHM BinarySearch(A, target)
   INPUT: 정렬된 배열 A, 찾을 값 target
   OUTPUT: target의 인덱스 또는 -1
   
   left ← 0
   right ← length(A) - 1
   
   WHILE left ≤ right DO
       mid ← (left + right) / 2
       IF A[mid] = target THEN
           RETURN mid
       ELSE IF A[mid] < target THEN
           left ← mid + 1
       ELSE
           right ← mid - 1
       END IF
   END WHILE
   
   RETURN -1
   ```

4. **Program code 표현**
   - 장점: 바로 실행 가능, 정확한 구현
   - 단점: 특정 언어에 종속적, 세부 구현에 집중하게 됨
   - 예시: 위의 이진 탐색을 Python으로 구현

5. **혼합 표현**
   - 복잡한 알고리즘은 여러 표현을 종합적으로 활용
   - 전체적인 흐름은 Flowchart, 세부 로직은 Pseudo-code, 최종 구현은 Program code

##### 2-2-2 알고리즘 성능 분석

**알고리즘의 성능 분석기법**

알고리즘의 성능을 분석하는 방법은 크게 두 가지로 나뉩니다.

1. **실행시간을 측정하는 방법 (실험적 분석)**
   ```python
   from timeit import default_timer as timer
   import random
   
   def measure_algorithm_performance():
       # 테스트 데이터 생성
       data = [random.randint(1, 1000) for _ in range(10000)]
       
       # 알고리즘 실행 시간 측정
       start = timer()
       result = bubble_sort(data.copy())  # 정렬 알고리즘 실행
       end = timer()
       
       execution_time = end - start
       print(f"실행 시간: {execution_time:.6f}초")
       return execution_time
   ```
   
   **장점**: 실제 성능을 정확히 측정
   **단점**: 
   - 실제로 구현해야 함
   - 하드웨어, 운영체제, 프로그래밍 언어에 의존
   - 입력 데이터에 따라 결과가 달라짐
   - 다양한 입력 크기에 대해 테스트하기 어려움

2. **알고리즘의 복잡도를 분석하는 방법 (이론적 분석)**
   - **시간 복잡도(Time Complexity)**: 알고리즘이 실행되는데 걸리는 시간
   - **공간 복잡도(Space Complexity)**: 알고리즘이 사용하는 메모리 공간
   
   **장점**:
   - 하드웨어에 독립적
   - 입력 크기에 따른 성능 변화 예측 가능
   - 알고리즘 간의 성능 비교 용이
   
   **단점**:
   - 실제 실행 시간과는 차이가 있을 수 있음
   - 상수 계수는 무시됨

**실무에서의 성능 분석**
```python
# 성능 비교 예시: 선형 탐색 vs 이진 탐색
def performance_comparison():
    import time
    import random
    
    # 테스트 데이터 준비
    sizes = [1000, 10000, 100000]
    
    for size in sizes:
        data = sorted([random.randint(1, size*10) for _ in range(size)])
        target = random.choice(data)
        
        # 선형 탐색 시간 측정
        start = time.time()
        linear_search(data, target)
        linear_time = time.time() - start
        
        # 이진 탐색 시간 측정
        start = time.time()
        binary_search(data, target)
        binary_time = time.time() - start
        
        print(f"크기 {size}: 선형탐색 {linear_time:.6f}초, 이진탐색 {binary_time:.6f}초")
```

##### 2-2-3 알고리즘 성능분석

**알고리즘 성능 측정**
- **시간복잡도(Time Complexity)**: 알고리즘을 소요 시간을 기준으로 알고리즘 성능을 분석하는 방법
- **공간복잡도(Space Complexity)**: 알고리즘이 사용하는 메모리 공간을 기준으로 분석하는 방법

**알고리즘의 성능**
- 알고리즘 성능 표기: **빅오 표기법(Big-Oh Notation)**으로 O(f(n)) 형태
- 입력 크기 n에 대한 함수로 표현
- 최악의 경우를 기준으로 분석

**시간 복잡도**
- **알고리즘 수행에 필요한 연산의 개수**
- 입력 개수 n에 대한 함수 → 시간 복잡도 함수 T(n)
- 정밀계산 X → 대충 계산 (점근적 분석)

**구체적인 예시: n을 n번 더하는 문제**

```python
# 방법 1: 반복문 사용
def sum_n_method1(n):
    total = 0
    for i in range(n):  # n번 반복
        total += n      # n을 더함
    return total
# 시간복잡도: O(n)
# 연산 횟수: n번의 덧셈 + n번의 반복문 체크

# 방법 2: 곱셈 사용
def sum_n_method2(n):
    return n * n        # 한 번의 곱셈
# 시간복잡도: O(1)
# 연산 횟수: 1번의 곱셈

# 성능 비교
import time

def compare_performance():
    n = 1000000
    
    # 방법 1 측정
    start = time.time()
    result1 = sum_n_method1(n)
    time1 = time.time() - start
    
    # 방법 2 측정
    start = time.time()
    result2 = sum_n_method2(n)
    time2 = time.time() - start
    
    print(f"방법 1 (O(n)): {time1:.6f}초")
    print(f"방법 2 (O(1)): {time2:.6f}초")
    print(f"성능 차이: {time1/time2:.1f}배")

# 실행 결과 예시:
# 방법 1 (O(n)): 0.123456초
# 방법 2 (O(1)): 0.000001초
# 성능 차이: 123456.0배
```

**다른 복잡도 예시들**

```python
# O(n²) - 버블 정렬
def bubble_sort(arr):
    n = len(arr)
    for i in range(n):           # n번 반복
        for j in range(n-1):     # n-1번 반복
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
    return arr
# 시간복잡도: O(n²)

# O(log n) - 이진 탐색
def binary_search(arr, target):
    left, right = 0, len(arr) - 1
    while left <= right:
        mid = (left + right) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return -1
# 시간복잡도: O(log n)

# O(2^n) - 피보나치 수열 (비효율적 구현)
def fibonacci_inefficient(n):
    if n <= 1:
        return n
    return fibonacci_inefficient(n-1) + fibonacci_inefficient(n-2)
# 시간복잡도: O(2^n)
```

**빅오(Big-Oh) 표기법**
- 두 개의 함수 f(n)과 g(n)이 주어졌을 때, 모든 n ≥ n0에 대하여 |f(n)| ≤ c |g(n)| 을 만족하는 2개의 상수 c와 n0가 존재하면 f(n) = O(g(n))이다.
- 연산의 회수를 대략적(점근적)으로 표기한 것
- 빅오는 함수의 상한을 표시한다

**최고차항만 고려**: 시간 복잡도 함수에서 가장 영향을 크게 미치는 항만을 고려하면 충분하다.
- 계수도 별 신경 안 써: f(n) = 2n+1 → O(n)
- 상수항 무시: f(n) = n² + 1000 → O(n²)

**예시:**
- T(n) = 2n+1 → O(n)
- T(n) = 2^n + n^2 + 1 → O(2^n)
- T(n) = 3n² + 5n + 10 → O(n²)

**빅오 표기법의 사례 (성능 순서대로 외워야 함)**

| 복잡도 | 이름 | 설명 | 예시 |
|--------|------|------|------|
| O(1) | 상수형 | n과 무관하게 일정 | 배열 인덱스 접근, 해시 테이블 조회 |
| O(log n) | 로그형 | log₂n (밑이 2) | 이진 탐색, 균형 이진 트리 |
| O(n) | 선형 | n에 비례 | 선형 탐색, 단순 반복문 |
| O(n log n) | 로그선형 | n × log n | 병합 정렬, 힙 정렬 |
| O(n²) | 2차형 | n의 제곱에 비례 | 버블 정렬, 선택 정렬 |
| O(n³) | 3차형 | n의 세제곱에 비례 | 3중 반복문 |
| O(2^n) | 지수형 | 2의 n제곱에 비례 | 피보나치(비효율적), 부분집합 |
| O(n!) | 팩토리얼형 | n!에 비례 | 순열 생성, 외판원 문제 |

**성능 비교 시각화**
```
n=10일 때:
O(1)     = 1
O(log n) = 3.32
O(n)     = 10
O(n²)    = 100
O(2^n)   = 1024
O(n!)    = 3,628,800

n=100일 때:
O(1)     = 1
O(log n) = 6.64
O(n)     = 100
O(n²)    = 10,000
O(2^n)   = 1.27 × 10^30
O(n!)    = 9.33 × 10^157
```

> **실무 팁**: 적어도 O(n³)보다는 작아야 실용적으로 사용 가능합니다. O(2^n)이나 O(n!)은 매우 작은 입력에서만 사용 가능합니다.

**최선, 평균, 최악의 경우**
알고리즘의 수행 시간은 입력자료 집합에 따라 다를 수 있다.

- **최선의 경우 (Best Case)**: 수행 시간이 가장 빠른 경우
  - 의미 없는 경우가 많음
  - 실제 상황에서는 거의 발생하지 않음
  - 예: 정렬된 배열에서 선형 탐색으로 첫 번째 원소를 찾는 경우

- **평균의 경우 (Average Case)**: 수행 시간이 평균적인 경우
  - 정확히 계산하기 어려움
  - 입력 데이터의 분포에 따라 달라짐
  - 통계적 분석이 필요

- **최악의 경우 (Worst Case)**: 수행 시간이 가장 늦은 경우
  - 가장 널리 사용됨
  - 계산하기 쉽고 응용에 따라서 중요한 의미를 가질 수 있음
  - 시스템의 안정성을 보장할 수 있음

**실제 예시: 퀵 정렬의 경우들**
```python
def quick_sort(arr):
    if len(arr) <= 1:
        return arr
    
    pivot = arr[len(arr) // 2]
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]
    
    return quick_sort(left) + middle + quick_sort(right)

# 최선의 경우: O(n log n) - 피벗이 항상 중간값
# 평균의 경우: O(n log n) - 피벗이 무작위로 선택
# 최악의 경우: O(n²) - 피벗이 항상 최솟값 또는 최댓값
```

**실무에서의 고려사항**
- **웹 서버**: 최악의 경우를 고려하여 응답 시간을 보장해야 함
- **게임**: 평균적인 경우를 고려하여 사용자 경험을 최적화
- **데이터베이스**: 최악의 경우를 고려하여 쿼리 성능을 예측

## 정리

이번 포스트에서는 자료구조와 알고리즘의 기본 개념을 자세히 다뤘습니다:

**핵심 개념 정리**
1. **자료구조와 알고리즘의 관계**: 자료구조는 데이터를 저장하는 방법, 알고리즘은 데이터를 처리하는 방법
2. **추상자료형(ADT)**: 데이터와 연산을 추상적으로 정의한 것으로, "무엇"을 할 수 있는지는 정의하지만 "어떻게" 구현할지는 정의하지 않음
3. **자료구조**: 추상자료형을 프로그래밍 언어로 구체적으로 구현한 것
4. **알고리즘 성능 분석**: 시간복잡도와 공간복잡도를 통해 알고리즘의 효율성을 평가
5. **빅오 표기법**: 최고차항만 고려하여 알고리즘의 성능을 대략적으로 표현하는 표준 방법

**실무 적용 포인트**
- 🎯 **적절한 자료구조 선택**: 문제의 특성에 맞는 자료구조를 선택하는 것이 중요
- ⚡ **성능 최적화**: O(n²)보다는 O(n log n) 또는 O(n) 알고리즘을 우선 고려
- 🔍 **복잡도 분석**: 코드 작성 전에 시간복잡도를 먼저 분석해보기
- 📊 **최악의 경우 고려**: 시스템의 안정성을 위해 최악의 경우를 항상 고려

**다음 학습 계획**
다음 포스트에서는 구체적인 자료구조들에 대해 알아보겠습니다:
- 선형 자료구조: 배열, 연결리스트, 스택, 큐
- 비선형 자료구조: 트리, 그래프
- 각 자료구조의 ADT 정의와 Python 구현
- 실제 문제 해결에의 활용 사례

**추가 학습 자료**
- [백준](https://www.acmicpc.net/) - 한국의 대표적인 알고리즘 사이트
- [프로그래머스](https://programmers.co.kr/) - 실무 중심의 코딩 테스트

# 📚 레퍼런스
- [Big O Cheat Sheet](https://www.bigocheatsheet.com/) - 빅오 표기법 참고 자료
- [VisuAlgo](https://visualgo.net/) - 알고리즘 시각화 사이트
- [GeeksforGeeks](https://www.geeksforgeeks.org/) - 알고리즘과 자료구조 튜토리얼

---
*이 포스트는 자료구조와 알고리즘 학습 과정을 정리한 내용입니다.*
