---
layout: post
title: "[학습] [자료구조] 스택(Stack)"
date: 2025-10-04 22:50:00 +0900
categories: [학습, 자료구조]
tags: [자료구조, 스택, Stack, LIFO, Python, 배열, 연결리스트, 시간복잡도]
author: LimJongHan
toc: true
---

# 📖 관련된 내 포스팅
- [[학습] [자료구조] 자료구조와 알고리즘 개요]({% post_url 2025-10-02-자료구조와-알고리즘-개요 %})
- [[학습] [자료구조] 배열(Array)]({% post_url 2025-10-03-배열(Array) %})
- [[학습] [자료구조] 연결리스트(Linked List)]({% post_url 2025-10-04-연결리스트(Linked-List) %})

# 📝 내용

## 개요

스택(Stack)은 **LIFO(Last In, First Out)** 원칙을 따르는 선형 자료구조입니다. 마지막에 삽입된 원소가 가장 먼저 제거되는 구조로, 일상생활에서 접시를 쌓아놓는 것과 비슷한 개념입니다. 스택은 컴퓨터 과학의 여러 분야에서 핵심적인 역할을 하며, 특히 함수 호출, 표현식 계산, 알고리즘 구현 등에서 널리 사용됩니다.

**스택의 주요 특징:**
- **LIFO 구조**: 마지막에 들어온 원소가 가장 먼저 나감
- **제한된 접근**: 맨 위(top) 원소에만 접근 가능
- **단순한 구조**: 기본 연산이 push, pop, peek, isEmpty로 제한
- **효율적인 구현**: 배열이나 연결리스트로 간단히 구현 가능

이번 포스트에서는 스택의 기본 개념, 추상자료형 정의, 배열과 연결리스트를 이용한 구현, 그리고 스택의 시간복잡도 분석에 대해 자세히 알아보겠습니다.

## 1. 스택의 추상자료형(ADT)

**추상자료형(ADT)**으로서의 스택은 다음과 같이 정의할 수 있습니다.

**데이터**:
- `n`개의 원소 `e0, e1, ..., en-1`의 유한 시퀀스
- 모든 삽입과 삭제는 한쪽 끝(top)에서만 수행

**연산**:
- `push(item)`: 스택의 맨 위에 새로운 원소를 추가
- `pop()`: 스택의 맨 위 원소를 제거하고 반환
- `peek()` 또는 `top()`: 스택의 맨 위 원소를 제거하지 않고 반환
- `isEmpty()`: 스택이 비어있는지 확인
- `size()`: 스택에 저장된 원소의 개수 반환

### 1-1 스택의 시각적 표현

```
    ┌─────┐  ← top (맨 위)
    │  30 │
    ├─────┤
    │  20 │
    ├─────┤
    │  10 │
    └─────┘  ← bottom (맨 아래)
```

**스택 동작 예시:**
```
1. push(10):  [10]
2. push(20):  [10, 20]
3. push(30):  [10, 20, 30]
4. pop():     [10, 20]      (30 반환)
5. pop():     [10]          (20 반환)
6. peek():    [10]          (10 반환, 제거하지 않음)
```

## 2. 배열을 이용한 스택 구현

가장 직관적이고 간단한 스택 구현 방법입니다. Python 리스트를 활용하여 동적 크기의 스택을 만들 수 있습니다.

```python
class ArrayStack:
    """
    배열(리스트)을 이용한 스택 구현
    """
    def __init__(self):
        self._items = []  # Python 리스트를 스택으로 사용
        self._size = 0    # 스택의 크기

    def __len__(self):
        """스택의 크기 반환"""
        return self._size

    def __str__(self):
        """스택을 문자열로 표현 (디버깅용)"""
        return f"Stack({self._items[:self._size]})"

    def isEmpty(self):
        """스택이 비어있는지 확인 O(1)"""
        return self._size == 0

    def push(self, item):
        """
        스택의 맨 위에 원소 추가 O(1)
        Args:
            item: 추가할 원소
        """
        self._items.append(item)
        self._size += 1

    def pop(self):
        """
        스택의 맨 위 원소 제거 및 반환 O(1)
        Returns:
            any: 제거된 원소
        Raises:
            IndexError: 스택이 비어있을 때
        """
        if self.isEmpty():
            raise IndexError("Stack is empty")
        
        self._size -= 1
        return self._items.pop()

    def peek(self):
        """
        스택의 맨 위 원소 확인 (제거하지 않음) O(1)
        Returns:
            any: 맨 위 원소
        Raises:
            IndexError: 스택이 비어있을 때
        """
        if self.isEmpty():
            raise IndexError("Stack is empty")
        
        return self._items[self._size - 1]

    def size(self):
        """스택의 크기 반환 O(1)"""
        return self._size

    def display(self):
        """스택의 모든 원소를 출력 (디버깅용)"""
        print(f"Stack contents (top to bottom): {self._items[:self._size][::-1]}")

# 테스트
stack = ArrayStack()
print(f"초기 상태: {stack}")
print(f"비어있는가? {stack.isEmpty()}")

# 원소 추가
stack.push(10)
stack.push(20)
stack.push(30)
print(f"3개 원소 추가 후: {stack}")
print(f"크기: {len(stack)}")

# 맨 위 원소 확인
print(f"맨 위 원소: {stack.peek()}")

# 원소 제거
print(f"제거된 원소: {stack.pop()}")
print(f"제거 후: {stack}")
print(f"최종 크기: {len(stack)}")

stack.display()
```

## 3. 연결리스트를 이용한 스택 구현

연결리스트를 사용하면 동적 크기 조절이 더욱 유연하며, 메모리 효율성도 좋습니다.

```python
class ListNode:
    """연결리스트 노드 클래스"""
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

class LinkedListStack:
    """
    연결리스트를 이용한 스택 구현
    """
    def __init__(self):
        self._top = None  # 스택의 맨 위 노드를 가리키는 포인터
        self._size = 0    # 스택의 크기

    def __len__(self):
        """스택의 크기 반환"""
        return self._size

    def __str__(self):
        """스택을 문자열로 표현 (디버깅용)"""
        if self.isEmpty():
            return "Stack([])"
        
        items = []
        current = self._top
        while current:
            items.append(current.val)
            current = current.next
        
        return f"Stack({items})"

    def isEmpty(self):
        """스택이 비어있는지 확인 O(1)"""
        return self._top is None

    def push(self, item):
        """
        스택의 맨 위에 원소 추가 O(1)
        Args:
            item: 추가할 원소
        """
        new_node = ListNode(item)
        new_node.next = self._top  # 새로운 노드가 기존 top을 가리킴
        self._top = new_node       # top을 새로운 노드로 업데이트
        self._size += 1

    def pop(self):
        """
        스택의 맨 위 원소 제거 및 반환 O(1)
        Returns:
            any: 제거된 원소
        Raises:
            IndexError: 스택이 비어있을 때
        """
        if self.isEmpty():
            raise IndexError("Stack is empty")
        
        popped_item = self._top.val
        self._top = self._top.next  # top을 다음 노드로 이동
        self._size -= 1
        return popped_item

    def peek(self):
        """
        스택의 맨 위 원소 확인 (제거하지 않음) O(1)
        Returns:
            any: 맨 위 원소
        Raises:
            IndexError: 스택이 비어있을 때
        """
        if self.isEmpty():
            raise IndexError("Stack is empty")
        
        return self._top.val

    def size(self):
        """스택의 크기 반환 O(1)"""
        return self._size

    def display(self):
        """스택의 모든 원소를 출력 (디버깅용)"""
        if self.isEmpty():
            print("Stack is empty")
            return
        
        items = []
        current = self._top
        while current:
            items.append(current.val)
            current = current.next
        
        print(f"Stack contents (top to bottom): {items}")

# 테스트
linked_stack = LinkedListStack()
print(f"초기 상태: {linked_stack}")
print(f"비어있는가? {linked_stack.isEmpty()}")

# 원소 추가
linked_stack.push("첫번째")
linked_stack.push("두번째")
linked_stack.push("세번째")
print(f"3개 원소 추가 후: {linked_stack}")
print(f"크기: {len(linked_stack)}")

# 맨 위 원소 확인
print(f"맨 위 원소: {linked_stack.peek()}")

# 원소 제거
print(f"제거된 원소: {linked_stack.pop()}")
print(f"제거 후: {linked_stack}")
linked_stack.display()
```

## 4. Python 내장 자료구조 활용

Python에서는 리스트가 이미 스택의 모든 기능을 제공하므로, 간단한 스택이 필요한 경우 직접 사용할 수 있습니다.

```python
# Python 리스트를 스택으로 사용
def demonstrate_list_as_stack():
    """Python 리스트를 스택으로 사용하는 예시"""
    stack = []
    
    # push 연산 (append 사용)
    stack.append(1)
    stack.append(2)
    stack.append(3)
    print(f"push 후: {stack}")
    
    # peek 연산 (마지막 원소 확인)
    if stack:
        print(f"맨 위 원소: {stack[-1]}")
    
    # pop 연산
    while stack:
        popped = stack.pop()
        print(f"pop: {popped}, 남은 스택: {stack}")

demonstrate_list_as_stack()

# collections.deque 사용 (양방향 큐이지만 스택으로도 사용 가능)
from collections import deque

def demonstrate_deque_as_stack():
    """deque를 스택으로 사용하는 예시"""
    stack = deque()
    
    # push 연산 (append 사용)
    stack.append("A")
    stack.append("B")
    stack.append("C")
    print(f"deque push 후: {list(stack)}")
    
    # pop 연산 (pop 사용)
    while stack:
        popped = stack.pop()
        print(f"deque pop: {popped}, 남은 스택: {list(stack)}")

demonstrate_deque_as_stack()
```

## 5. 스택의 시간복잡도 분석

스택의 주요 연산별 시간복잡도는 다음과 같습니다.

| 연산 | 배열 구현 | 연결리스트 구현 | Python 리스트 | 설명 |
|------|-----------|-----------------|---------------|------|
| `push()` | O(1) | O(1) | O(1) | 맨 위에 원소 추가 |
| `pop()` | O(1) | O(1) | O(1) | 맨 위 원소 제거 |
| `peek()` | O(1) | O(1) | O(1) | 맨 위 원소 확인 |
| `isEmpty()` | O(1) | O(1) | O(1) | 비어있는지 확인 |
| `size()` | O(1) | O(1) | O(1) | 크기 반환 |

**공간복잡도:**
- **배열 구현**: O(n) - 고정 크기 배열의 경우 최대 크기만큼 메모리 할당
- **연결리스트 구현**: O(n) - 실제 사용하는 원소만큼만 메모리 사용
- **Python 리스트**: O(n) - 동적 배열로 필요에 따라 크기 조절

## 6. 스택 vs 다른 자료구조 비교

### 6-1 스택 vs 큐

| 특성 | 스택 (Stack) | 큐 (Queue) |
|------|--------------|------------|
| **구조** | LIFO (Last In, First Out) | FIFO (First In, First Out) |
| **접근 방식** | 한쪽 끝 (top)에서만 | 양쪽 끝 (front, rear) |
| **주요 연산** | push, pop, peek | enqueue, dequeue, front |
| **사용 예시** | 함수 호출, 괄호 매칭 | 대기열, BFS 알고리즘 |

### 6-2 스택 vs 배열

| 특성 | 스택 | 배열 |
|------|------|------|
| **접근 제한** | top에서만 접근 | 인덱스로 임의 접근 |
| **연산 제한** | push, pop만 가능 | 임의 위치 삽입/삭제 |
| **용도** | 특정 알고리즘, 제한적 접근 | 일반적인 데이터 저장 |
| **구현** | 배열이나 연결리스트로 구현 | 직접적인 자료구조 |

## 정리

이번 포스트에서는 스택의 기본 개념과 구현 방법에 대해 알아보았습니다.

**핵심 개념 정리**
1. **LIFO 구조**: 마지막에 들어온 원소가 가장 먼저 나가는 구조
2. **제한된 접근**: top에서만 원소 추가/제거 가능
3. **효율적인 연산**: 모든 기본 연산이 O(1) 시간복잡도
4. **다양한 구현**: 배열, 연결리스트, Python 내장 자료구조 활용 가능
5. **간단한 구조**: 구현이 쉽고 이해하기 쉬운 자료구조

**다음 학습 계획**
다음 포스트에서는 스택을 활용한 다양한 문제 해결 방법과 알고리즘에 대해 알아보겠습니다:
- [[학습] [자료구조] 스택(Stack) 활용 - 1. 예제]({% post_url 2025-10-04-스택(Stack)-활용-1-예제 %}) - 괄호 매칭, 후위 표기법 등 기본 문제들
- [[학습] [자료구조] 스택(Stack) 활용 - 2. 고급 활용]({% post_url 2025-10-04-스택(Stack)-활용-2-고급-활용 %}) - 재귀, DFS, 알고리즘 최적화
- [[학습] [자료구조] 스택(Stack) 활용 - 3. 실무 활용]({% post_url 2025-10-04-스택(Stack)-활용-3-실무-활용 %}) - 브라우저 히스토리, 실행 취소, 웹 서버 등

# 📚 레퍼런스
- [Stack Data Structure - Wikipedia](https://en.wikipedia.org/wiki/Stack_(abstract_data_type))
- [GeeksforGeeks - Stack Data Structure](https://www.geeksforgeeks.org/stack-data-structure-introduction-program/)
- [Python Data Structures - Official Documentation](https://docs.python.org/3/tutorial/datastructures.html)
- [Introduction to Algorithms - Thomas H. Cormen](https://mitpress.mit.edu/books/introduction-algorithms-third-edition)

---
*이 포스트는 자료구조 학습 과정을 정리한 내용입니다.*
