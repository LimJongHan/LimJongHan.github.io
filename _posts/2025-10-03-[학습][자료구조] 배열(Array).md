---
layout: post
title: "[학습] [자료구조] 배열(Array)"
date: 2025-10-03 01:30:00 +0900
categories: [학습, 자료구조]
tags: [배열, Array, 자료구조, 선형자료구조, 시간복잡도]
author: LimJongHan
toc: true
---

# 📖 관련된 내 포스팅
- [[학습] [자료구조] 자료구조와 알고리즘 개요]({% post_url 2025-10-02-자료구조와-알고리즘-개요 %})

# 📝 내용

## 개요

배열(Array)은 가장 기본적이면서도 가장 중요한 자료구조입니다. 프로그래밍을 배우는 모든 개발자가 처음 접하게 되는 자료구조이며, 다른 많은 자료구조들의 기반이 되는 핵심적인 자료구조입니다.

**배열이 중요한 이유:**
- 🏗️ **기본 구조**: 대부분의 자료구조가 배열을 기반으로 구현됨
- ⚡ **빠른 접근**: 인덱스를 통한 O(1) 시간에 원소에 접근 가능
- 💾 **메모리 효율**: 연속된 메모리 공간을 사용하여 캐시 효율성이 좋음
- 🎯 **단순함**: 이해하기 쉽고 구현이 간단함

이번 포스트에서는 배열의 기본 개념과 Python에서의 구현에 대해 알아보겠습니다.

## 핵심 내용

### 1. 배열의 정의와 특징

#### 1-1 배열이란?

**배열(Array)**이란?
- 동일한 타입의 데이터들이 연속된 메모리 공간에 저장되는 자료구조
- 각 원소는 고유한 인덱스(Index)를 가짐
- 인덱스를 통해 원소에 직접 접근 가능

**배열의 주요 특징:**
- **고정 크기**: 선언 시 크기가 결정되며, 크기 변경이 어려움
- **연속 메모리**: 모든 원소가 메모리에서 연속적으로 저장됨
- **동일 타입**: 모든 원소가 같은 데이터 타입이어야 함
- **인덱스 접근**: 0부터 시작하는 정수 인덱스로 접근

#### 1-2 Python에서의 배열과 리스트

**중요한 사실**: Python에서는 배열 대신 **리스트(list)**를 사용합니다. Python의 리스트는 사실상 **동적 배열(Dynamic Array)**입니다.

**Python 리스트의 특징:**
- **가변 크기**: 크기를 동적으로 조절할 수 있음
- **다양한 자료형**: 서로 다른 타입의 객체도 저장 가능
- **객체 참조 저장**: 실제 값이 아닌 객체의 참조(주소)를 저장
- **연속된 메모리**: 객체 참조들이 연속된 메모리 공간에 저장

```python
# Python 리스트 예시
arr = [1, "a", ("가", "나"), [1, 2, 3]]
print(f"리스트: {arr}")
print(f"타입들: {[type(x) for x in arr]}")
```

**리스트 vs 배열 비교표**

| 특징 | 배열 (C/Java) | Python 리스트 |
|------|---------------|---------------|
| 크기 | 고정 | 가변 |
| 자료형 | 동일해야 함 | 다양 가능 |
| 저장 방식 | 값 직접 저장 | 객체 참조 저장 |
| 메모리 효율 | 높음 | 상대적으로 낮음 |
| 접근 속도 | 빠름 | 상대적으로 느림 |

#### 1-3 Python array 모듈 사용

단일 자료형만 사용하는 경우, `array` 모듈을 사용할 수 있습니다:

```python
import array

# 정수 배열 생성
int_array = array.array('i', [1, 2, 3, 4, 5])
print(f"정수 배열: {int_array}")

# 부동소수점 배열 생성
float_array = array.array('d', [1.1, 2.2, 3.3])
print(f"부동소수점 배열: {float_array}")

# 배열 연산
int_array.append(6)
print(f"추가 후: {int_array}")
```

### 2. 배열의 추상자료형(ADT)

#### 2-1 배열 ADT 정의

```python
class Array:
    """
    배열(Array) 추상자료형
    
    데이터: 동일한 타입의 원소들이 인덱스로 접근 가능한 순서화된 집합
    연산: 배열에 대한 기본 연산들
    """
    
    def __init__(self, size, default_value=None):
        """크기가 size인 배열을 생성하고 default_value로 초기화"""
        pass
    
    def get(self, index):
        """인덱스 index에 있는 원소를 반환"""
        pass
    
    def set(self, index, value):
        """인덱스 index에 value를 저장"""
        pass
    
    def size(self):
        """배열의 크기를 반환"""
        pass
    
    def find(self, value):
        """배열에서 value를 찾아 인덱스를 반환, 없으면 -1 반환"""
        pass
```

### 3. 배열의 기본 구현

#### 3-1 간단한 배열 클래스

```python
class Array:
    """배열 클래스 - Python 리스트를 기반으로 구현"""
    
    def __init__(self, size, default_value=None):
        """
        크기가 size인 배열을 생성하고 default_value로 초기화
        
        Args:
            size (int): 배열의 크기
            default_value: 초기값 (기본값: None)
        """
        if size <= 0:
            raise ValueError("배열 크기는 양수여야 합니다")
        
        self._size = size
        self._data = [default_value] * size
    
    def get(self, index):
        """인덱스 index에 있는 원소를 반환"""
        if not self._is_valid_index(index):
            raise IndexError(f"인덱스 {index}는 범위를 벗어났습니다 (0-{self._size-1})")
        return self._data[index]
    
    def set(self, index, value):
        """인덱스 index에 value를 저장"""
        if not self._is_valid_index(index):
            raise IndexError(f"인덱스 {index}는 범위를 벗어났습니다 (0-{self._size-1})")
        self._data[index] = value
    
    def size(self):
        """배열의 크기를 반환"""
        return self._size
    
    def find(self, value):
        """배열에서 value를 찾아 인덱스를 반환"""
        for i in range(self._size):
            if self._data[i] == value:
                return i
        return -1
    
    def _is_valid_index(self, index):
        """인덱스가 유효한 범위에 있는지 확인"""
        return 0 <= index < self._size
    
    def __str__(self):
        """배열의 문자열 표현"""
        return f"Array({self._data})"
    
    def __getitem__(self, index):
        """[] 연산자 지원"""
        return self.get(index)
    
    def __setitem__(self, index, value):
        """[] 연산자로 할당 지원"""
        self.set(index, value)

# 사용 예시
if __name__ == "__main__":
    # 배열 생성
    arr = Array(5, 0)  # 크기 5, 초기값 0
    
    print(f"배열 크기: {arr.size()}")
    print(f"초기 배열: {arr}")
    
    # 값 설정
    for i in range(5):
        arr.set(i, i * 10)
    
    print(f"값 설정 후: {arr}")
    
    # 값 조회
    print(f"인덱스 2의 값: {arr.get(2)}")
    print(f"인덱스 3의 값: {arr[3]}")  # __getitem__ 사용
    
    # 값 수정
    arr.set(1, 99)
    arr[4] = 88  # __setitem__ 사용
    print(f"값 수정 후: {arr}")
    
    # 값 찾기
    print(f"값 30의 인덱스: {arr.find(30)}")
    print(f"값 100의 인덱스: {arr.find(100)}")
```

### 4. 배열의 시간복잡도

#### 4-1 기본 배열 연산의 시간복잡도

| 연산 | 시간복잡도 | 설명 |
|------|------------|------|
| 접근 (Access) | O(1) | 인덱스를 통한 직접 접근 |
| 검색 (Search) | O(n) | 순차 탐색 필요 |
| 삽입 (Insert) | O(1) | 끝에 삽입하는 경우 |
| 삽입 (Insert) | O(n) | 중간에 삽입하는 경우 (원소 이동 필요) |
| 삭제 (Delete) | O(1) | 끝에서 삭제하는 경우 |
| 삭제 (Delete) | O(n) | 중간에서 삭제하는 경우 (원소 이동 필요) |
| 업데이트 (Update) | O(1) | 인덱스를 통한 직접 접근 |

#### 4-2 Python 리스트의 시간복잡도

Python 리스트(동적 배열)의 주요 연산별 시간복잡도:

| 연산 | 시간복잡도 | 설명 |
|------|------------|------|
| 인덱스 접근 `lst[i]` | O(1) | 인덱스를 통한 직접 접근 |
| 맨 끝에 추가 `append()` | O(1) 평균 | 용량 부족 시에만 O(n) |
| 맨 끝 제거 `pop()` | O(1) | 맨 끝 원소 제거 |
| 중간 삽입 `insert()` | O(n) | 원소 이동 필요 |
| 중간 삭제 `remove()` | O(n) | 원소 이동 필요 |
| 검색 `index()` | O(n) | 순차 탐색 |
| 정렬 `sort()` | O(n log n) | TimSort 알고리즘 |

### 5. 간단한 배열 문제 예제

#### 5-1 배열에서 최댓값 찾기

```python
def find_maximum(arr):
    """배열에서 최댓값을 찾는 함수"""
    if not arr:
        return None
    
    maximum = arr[0]
    for i in range(1, len(arr)):
        if arr[i] > maximum:
            maximum = arr[i]
    
    return maximum

# 테스트
numbers = [3, 7, 2, 9, 1, 8, 5]
max_value = find_maximum(numbers)
print(f"배열: {numbers}")
print(f"최댓값: {max_value}")

# 시간복잡도: O(n), 공간복잡도: O(1)
```

#### 5-2 배열 역순으로 출력하기

```python
def reverse_array(arr):
    """배열을 역순으로 출력하는 함수"""
    for i in range(len(arr) - 1, -1, -1):
        print(arr[i], end=" ")
    print()

def reverse_array_in_place(arr):
    """배열을 제자리에서 역순으로 만드는 함수"""
    left = 0
    right = len(arr) - 1
    
    while left < right:
        arr[left], arr[right] = arr[right], arr[left]
        left += 1
        right -= 1
    
    return arr

# 테스트
numbers = [1, 2, 3, 4, 5]
print(f"원본: {numbers}")

print("역순 출력: ", end="")
reverse_array(numbers)

reversed_numbers = reverse_array_in_place(numbers.copy())
print(f"제자리 역순: {reversed_numbers}")

# 시간복잡도: O(n), 공간복잡도: O(1)
```

#### 5-3 배열에서 특정 값의 개수 세기

```python
def count_occurrences(arr, target):
    """배열에서 특정 값의 개수를 세는 함수"""
    count = 0
    for element in arr:
        if element == target:
            count += 1
    return count

# 테스트
numbers = [1, 2, 3, 2, 4, 2, 5]
target = 2
count = count_occurrences(numbers, target)
print(f"배열: {numbers}")
print(f"{target}의 개수: {count}")

# 시간복잡도: O(n), 공간복잡도: O(1)
```

### 6. 배열 vs 다른 자료구조 비교

#### 6-1 배열 vs 연결리스트

| 특성 | 배열 | 연결리스트 |
|------|------|------------|
| 메모리 사용 | 연속된 메모리 | 분산된 메모리 |
| 접근 시간 | O(1) | O(n) |
| 삽입/삭제 | O(n) | O(1) (위치를 알고 있는 경우) |
| 메모리 오버헤드 | 낮음 | 높음 (포인터 저장) |
| 캐시 효율성 | 높음 | 낮음 |
| 크기 변경 | 어려움 | 쉬움 |

#### 6-2 배열 vs 동적 배열

| 특성 | 배열 | 동적 배열 |
|------|------|------------|
| 크기 고정 | 예 | 아니오 |
| 메모리 사용량 | 예측 가능 | 변동적 |
| append 성능 | 불가능 | O(1) 평균 |
| 메모리 재할당 | 없음 | 필요시 발생 |

## 정리

이번 포스트에서는 배열 자료구조의 기본 개념을 알아보았습니다:

**핵심 개념 정리**
1. **배열의 정의**: 동일한 타입의 데이터들이 연속된 메모리 공간에 저장되는 자료구조
2. **배열의 특징**: 고정 크기, 연속 메모리, 인덱스 접근, 동일 타입
3. **Python 리스트**: 동적 배열로 구현되어 있으며, 다양한 타입 저장 가능
4. **시간복잡도**: 접근 O(1), 검색 O(n), 삽입/삭제는 위치에 따라 O(1) 또는 O(n)

**배열의 장단점**
- ✅ **장점**: 빠른 접근, 메모리 효율성, 캐시 친화적
- ❌ **단점**: 고정 크기, 삽입/삭제 비효율성

**다음 학습 계획**
다음 포스트에서는 배열을 활용한 다양한 문제 해결 방법과 알고리즘에 대해 알아보겠습니다:
- [[학습] [자료구조] 배열(Array) 활용 - 1. 예제]({% post_url 2025-10-03-배열(Array)-활용-1-예제 %}) - 실전 문제 해결 예제들
- [[학습] [자료구조] 배열(Array) 활용 - 2. 알고리즘 활용]({% post_url 2025-10-03-배열(Array)-활용-2-알고리즘-활용 %}) - 두 포인터, 슬라이딩 윈도우 등 고급 기법
- [[학습] [자료구조] 배열(Array) 활용 - 3. 실무 활용]({% post_url 2025-10-03-배열(Array)-활용-3-실무-활용 %}) - 웹 개발, 데이터 분석에서의 활용

# 📚 레퍼런스
- [좌충우돌, 파이썬으로 자료구조 구현하기 - 위키독스](https://wikidocs.net/189478) - Python으로 자료구조 구현하는 실전 가이드
- [Array Data Structure - Wikipedia](https://en.wikipedia.org/wiki/Array_data_structure)
- [Python Data Structures - Official Documentation](https://docs.python.org/3/tutorial/datastructures.html)

---
*이 포스트는 자료구조 학습 과정을 정리한 내용입니다.*