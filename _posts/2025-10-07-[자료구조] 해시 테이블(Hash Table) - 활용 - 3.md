---
layout: post
title: "[자료구조] 해시 테이블(Hash Table) - 활용 - 3"
date: 2025-10-07 16:20:00 +0900
categories: [자료구조, 해시테이블]
tags: [자료구조, 해시테이블, 캐싱, 세션관리, 데이터베이스, 인덱싱, 실무]
author: LimJongHan
toc: true
---

# 📖 관련된 내 포스팅
- [[자료구조] 자료구조와 알고리즘 개요]({% post_url 2025-10-02-[자료구조] 자료구조와 알고리즘 개요 %})
- [[자료구조] 해시 테이블(Hash Table) - 기본 예제]({% post_url 2025-10-07-[자료구조] 해시 테이블(Hash Table) - 기본 예제 %})
- [[자료구조] 해시 테이블 활용 - 1]({% post_url 2025-10-07-[자료구조] 해시 테이블(Hash Table) - 활용 - 1 %})
- [[자료구조] 해시 테이블 활용 - 2]({% post_url 2025-10-07-[자료구조] 해시 테이블(Hash Table) - 활용 - 2 %})

# 📝 내용

## 개요

해시 테이블은 실제 소프트웨어 개발과 시스템 설계에서 핵심적인 역할을 합니다. 이번 포스트에서는 실무에서 해시 테이블이 어떻게 활용되는지 살펴보겠습니다.

**다룰 실무 활용 사례들:**
- **웹 캐싱 시스템**: Redis 스타일 캐시 구현
- **세션 관리**: 사용자 세션 저장 및 관리
- **데이터베이스 인덱싱**: 빠른 데이터 검색
- **URL 단축 서비스**: 짧은 URL 생성 및 매핑
- **레이트 리미팅**: API 요청 속도 제한

## 1. 웹 캐싱 시스템

Redis와 유사한 인메모리 캐시 시스템을 구현합니다.

### 1-1 기본 캐시 시스템

```python
import time
from typing import Any, Optional
from collections import OrderedDict

class WebCache:
    """
    웹 캐싱 시스템
    LRU 제거 정책 + TTL 지원
    """
    def __init__(self, max_size=1000, default_ttl=300):
        self.max_size = max_size
        self.default_ttl = default_ttl
        self.cache = OrderedDict()
        self.ttl_map = {}
        self.stats = {
            'hits': 0,
            'misses': 0,
            'evictions': 0
        }
    
    def get(self, key: str) -> Optional[Any]:
        """
        캐시에서 값 가져오기
        Args:
            key: 캐시 키
        Returns:
            Any: 캐시된 값, 없으면 None
        """
        # TTL 확인
        if key in self.ttl_map:
            if time.time() > self.ttl_map[key]:
                # 만료된 항목 제거
                del self.cache[key]
                del self.ttl_map[key]
                self.stats['misses'] += 1
                return None
        
        if key in self.cache:
            # LRU 업데이트 (맨 뒤로 이동)
            self.cache.move_to_end(key)
            self.stats['hits'] += 1
            return self.cache[key]
        
        self.stats['misses'] += 1
        return None
    
    def set(self, key: str, value: Any, ttl: Optional[int] = None):
        """
        캐시에 값 저장
        Args:
            key: 캐시 키
            value: 저장할 값
            ttl: 생존 시간 (초), None이면 기본값 사용
        """
        if key in self.cache:
            # 기존 키 업데이트
            self.cache.move_to_end(key)
        else:
            # 새 키 추가
            if len(self.cache) >= self.max_size:
                # LRU 제거
                oldest_key = next(iter(self.cache))
                del self.cache[oldest_key]
                if oldest_key in self.ttl_map:
                    del self.ttl_map[oldest_key]
                self.stats['evictions'] += 1
        
        self.cache[key] = value
        
        # TTL 설정
        if ttl is None:
            ttl = self.default_ttl
        self.ttl_map[key] = time.time() + ttl
    
    def delete(self, key: str) -> bool:
        """캐시에서 키 삭제"""
        if key in self.cache:
            del self.cache[key]
            if key in self.ttl_map:
                del self.ttl_map[key]
            return True
        return False
    
    def get_stats(self):
        """캐시 통계 반환"""
        total_requests = self.stats['hits'] + self.stats['misses']
        hit_rate = self.stats['hits'] / total_requests if total_requests > 0 else 0
        
        return {
            **self.stats,
            'total_requests': total_requests,
            'hit_rate': hit_rate,
            'size': len(self.cache)
        }
    
    def clear(self):
        """캐시 전체 삭제"""
        self.cache.clear()
        self.ttl_map.clear()

# 테스트
cache = WebCache(max_size=3, default_ttl=5)

print("=== 웹 캐시 시스템 테스트 ===")

# 데이터 저장
cache.set("user:1", {"name": "홍길동", "age": 30})
cache.set("user:2", {"name": "김철수", "age": 25})
cache.set("user:3", {"name": "이영희", "age": 28})

# 데이터 조회
print(f"user:1: {cache.get('user:1')}")
print(f"user:2: {cache.get('user:2')}")

# LRU 테스트 (user:1이 최근 사용되었으므로 user:2가 제거됨)
cache.set("user:4", {"name": "박민수", "age": 32})

print(f"\nuser:2 (LRU 제거됨): {cache.get('user:2')}")
print(f"user:4 (새로 추가): {cache.get('user:4')}")

# 통계
print(f"\n캐시 통계: {cache.get_stats()}")

# TTL 테스트
print("\n5초 대기 후 조회...")
time.sleep(5)
print(f"user:1 (TTL 만료): {cache.get('user:1')}")
```

### 1-2 계층적 캐시 시스템

```python
class TieredCache:
    """
    계층적 캐시 시스템 (L1, L2 캐시)
    """
    def __init__(self, l1_size=100, l2_size=1000):
        self.l1_cache = WebCache(max_size=l1_size, default_ttl=60)  # 빠른 L1
        self.l2_cache = WebCache(max_size=l2_size, default_ttl=300)  # 큰 L2
    
    def get(self, key: str) -> Optional[Any]:
        """계층적 캐시 조회"""
        # L1 캐시 확인
        value = self.l1_cache.get(key)
        if value is not None:
            return value
        
        # L2 캐시 확인
        value = self.l2_cache.get(key)
        if value is not None:
            # L1 캐시에 승격
            self.l1_cache.set(key, value)
            return value
        
        return None
    
    def set(self, key: str, value: Any):
        """양쪽 캐시에 저장"""
        self.l1_cache.set(key, value)
        self.l2_cache.set(key, value)
```

## 2. 세션 관리 시스템

웹 애플리케이션의 사용자 세션을 관리하는 시스템입니다.

```python
import uuid
import hashlib
from datetime import datetime, timedelta

class Session:
    """세션 클래스"""
    def __init__(self, session_id, user_id=None):
        self.session_id = session_id
        self.user_id = user_id
        self.created_at = datetime.now()
        self.last_accessed = datetime.now()
        self.data = {}
    
    def update_access(self):
        """마지막 접근 시간 업데이트"""
        self.last_accessed = datetime.now()
    
    def is_expired(self, timeout_minutes=30):
        """세션 만료 여부 확인"""
        expiry_time = self.last_accessed + timedelta(minutes=timeout_minutes)
        return datetime.now() > expiry_time

class SessionManager:
    """
    세션 관리자
    """
    def __init__(self, timeout_minutes=30):
        self.sessions = {}  # session_id -> Session
        self.user_sessions = {}  # user_id -> [session_ids]
        self.timeout_minutes = timeout_minutes
    
    def create_session(self, user_id=None):
        """
        새 세션 생성
        Args:
            user_id: 사용자 ID (선택)
        Returns:
            str: 세션 ID
        """
        session_id = str(uuid.uuid4())
        session = Session(session_id, user_id)
        
        self.sessions[session_id] = session
        
        if user_id:
            if user_id not in self.user_sessions:
                self.user_sessions[user_id] = []
            self.user_sessions[user_id].append(session_id)
        
        print(f"세션 생성: {session_id} (사용자: {user_id or '게스트'})")
        return session_id
    
    def get_session(self, session_id):
        """
        세션 가져오기
        Args:
            session_id: 세션 ID
        Returns:
            Session: 세션 객체, 없거나 만료되면 None
        """
        if session_id not in self.sessions:
            return None
        
        session = self.sessions[session_id]
        
        # 만료 확인
        if session.is_expired(self.timeout_minutes):
            self.destroy_session(session_id)
            return None
        
        # 접근 시간 업데이트
        session.update_access()
        return session
    
    def set_session_data(self, session_id, key, value):
        """세션 데이터 저장"""
        session = self.get_session(session_id)
        if session:
            session.data[key] = value
            return True
        return False
    
    def get_session_data(self, session_id, key):
        """세션 데이터 조회"""
        session = self.get_session(session_id)
        if session:
            return session.data.get(key)
        return None
    
    def destroy_session(self, session_id):
        """세션 삭제"""
        if session_id in self.sessions:
            session = self.sessions[session_id]
            
            # 사용자 세션 목록에서 제거
            if session.user_id in self.user_sessions:
                self.user_sessions[session.user_id].remove(session_id)
                if not self.user_sessions[session.user_id]:
                    del self.user_sessions[session.user_id]
            
            del self.sessions[session_id]
            print(f"세션 삭제: {session_id}")
            return True
        return False
    
    def cleanup_expired_sessions(self):
        """만료된 세션 정리"""
        expired = []
        
        for session_id, session in self.sessions.items():
            if session.is_expired(self.timeout_minutes):
                expired.append(session_id)
        
        for session_id in expired:
            self.destroy_session(session_id)
        
        print(f"만료된 세션 {len(expired)}개 정리됨")
    
    def get_user_sessions(self, user_id):
        """사용자의 모든 세션 조회"""
        return self.user_sessions.get(user_id, [])
    
    def get_stats(self):
        """세션 통계"""
        active_sessions = len(self.sessions)
        total_users = len(self.user_sessions)
        
        return {
            'active_sessions': active_sessions,
            'total_users': total_users,
            'avg_sessions_per_user': active_sessions / total_users if total_users > 0 else 0
        }

# 테스트
sm = SessionManager(timeout_minutes=1)

print("=== 세션 관리 시스템 테스트 ===")

# 세션 생성
session1 = sm.create_session(user_id="user123")
session2 = sm.create_session(user_id="user456")
session3 = sm.create_session()  # 게스트

# 세션 데이터 저장
sm.set_session_data(session1, "cart", ["item1", "item2"])
sm.set_session_data(session1, "last_page", "/products")

# 세션 데이터 조회
cart = sm.get_session_data(session1, "cart")
print(f"\n세션 {session1[:8]}... 장바구니: {cart}")

# 통계
print(f"\n세션 통계: {sm.get_stats()}")

# 만료된 세션 정리
print("\n60초 대기 후 정리...")
time.sleep(60)
sm.cleanup_expired_sessions()
print(f"정리 후 통계: {sm.get_stats()}")
```

## 3. URL 단축 서비스

긴 URL을 짧은 URL로 변환하는 서비스입니다.

```python
import hashlib
import string
import random

class URLShortener:
    """
    URL 단축 서비스
    """
    def __init__(self):
        self.url_map = {}  # short_code -> long_url
        self.reverse_map = {}  # long_url -> short_code
        self.custom_urls = set()  # 커스텀 URL 목록
        self.click_count = {}  # short_code -> click_count
    
    def _generate_short_code(self, length=6):
        """랜덤 짧은 코드 생성"""
        chars = string.ascii_letters + string.digits
        return ''.join(random.choice(chars) for _ in range(length))
    
    def _hash_url(self, url):
        """URL 해싱"""
        return hashlib.md5(url.encode()).hexdigest()[:6]
    
    def shorten(self, long_url, custom_code=None):
        """
        URL 단축
        Args:
            long_url: 원본 URL
            custom_code: 커스텀 짧은 코드 (선택)
        Returns:
            str: 짧은 코드
        """
        # 이미 단축된 URL인지 확인
        if long_url in self.reverse_map:
            return self.reverse_map[long_url]
        
        # 커스텀 코드 사용
        if custom_code:
            if custom_code in self.url_map or custom_code in self.custom_urls:
                raise ValueError(f"코드 '{custom_code}'는 이미 사용 중입니다")
            short_code = custom_code
            self.custom_urls.add(custom_code)
        else:
            # 해시 기반 코드 생성
            short_code = self._hash_url(long_url)
            
            # 충돌 시 랜덤 코드 생성
            while short_code in self.url_map:
                short_code = self._generate_short_code()
        
        # 매핑 저장
        self.url_map[short_code] = long_url
        self.reverse_map[long_url] = short_code
        self.click_count[short_code] = 0
        
        print(f"URL 단축: {long_url} -> {short_code}")
        return short_code
    
    def expand(self, short_code):
        """
        짧은 URL을 원본 URL로 확장
        Args:
            short_code: 짧은 코드
        Returns:
            str: 원본 URL, 없으면 None
        """
        if short_code in self.url_map:
            # 클릭 수 증가
            self.click_count[short_code] += 1
            return self.url_map[short_code]
        return None
    
    def get_stats(self, short_code):
        """URL 통계"""
        if short_code in self.url_map:
            return {
                'short_code': short_code,
                'long_url': self.url_map[short_code],
                'clicks': self.click_count[short_code],
                'is_custom': short_code in self.custom_urls
            }
        return None
    
    def delete(self, short_code):
        """URL 삭제"""
        if short_code in self.url_map:
            long_url = self.url_map[short_code]
            
            del self.url_map[short_code]
            del self.reverse_map[long_url]
            del self.click_count[short_code]
            
            if short_code in self.custom_urls:
                self.custom_urls.remove(short_code)
            
            return True
        return False

# 테스트
shortener = URLShortener()

print("=== URL 단축 서비스 테스트 ===")

# URL 단축
url1 = "https://www.example.com/very/long/url/path/to/page"
code1 = shortener.shorten(url1)

url2 = "https://www.example.com/another/long/url"
code2 = shortener.shorten(url2, custom_code="my-link")

# URL 확장
expanded1 = shortener.expand(code1)
expanded2 = shortener.expand(code2)

print(f"\n확장: {code1} -> {expanded1}")
print(f"확장: {code2} -> {expanded2}")

# 통계
stats1 = shortener.get_stats(code1)
stats2 = shortener.get_stats(code2)

print(f"\n통계 1: {stats1}")
print(f"통계 2: {stats2}")
```

## 4. 레이트 리미팅 (Rate Limiting)

API 요청 속도를 제한하는 시스템입니다.

```python
from collections import deque
import time

class RateLimiter:
    """
    레이트 리미터 (슬라이딩 윈도우 방식)
    """
    def __init__(self, max_requests, time_window):
        """
        Args:
            max_requests: 최대 요청 수
            time_window: 시간 윈도우 (초)
        """
        self.max_requests = max_requests
        self.time_window = time_window
        self.requests = {}  # client_id -> deque of timestamps
    
    def is_allowed(self, client_id):
        """
        요청 허용 여부 확인
        Args:
            client_id: 클라이언트 ID
        Returns:
            bool: 허용되면 True
        """
        current_time = time.time()
        
        # 클라이언트의 요청 기록 초기화
        if client_id not in self.requests:
            self.requests[client_id] = deque()
        
        request_times = self.requests[client_id]
        
        # 오래된 요청 제거
        while request_times and current_time - request_times[0] > self.time_window:
            request_times.popleft()
        
        # 요청 수 확인
        if len(request_times) < self.max_requests:
            request_times.append(current_time)
            return True
        
        return False
    
    def get_retry_after(self, client_id):
        """재시도 가능 시간 반환 (초)"""
        if client_id not in self.requests:
            return 0
        
        request_times = self.requests[client_id]
        
        if len(request_times) < self.max_requests:
            return 0
        
        # 가장 오래된 요청이 윈도우를 벗어날 때까지의 시간
        oldest_time = request_times[0]
        retry_after = self.time_window - (time.time() - oldest_time)
        
        return max(0, retry_after)

class TokenBucketRateLimiter:
    """
    토큰 버킷 방식 레이트 리미터
    """
    def __init__(self, capacity, refill_rate):
        """
        Args:
            capacity: 버킷 용량 (최대 토큰 수)
            refill_rate: 토큰 리필 속도 (토큰/초)
        """
        self.capacity = capacity
        self.refill_rate = refill_rate
        self.buckets = {}  # client_id -> (tokens, last_refill_time)
    
    def is_allowed(self, client_id, tokens=1):
        """
        요청 허용 여부 확인
        Args:
            client_id: 클라이언트 ID
            tokens: 필요한 토큰 수
        Returns:
            bool: 허용되면 True
        """
        current_time = time.time()
        
        # 버킷 초기화
        if client_id not in self.buckets:
            self.buckets[client_id] = [self.capacity, current_time]
        
        available_tokens, last_refill = self.buckets[client_id]
        
        # 토큰 리필
        elapsed = current_time - last_refill
        refilled = elapsed * self.refill_rate
        available_tokens = min(self.capacity, available_tokens + refilled)
        
        # 토큰 소비
        if available_tokens >= tokens:
            self.buckets[client_id] = [available_tokens - tokens, current_time]
            return True
        
        self.buckets[client_id] = [available_tokens, current_time]
        return False

# 테스트
limiter = RateLimiter(max_requests=5, time_window=10)

print("=== 레이트 리미터 테스트 ===")

client_id = "user123"

# 5개 요청 (허용)
for i in range(5):
    allowed = limiter.is_allowed(client_id)
    print(f"요청 {i+1}: {'허용' if allowed else '거부'}")

# 6번째 요청 (거부)
allowed = limiter.is_allowed(client_id)
print(f"요청 6: {'허용' if allowed else '거부'}")

retry_after = limiter.get_retry_after(client_id)
print(f"재시도 가능 시간: {retry_after:.1f}초 후")

# 토큰 버킷 테스트
print("\n=== 토큰 버킷 테스트 ===")

token_limiter = TokenBucketRateLimiter(capacity=10, refill_rate=1.0)

for i in range(12):
    allowed = token_limiter.is_allowed(client_id)
    print(f"요청 {i+1}: {'허용' if allowed else '거부'}")
    time.sleep(0.5)
```

## 정리

이번 포스트에서는 해시 테이블의 실무 활용 사례들을 살펴보았습니다.

**실무 활용 정리**
1. **웹 캐싱**: LRU/TTL 기반 고성능 캐시 시스템
2. **세션 관리**: 사용자 인증과 상태 관리
3. **URL 단축**: 해시 기반 짧은 URL 생성
4. **레이트 리미팅**: API 요청 속도 제한
5. **데이터베이스 인덱싱**: 빠른 데이터 검색

**해시 테이블 실무 활용의 핵심 원칙**
- **성능 최적화**: O(1) 검색으로 시스템 속도 향상
- **확장성**: 분산 시스템에서의 데이터 관리
- **리소스 관리**: 메모리와 성능의 균형
- **안정성**: TTL, 만료 처리로 시스템 안정성 확보
- **사용자 경험**: 빠른 응답 시간과 원활한 서비스

**실무에서의 해시 테이블 활용 패턴**
- **캐싱 레이어**: 데이터베이스 부하 감소
- **세션 스토어**: 분산 환경에서의 세션 공유
- **인덱싱**: 빠른 데이터 조회
- **속도 제한**: 시스템 보호와 공정한 리소스 사용
- **데이터 매핑**: 키-값 기반 데이터 관리

해시 테이블은 단순한 자료구조이지만, 실제 시스템 설계와 구현에서 매우 중요한 역할을 합니다. 이러한 실무 활용 사례들을 이해하면 더욱 효과적인 시스템을 설계하고 구현할 수 있습니다.

# 📚 레퍼런스
- [Redis Documentation](https://redis.io/docs/)
- [Session Management - OWASP](https://cheatsheetseries.owasp.org/cheatsheets/Session_Management_Cheat_Sheet.html)
- [Rate Limiting - Wikipedia](https://en.wikipedia.org/wiki/Rate_limiting)
- [URL Shortening - System Design](https://www.geeksforgeeks.org/system-design-url-shortening-service/)

---
*이 포스트는 자료구조 학습 과정을 정리한 내용입니다.*
