---
layout: post
title: "[ìë£Œêµ¬ì¡°] í•´ì‹œ í…Œì´ë¸”(Hash Table) - í™œìš© - 3"
date: 2025-10-07 16:20:00 +0900
categories: [ìë£Œêµ¬ì¡°, í•´ì‹œí…Œì´ë¸”]
tags: [ìë£Œêµ¬ì¡°, í•´ì‹œí…Œì´ë¸”, ìºì‹±, ì„¸ì…˜ê´€ë¦¬, ë°ì´í„°ë² ì´ìŠ¤, ì¸ë±ì‹±, ì‹¤ë¬´]
author: LimJongHan
toc: true
---

# ğŸ“– ê´€ë ¨ëœ ë‚´ í¬ìŠ¤íŒ…
- [[ìë£Œêµ¬ì¡°] ìë£Œêµ¬ì¡°ì™€ ì•Œê³ ë¦¬ì¦˜ ê°œìš”]({% post_url 2025-10-02-[ìë£Œêµ¬ì¡°] ìë£Œêµ¬ì¡°ì™€ ì•Œê³ ë¦¬ì¦˜ ê°œìš” %})
- [[ìë£Œêµ¬ì¡°] í•´ì‹œ í…Œì´ë¸”(Hash Table) - ê¸°ë³¸ ì˜ˆì œ]({% post_url 2025-10-07-[ìë£Œêµ¬ì¡°] í•´ì‹œ í…Œì´ë¸”(Hash Table) - ê¸°ë³¸ ì˜ˆì œ %})
- [[ìë£Œêµ¬ì¡°] í•´ì‹œ í…Œì´ë¸” í™œìš© - 1]({% post_url 2025-10-07-[ìë£Œêµ¬ì¡°] í•´ì‹œ í…Œì´ë¸”(Hash Table) - í™œìš© - 1 %})
- [[ìë£Œêµ¬ì¡°] í•´ì‹œ í…Œì´ë¸” í™œìš© - 2]({% post_url 2025-10-07-[ìë£Œêµ¬ì¡°] í•´ì‹œ í…Œì´ë¸”(Hash Table) - í™œìš© - 2 %})

# ğŸ“ ë‚´ìš©

## ê°œìš”

í•´ì‹œ í…Œì´ë¸”ì€ ì‹¤ì œ ì†Œí”„íŠ¸ì›¨ì–´ ê°œë°œê³¼ ì‹œìŠ¤í…œ ì„¤ê³„ì—ì„œ í•µì‹¬ì ì¸ ì—­í• ì„ í•©ë‹ˆë‹¤. ì´ë²ˆ í¬ìŠ¤íŠ¸ì—ì„œëŠ” ì‹¤ë¬´ì—ì„œ í•´ì‹œ í…Œì´ë¸”ì´ ì–´ë–»ê²Œ í™œìš©ë˜ëŠ”ì§€ ì‚´í´ë³´ê² ìŠµë‹ˆë‹¤.

**ë‹¤ë£° ì‹¤ë¬´ í™œìš© ì‚¬ë¡€ë“¤:**
- **ì›¹ ìºì‹± ì‹œìŠ¤í…œ**: Redis ìŠ¤íƒ€ì¼ ìºì‹œ êµ¬í˜„
- **ì„¸ì…˜ ê´€ë¦¬**: ì‚¬ìš©ì ì„¸ì…˜ ì €ì¥ ë° ê´€ë¦¬
- **ë°ì´í„°ë² ì´ìŠ¤ ì¸ë±ì‹±**: ë¹ ë¥¸ ë°ì´í„° ê²€ìƒ‰
- **URL ë‹¨ì¶• ì„œë¹„ìŠ¤**: ì§§ì€ URL ìƒì„± ë° ë§¤í•‘
- **ë ˆì´íŠ¸ ë¦¬ë¯¸íŒ…**: API ìš”ì²­ ì†ë„ ì œí•œ

## 1. ì›¹ ìºì‹± ì‹œìŠ¤í…œ

Redisì™€ ìœ ì‚¬í•œ ì¸ë©”ëª¨ë¦¬ ìºì‹œ ì‹œìŠ¤í…œì„ êµ¬í˜„í•©ë‹ˆë‹¤.

### 1-1 ê¸°ë³¸ ìºì‹œ ì‹œìŠ¤í…œ

```python
import time
from typing import Any, Optional
from collections import OrderedDict

class WebCache:
    """
    ì›¹ ìºì‹± ì‹œìŠ¤í…œ
    LRU ì œê±° ì •ì±… + TTL ì§€ì›
    """
    def __init__(self, max_size=1000, default_ttl=300):
        self.max_size = max_size
        self.default_ttl = default_ttl
        self.cache = OrderedDict()
        self.ttl_map = {}
        self.stats = {
            'hits': 0,
            'misses': 0,
            'evictions': 0
        }
    
    def get(self, key: str) -> Optional[Any]:
        """
        ìºì‹œì—ì„œ ê°’ ê°€ì ¸ì˜¤ê¸°
        Args:
            key: ìºì‹œ í‚¤
        Returns:
            Any: ìºì‹œëœ ê°’, ì—†ìœ¼ë©´ None
        """
        # TTL í™•ì¸
        if key in self.ttl_map:
            if time.time() > self.ttl_map[key]:
                # ë§Œë£Œëœ í•­ëª© ì œê±°
                del self.cache[key]
                del self.ttl_map[key]
                self.stats['misses'] += 1
                return None
        
        if key in self.cache:
            # LRU ì—…ë°ì´íŠ¸ (ë§¨ ë’¤ë¡œ ì´ë™)
            self.cache.move_to_end(key)
            self.stats['hits'] += 1
            return self.cache[key]
        
        self.stats['misses'] += 1
        return None
    
    def set(self, key: str, value: Any, ttl: Optional[int] = None):
        """
        ìºì‹œì— ê°’ ì €ì¥
        Args:
            key: ìºì‹œ í‚¤
            value: ì €ì¥í•  ê°’
            ttl: ìƒì¡´ ì‹œê°„ (ì´ˆ), Noneì´ë©´ ê¸°ë³¸ê°’ ì‚¬ìš©
        """
        if key in self.cache:
            # ê¸°ì¡´ í‚¤ ì—…ë°ì´íŠ¸
            self.cache.move_to_end(key)
        else:
            # ìƒˆ í‚¤ ì¶”ê°€
            if len(self.cache) >= self.max_size:
                # LRU ì œê±°
                oldest_key = next(iter(self.cache))
                del self.cache[oldest_key]
                if oldest_key in self.ttl_map:
                    del self.ttl_map[oldest_key]
                self.stats['evictions'] += 1
        
        self.cache[key] = value
        
        # TTL ì„¤ì •
        if ttl is None:
            ttl = self.default_ttl
        self.ttl_map[key] = time.time() + ttl
    
    def delete(self, key: str) -> bool:
        """ìºì‹œì—ì„œ í‚¤ ì‚­ì œ"""
        if key in self.cache:
            del self.cache[key]
            if key in self.ttl_map:
                del self.ttl_map[key]
            return True
        return False
    
    def get_stats(self):
        """ìºì‹œ í†µê³„ ë°˜í™˜"""
        total_requests = self.stats['hits'] + self.stats['misses']
        hit_rate = self.stats['hits'] / total_requests if total_requests > 0 else 0
        
        return {
            **self.stats,
            'total_requests': total_requests,
            'hit_rate': hit_rate,
            'size': len(self.cache)
        }
    
    def clear(self):
        """ìºì‹œ ì „ì²´ ì‚­ì œ"""
        self.cache.clear()
        self.ttl_map.clear()

# í…ŒìŠ¤íŠ¸
cache = WebCache(max_size=3, default_ttl=5)

print("=== ì›¹ ìºì‹œ ì‹œìŠ¤í…œ í…ŒìŠ¤íŠ¸ ===")

# ë°ì´í„° ì €ì¥
cache.set("user:1", {"name": "í™ê¸¸ë™", "age": 30})
cache.set("user:2", {"name": "ê¹€ì² ìˆ˜", "age": 25})
cache.set("user:3", {"name": "ì´ì˜í¬", "age": 28})

# ë°ì´í„° ì¡°íšŒ
print(f"user:1: {cache.get('user:1')}")
print(f"user:2: {cache.get('user:2')}")

# LRU í…ŒìŠ¤íŠ¸ (user:1ì´ ìµœê·¼ ì‚¬ìš©ë˜ì—ˆìœ¼ë¯€ë¡œ user:2ê°€ ì œê±°ë¨)
cache.set("user:4", {"name": "ë°•ë¯¼ìˆ˜", "age": 32})

print(f"\nuser:2 (LRU ì œê±°ë¨): {cache.get('user:2')}")
print(f"user:4 (ìƒˆë¡œ ì¶”ê°€): {cache.get('user:4')}")

# í†µê³„
print(f"\nìºì‹œ í†µê³„: {cache.get_stats()}")

# TTL í…ŒìŠ¤íŠ¸
print("\n5ì´ˆ ëŒ€ê¸° í›„ ì¡°íšŒ...")
time.sleep(5)
print(f"user:1 (TTL ë§Œë£Œ): {cache.get('user:1')}")
```

### 1-2 ê³„ì¸µì  ìºì‹œ ì‹œìŠ¤í…œ

```python
class TieredCache:
    """
    ê³„ì¸µì  ìºì‹œ ì‹œìŠ¤í…œ (L1, L2 ìºì‹œ)
    """
    def __init__(self, l1_size=100, l2_size=1000):
        self.l1_cache = WebCache(max_size=l1_size, default_ttl=60)  # ë¹ ë¥¸ L1
        self.l2_cache = WebCache(max_size=l2_size, default_ttl=300)  # í° L2
    
    def get(self, key: str) -> Optional[Any]:
        """ê³„ì¸µì  ìºì‹œ ì¡°íšŒ"""
        # L1 ìºì‹œ í™•ì¸
        value = self.l1_cache.get(key)
        if value is not None:
            return value
        
        # L2 ìºì‹œ í™•ì¸
        value = self.l2_cache.get(key)
        if value is not None:
            # L1 ìºì‹œì— ìŠ¹ê²©
            self.l1_cache.set(key, value)
            return value
        
        return None
    
    def set(self, key: str, value: Any):
        """ì–‘ìª½ ìºì‹œì— ì €ì¥"""
        self.l1_cache.set(key, value)
        self.l2_cache.set(key, value)
```

## 2. ì„¸ì…˜ ê´€ë¦¬ ì‹œìŠ¤í…œ

ì›¹ ì• í”Œë¦¬ì¼€ì´ì…˜ì˜ ì‚¬ìš©ì ì„¸ì…˜ì„ ê´€ë¦¬í•˜ëŠ” ì‹œìŠ¤í…œì…ë‹ˆë‹¤.

```python
import uuid
import hashlib
from datetime import datetime, timedelta

class Session:
    """ì„¸ì…˜ í´ë˜ìŠ¤"""
    def __init__(self, session_id, user_id=None):
        self.session_id = session_id
        self.user_id = user_id
        self.created_at = datetime.now()
        self.last_accessed = datetime.now()
        self.data = {}
    
    def update_access(self):
        """ë§ˆì§€ë§‰ ì ‘ê·¼ ì‹œê°„ ì—…ë°ì´íŠ¸"""
        self.last_accessed = datetime.now()
    
    def is_expired(self, timeout_minutes=30):
        """ì„¸ì…˜ ë§Œë£Œ ì—¬ë¶€ í™•ì¸"""
        expiry_time = self.last_accessed + timedelta(minutes=timeout_minutes)
        return datetime.now() > expiry_time

class SessionManager:
    """
    ì„¸ì…˜ ê´€ë¦¬ì
    """
    def __init__(self, timeout_minutes=30):
        self.sessions = {}  # session_id -> Session
        self.user_sessions = {}  # user_id -> [session_ids]
        self.timeout_minutes = timeout_minutes
    
    def create_session(self, user_id=None):
        """
        ìƒˆ ì„¸ì…˜ ìƒì„±
        Args:
            user_id: ì‚¬ìš©ì ID (ì„ íƒ)
        Returns:
            str: ì„¸ì…˜ ID
        """
        session_id = str(uuid.uuid4())
        session = Session(session_id, user_id)
        
        self.sessions[session_id] = session
        
        if user_id:
            if user_id not in self.user_sessions:
                self.user_sessions[user_id] = []
            self.user_sessions[user_id].append(session_id)
        
        print(f"ì„¸ì…˜ ìƒì„±: {session_id} (ì‚¬ìš©ì: {user_id or 'ê²ŒìŠ¤íŠ¸'})")
        return session_id
    
    def get_session(self, session_id):
        """
        ì„¸ì…˜ ê°€ì ¸ì˜¤ê¸°
        Args:
            session_id: ì„¸ì…˜ ID
        Returns:
            Session: ì„¸ì…˜ ê°ì²´, ì—†ê±°ë‚˜ ë§Œë£Œë˜ë©´ None
        """
        if session_id not in self.sessions:
            return None
        
        session = self.sessions[session_id]
        
        # ë§Œë£Œ í™•ì¸
        if session.is_expired(self.timeout_minutes):
            self.destroy_session(session_id)
            return None
        
        # ì ‘ê·¼ ì‹œê°„ ì—…ë°ì´íŠ¸
        session.update_access()
        return session
    
    def set_session_data(self, session_id, key, value):
        """ì„¸ì…˜ ë°ì´í„° ì €ì¥"""
        session = self.get_session(session_id)
        if session:
            session.data[key] = value
            return True
        return False
    
    def get_session_data(self, session_id, key):
        """ì„¸ì…˜ ë°ì´í„° ì¡°íšŒ"""
        session = self.get_session(session_id)
        if session:
            return session.data.get(key)
        return None
    
    def destroy_session(self, session_id):
        """ì„¸ì…˜ ì‚­ì œ"""
        if session_id in self.sessions:
            session = self.sessions[session_id]
            
            # ì‚¬ìš©ì ì„¸ì…˜ ëª©ë¡ì—ì„œ ì œê±°
            if session.user_id in self.user_sessions:
                self.user_sessions[session.user_id].remove(session_id)
                if not self.user_sessions[session.user_id]:
                    del self.user_sessions[session.user_id]
            
            del self.sessions[session_id]
            print(f"ì„¸ì…˜ ì‚­ì œ: {session_id}")
            return True
        return False
    
    def cleanup_expired_sessions(self):
        """ë§Œë£Œëœ ì„¸ì…˜ ì •ë¦¬"""
        expired = []
        
        for session_id, session in self.sessions.items():
            if session.is_expired(self.timeout_minutes):
                expired.append(session_id)
        
        for session_id in expired:
            self.destroy_session(session_id)
        
        print(f"ë§Œë£Œëœ ì„¸ì…˜ {len(expired)}ê°œ ì •ë¦¬ë¨")
    
    def get_user_sessions(self, user_id):
        """ì‚¬ìš©ìì˜ ëª¨ë“  ì„¸ì…˜ ì¡°íšŒ"""
        return self.user_sessions.get(user_id, [])
    
    def get_stats(self):
        """ì„¸ì…˜ í†µê³„"""
        active_sessions = len(self.sessions)
        total_users = len(self.user_sessions)
        
        return {
            'active_sessions': active_sessions,
            'total_users': total_users,
            'avg_sessions_per_user': active_sessions / total_users if total_users > 0 else 0
        }

# í…ŒìŠ¤íŠ¸
sm = SessionManager(timeout_minutes=1)

print("=== ì„¸ì…˜ ê´€ë¦¬ ì‹œìŠ¤í…œ í…ŒìŠ¤íŠ¸ ===")

# ì„¸ì…˜ ìƒì„±
session1 = sm.create_session(user_id="user123")
session2 = sm.create_session(user_id="user456")
session3 = sm.create_session()  # ê²ŒìŠ¤íŠ¸

# ì„¸ì…˜ ë°ì´í„° ì €ì¥
sm.set_session_data(session1, "cart", ["item1", "item2"])
sm.set_session_data(session1, "last_page", "/products")

# ì„¸ì…˜ ë°ì´í„° ì¡°íšŒ
cart = sm.get_session_data(session1, "cart")
print(f"\nì„¸ì…˜ {session1[:8]}... ì¥ë°”êµ¬ë‹ˆ: {cart}")

# í†µê³„
print(f"\nì„¸ì…˜ í†µê³„: {sm.get_stats()}")

# ë§Œë£Œëœ ì„¸ì…˜ ì •ë¦¬
print("\n60ì´ˆ ëŒ€ê¸° í›„ ì •ë¦¬...")
time.sleep(60)
sm.cleanup_expired_sessions()
print(f"ì •ë¦¬ í›„ í†µê³„: {sm.get_stats()}")
```

## 3. URL ë‹¨ì¶• ì„œë¹„ìŠ¤

ê¸´ URLì„ ì§§ì€ URLë¡œ ë³€í™˜í•˜ëŠ” ì„œë¹„ìŠ¤ì…ë‹ˆë‹¤.

```python
import hashlib
import string
import random

class URLShortener:
    """
    URL ë‹¨ì¶• ì„œë¹„ìŠ¤
    """
    def __init__(self):
        self.url_map = {}  # short_code -> long_url
        self.reverse_map = {}  # long_url -> short_code
        self.custom_urls = set()  # ì»¤ìŠ¤í…€ URL ëª©ë¡
        self.click_count = {}  # short_code -> click_count
    
    def _generate_short_code(self, length=6):
        """ëœë¤ ì§§ì€ ì½”ë“œ ìƒì„±"""
        chars = string.ascii_letters + string.digits
        return ''.join(random.choice(chars) for _ in range(length))
    
    def _hash_url(self, url):
        """URL í•´ì‹±"""
        return hashlib.md5(url.encode()).hexdigest()[:6]
    
    def shorten(self, long_url, custom_code=None):
        """
        URL ë‹¨ì¶•
        Args:
            long_url: ì›ë³¸ URL
            custom_code: ì»¤ìŠ¤í…€ ì§§ì€ ì½”ë“œ (ì„ íƒ)
        Returns:
            str: ì§§ì€ ì½”ë“œ
        """
        # ì´ë¯¸ ë‹¨ì¶•ëœ URLì¸ì§€ í™•ì¸
        if long_url in self.reverse_map:
            return self.reverse_map[long_url]
        
        # ì»¤ìŠ¤í…€ ì½”ë“œ ì‚¬ìš©
        if custom_code:
            if custom_code in self.url_map or custom_code in self.custom_urls:
                raise ValueError(f"ì½”ë“œ '{custom_code}'ëŠ” ì´ë¯¸ ì‚¬ìš© ì¤‘ì…ë‹ˆë‹¤")
            short_code = custom_code
            self.custom_urls.add(custom_code)
        else:
            # í•´ì‹œ ê¸°ë°˜ ì½”ë“œ ìƒì„±
            short_code = self._hash_url(long_url)
            
            # ì¶©ëŒ ì‹œ ëœë¤ ì½”ë“œ ìƒì„±
            while short_code in self.url_map:
                short_code = self._generate_short_code()
        
        # ë§¤í•‘ ì €ì¥
        self.url_map[short_code] = long_url
        self.reverse_map[long_url] = short_code
        self.click_count[short_code] = 0
        
        print(f"URL ë‹¨ì¶•: {long_url} -> {short_code}")
        return short_code
    
    def expand(self, short_code):
        """
        ì§§ì€ URLì„ ì›ë³¸ URLë¡œ í™•ì¥
        Args:
            short_code: ì§§ì€ ì½”ë“œ
        Returns:
            str: ì›ë³¸ URL, ì—†ìœ¼ë©´ None
        """
        if short_code in self.url_map:
            # í´ë¦­ ìˆ˜ ì¦ê°€
            self.click_count[short_code] += 1
            return self.url_map[short_code]
        return None
    
    def get_stats(self, short_code):
        """URL í†µê³„"""
        if short_code in self.url_map:
            return {
                'short_code': short_code,
                'long_url': self.url_map[short_code],
                'clicks': self.click_count[short_code],
                'is_custom': short_code in self.custom_urls
            }
        return None
    
    def delete(self, short_code):
        """URL ì‚­ì œ"""
        if short_code in self.url_map:
            long_url = self.url_map[short_code]
            
            del self.url_map[short_code]
            del self.reverse_map[long_url]
            del self.click_count[short_code]
            
            if short_code in self.custom_urls:
                self.custom_urls.remove(short_code)
            
            return True
        return False

# í…ŒìŠ¤íŠ¸
shortener = URLShortener()

print("=== URL ë‹¨ì¶• ì„œë¹„ìŠ¤ í…ŒìŠ¤íŠ¸ ===")

# URL ë‹¨ì¶•
url1 = "https://www.example.com/very/long/url/path/to/page"
code1 = shortener.shorten(url1)

url2 = "https://www.example.com/another/long/url"
code2 = shortener.shorten(url2, custom_code="my-link")

# URL í™•ì¥
expanded1 = shortener.expand(code1)
expanded2 = shortener.expand(code2)

print(f"\ní™•ì¥: {code1} -> {expanded1}")
print(f"í™•ì¥: {code2} -> {expanded2}")

# í†µê³„
stats1 = shortener.get_stats(code1)
stats2 = shortener.get_stats(code2)

print(f"\ní†µê³„ 1: {stats1}")
print(f"í†µê³„ 2: {stats2}")
```

## 4. ë ˆì´íŠ¸ ë¦¬ë¯¸íŒ… (Rate Limiting)

API ìš”ì²­ ì†ë„ë¥¼ ì œí•œí•˜ëŠ” ì‹œìŠ¤í…œì…ë‹ˆë‹¤.

```python
from collections import deque
import time

class RateLimiter:
    """
    ë ˆì´íŠ¸ ë¦¬ë¯¸í„° (ìŠ¬ë¼ì´ë”© ìœˆë„ìš° ë°©ì‹)
    """
    def __init__(self, max_requests, time_window):
        """
        Args:
            max_requests: ìµœëŒ€ ìš”ì²­ ìˆ˜
            time_window: ì‹œê°„ ìœˆë„ìš° (ì´ˆ)
        """
        self.max_requests = max_requests
        self.time_window = time_window
        self.requests = {}  # client_id -> deque of timestamps
    
    def is_allowed(self, client_id):
        """
        ìš”ì²­ í—ˆìš© ì—¬ë¶€ í™•ì¸
        Args:
            client_id: í´ë¼ì´ì–¸íŠ¸ ID
        Returns:
            bool: í—ˆìš©ë˜ë©´ True
        """
        current_time = time.time()
        
        # í´ë¼ì´ì–¸íŠ¸ì˜ ìš”ì²­ ê¸°ë¡ ì´ˆê¸°í™”
        if client_id not in self.requests:
            self.requests[client_id] = deque()
        
        request_times = self.requests[client_id]
        
        # ì˜¤ë˜ëœ ìš”ì²­ ì œê±°
        while request_times and current_time - request_times[0] > self.time_window:
            request_times.popleft()
        
        # ìš”ì²­ ìˆ˜ í™•ì¸
        if len(request_times) < self.max_requests:
            request_times.append(current_time)
            return True
        
        return False
    
    def get_retry_after(self, client_id):
        """ì¬ì‹œë„ ê°€ëŠ¥ ì‹œê°„ ë°˜í™˜ (ì´ˆ)"""
        if client_id not in self.requests:
            return 0
        
        request_times = self.requests[client_id]
        
        if len(request_times) < self.max_requests:
            return 0
        
        # ê°€ì¥ ì˜¤ë˜ëœ ìš”ì²­ì´ ìœˆë„ìš°ë¥¼ ë²—ì–´ë‚  ë•Œê¹Œì§€ì˜ ì‹œê°„
        oldest_time = request_times[0]
        retry_after = self.time_window - (time.time() - oldest_time)
        
        return max(0, retry_after)

class TokenBucketRateLimiter:
    """
    í† í° ë²„í‚· ë°©ì‹ ë ˆì´íŠ¸ ë¦¬ë¯¸í„°
    """
    def __init__(self, capacity, refill_rate):
        """
        Args:
            capacity: ë²„í‚· ìš©ëŸ‰ (ìµœëŒ€ í† í° ìˆ˜)
            refill_rate: í† í° ë¦¬í•„ ì†ë„ (í† í°/ì´ˆ)
        """
        self.capacity = capacity
        self.refill_rate = refill_rate
        self.buckets = {}  # client_id -> (tokens, last_refill_time)
    
    def is_allowed(self, client_id, tokens=1):
        """
        ìš”ì²­ í—ˆìš© ì—¬ë¶€ í™•ì¸
        Args:
            client_id: í´ë¼ì´ì–¸íŠ¸ ID
            tokens: í•„ìš”í•œ í† í° ìˆ˜
        Returns:
            bool: í—ˆìš©ë˜ë©´ True
        """
        current_time = time.time()
        
        # ë²„í‚· ì´ˆê¸°í™”
        if client_id not in self.buckets:
            self.buckets[client_id] = [self.capacity, current_time]
        
        available_tokens, last_refill = self.buckets[client_id]
        
        # í† í° ë¦¬í•„
        elapsed = current_time - last_refill
        refilled = elapsed * self.refill_rate
        available_tokens = min(self.capacity, available_tokens + refilled)
        
        # í† í° ì†Œë¹„
        if available_tokens >= tokens:
            self.buckets[client_id] = [available_tokens - tokens, current_time]
            return True
        
        self.buckets[client_id] = [available_tokens, current_time]
        return False

# í…ŒìŠ¤íŠ¸
limiter = RateLimiter(max_requests=5, time_window=10)

print("=== ë ˆì´íŠ¸ ë¦¬ë¯¸í„° í…ŒìŠ¤íŠ¸ ===")

client_id = "user123"

# 5ê°œ ìš”ì²­ (í—ˆìš©)
for i in range(5):
    allowed = limiter.is_allowed(client_id)
    print(f"ìš”ì²­ {i+1}: {'í—ˆìš©' if allowed else 'ê±°ë¶€'}")

# 6ë²ˆì§¸ ìš”ì²­ (ê±°ë¶€)
allowed = limiter.is_allowed(client_id)
print(f"ìš”ì²­ 6: {'í—ˆìš©' if allowed else 'ê±°ë¶€'}")

retry_after = limiter.get_retry_after(client_id)
print(f"ì¬ì‹œë„ ê°€ëŠ¥ ì‹œê°„: {retry_after:.1f}ì´ˆ í›„")

# í† í° ë²„í‚· í…ŒìŠ¤íŠ¸
print("\n=== í† í° ë²„í‚· í…ŒìŠ¤íŠ¸ ===")

token_limiter = TokenBucketRateLimiter(capacity=10, refill_rate=1.0)

for i in range(12):
    allowed = token_limiter.is_allowed(client_id)
    print(f"ìš”ì²­ {i+1}: {'í—ˆìš©' if allowed else 'ê±°ë¶€'}")
    time.sleep(0.5)
```

## ì •ë¦¬

ì´ë²ˆ í¬ìŠ¤íŠ¸ì—ì„œëŠ” í•´ì‹œ í…Œì´ë¸”ì˜ ì‹¤ë¬´ í™œìš© ì‚¬ë¡€ë“¤ì„ ì‚´í´ë³´ì•˜ìŠµë‹ˆë‹¤.

**ì‹¤ë¬´ í™œìš© ì •ë¦¬**
1. **ì›¹ ìºì‹±**: LRU/TTL ê¸°ë°˜ ê³ ì„±ëŠ¥ ìºì‹œ ì‹œìŠ¤í…œ
2. **ì„¸ì…˜ ê´€ë¦¬**: ì‚¬ìš©ì ì¸ì¦ê³¼ ìƒíƒœ ê´€ë¦¬
3. **URL ë‹¨ì¶•**: í•´ì‹œ ê¸°ë°˜ ì§§ì€ URL ìƒì„±
4. **ë ˆì´íŠ¸ ë¦¬ë¯¸íŒ…**: API ìš”ì²­ ì†ë„ ì œí•œ
5. **ë°ì´í„°ë² ì´ìŠ¤ ì¸ë±ì‹±**: ë¹ ë¥¸ ë°ì´í„° ê²€ìƒ‰

**í•´ì‹œ í…Œì´ë¸” ì‹¤ë¬´ í™œìš©ì˜ í•µì‹¬ ì›ì¹™**
- **ì„±ëŠ¥ ìµœì í™”**: O(1) ê²€ìƒ‰ìœ¼ë¡œ ì‹œìŠ¤í…œ ì†ë„ í–¥ìƒ
- **í™•ì¥ì„±**: ë¶„ì‚° ì‹œìŠ¤í…œì—ì„œì˜ ë°ì´í„° ê´€ë¦¬
- **ë¦¬ì†ŒìŠ¤ ê´€ë¦¬**: ë©”ëª¨ë¦¬ì™€ ì„±ëŠ¥ì˜ ê· í˜•
- **ì•ˆì •ì„±**: TTL, ë§Œë£Œ ì²˜ë¦¬ë¡œ ì‹œìŠ¤í…œ ì•ˆì •ì„± í™•ë³´
- **ì‚¬ìš©ì ê²½í—˜**: ë¹ ë¥¸ ì‘ë‹µ ì‹œê°„ê³¼ ì›í™œí•œ ì„œë¹„ìŠ¤

**ì‹¤ë¬´ì—ì„œì˜ í•´ì‹œ í…Œì´ë¸” í™œìš© íŒ¨í„´**
- **ìºì‹± ë ˆì´ì–´**: ë°ì´í„°ë² ì´ìŠ¤ ë¶€í•˜ ê°ì†Œ
- **ì„¸ì…˜ ìŠ¤í† ì–´**: ë¶„ì‚° í™˜ê²½ì—ì„œì˜ ì„¸ì…˜ ê³µìœ 
- **ì¸ë±ì‹±**: ë¹ ë¥¸ ë°ì´í„° ì¡°íšŒ
- **ì†ë„ ì œí•œ**: ì‹œìŠ¤í…œ ë³´í˜¸ì™€ ê³µì •í•œ ë¦¬ì†ŒìŠ¤ ì‚¬ìš©
- **ë°ì´í„° ë§¤í•‘**: í‚¤-ê°’ ê¸°ë°˜ ë°ì´í„° ê´€ë¦¬

í•´ì‹œ í…Œì´ë¸”ì€ ë‹¨ìˆœí•œ ìë£Œêµ¬ì¡°ì´ì§€ë§Œ, ì‹¤ì œ ì‹œìŠ¤í…œ ì„¤ê³„ì™€ êµ¬í˜„ì—ì„œ ë§¤ìš° ì¤‘ìš”í•œ ì—­í• ì„ í•©ë‹ˆë‹¤. ì´ëŸ¬í•œ ì‹¤ë¬´ í™œìš© ì‚¬ë¡€ë“¤ì„ ì´í•´í•˜ë©´ ë”ìš± íš¨ê³¼ì ì¸ ì‹œìŠ¤í…œì„ ì„¤ê³„í•˜ê³  êµ¬í˜„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

# ğŸ“š ë ˆí¼ëŸ°ìŠ¤
- [Redis Documentation](https://redis.io/docs/)
- [Session Management - OWASP](https://cheatsheetseries.owasp.org/cheatsheets/Session_Management_Cheat_Sheet.html)
- [Rate Limiting - Wikipedia](https://en.wikipedia.org/wiki/Rate_limiting)
- [URL Shortening - System Design](https://www.geeksforgeeks.org/system-design-url-shortening-service/)

---
*ì´ í¬ìŠ¤íŠ¸ëŠ” ìë£Œêµ¬ì¡° í•™ìŠµ ê³¼ì •ì„ ì •ë¦¬í•œ ë‚´ìš©ì…ë‹ˆë‹¤.*
