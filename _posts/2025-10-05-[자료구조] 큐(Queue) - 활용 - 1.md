---
layout: post
title: "[자료구조] 큐(Queue) - 활용 - 1"
date: 2025-01-08 20:45:00 +0900
categories: [자료구조, 큐]
tags: [자료구조, 큐, Queue, BFS, 문제해결, 알고리즘, 예제, 트리순회]
author: LimJongHan
toc: true
---

# 📖 관련된 내 포스팅
- [[자료구조] 자료구조와 알고리즘 개요]({% post_url 2025-10-02-[자료구조] 자료구조와 알고리즘 개요 %})
- [[자료구조] 배열(Array) - 기본 예제]({% post_url 2025-10-03-[자료구조] 배열(Array) - 기본 예제 %})
- [[자료구조] 배열(Array) - 활용 - 1]({% post_url 2025-10-03-[자료구조] 배열(Array) - 활용 - 1 %})
- [[자료구조] 배열(Array) - 활용 - 2]({% post_url 2025-10-03-[자료구조] 배열(Array) - 활용 - 2 %})
- [[자료구조] 배열(Array) - 활용 - 3]({% post_url 2025-10-03-[자료구조] 배열(Array) - 활용 - 3 %})
- [[자료구조] 연결리스트(Linked List) - 기본 예제]({% post_url 2025-10-04-[자료구조] 연결리스트(Linked List) - 기본 예제 %})
- [[자료구조] 연결리스트(Linked List) - 활용 - 1]({% post_url 2025-10-04-[자료구조] 연결리스트(Linked List) - 활용 - 1 %})
- [[자료구조] 연결리스트(Linked List) - 활용 - 2]({% post_url 2025-10-04-[자료구조] 연결리스트(Linked List) - 활용 - 2 %})
- [[자료구조] 연결리스트(Linked List) - 활용 - 3]({% post_url 2025-10-04-[자료구조] 연결리스트(Linked List) - 활용 - 3 %})
- [[자료구조] 스택(Stack) - 기본 예제]({% post_url 2025-10-04-[자료구조] 스택(Stack) - 기본 예제 %})
- [[자료구조] 스택(Stack) - 활용 - 1]({% post_url 2025-10-04-[자료구조] 스택(Stack) - 활용 - 1 %})
- [[자료구조] 스택(Stack) - 활용 - 2]({% post_url 2025-10-04-[자료구조] 스택(Stack) - 활용 - 2 %})
- [[자료구조] 스택(Stack) - 활용 - 3]({% post_url 2025-10-04-[자료구조] 스택(Stack) - 활용 - 3 %})
- [[자료구조] 큐(Queue) - 기본 예제]({% post_url 2025-10-05-[자료구조] 큐(Queue) - 기본 예제 %})
- [[자료구조] 큐(Queue) - 활용 - 2]({% post_url 2025-10-05-[자료구조] 큐(Queue) - 활용 - 2 %})
- [[자료구조] 큐(Queue) - 활용 - 3]({% post_url 2025-10-05-[자료구조] 큐(Queue) - 활용 - 3 %})

# 📝 내용

## 개요

큐의 FIFO(First In, First Out) 특성은 다양한 문제 해결에 매우 유용합니다. 이번 포스트에서는 큐를 활용한 기본적인 문제 해결 예제들을 살펴보겠습니다. 각 예제는 큐의 핵심 개념을 이해하고 실제 문제에 어떻게 적용할 수 있는지 보여줍니다.

**다룰 예제들:**
- **BFS (너비 우선 탐색)**: 그래프와 트리 탐색에서의 큐 활용
- **레벨 순회**: 트리의 각 레벨을 순서대로 방문
- **회문 검사**: 큐와 스택을 조합한 문제 해결
- **요세푸스 문제**: 원형 큐를 이용한 고전 문제
- **슬라이딩 윈도우 최댓값**: 덱을 이용한 최적화 문제

## 1. BFS (너비 우선 탐색)

BFS는 큐의 가장 대표적인 활용 예제입니다. 그래프나 트리를 레벨별로 탐색할 때 큐를 사용합니다.

### 1-1 그래프의 BFS 구현

```python
from collections import deque

class Graph:
    """인접 리스트를 이용한 그래프 구현"""
    def __init__(self):
        self.graph = {}
    
    def add_edge(self, u, v):
        """간선 추가 (무방향 그래프)"""
        if u not in self.graph:
            self.graph[u] = []
        if v not in self.graph:
            self.graph[v] = []
        
        self.graph[u].append(v)
        self.graph[v].append(u)
    
    def bfs_recursive(self, start, visited=None, queue=None):
        """재귀를 이용한 BFS (비추천 - 큐의 본래 목적에 맞지 않음)"""
        if visited is None:
            visited = set()
            queue = deque([start])
            visited.add(start)
        
        if not queue:
            return visited
        
        vertex = queue.popleft()
        print(f"방문: {vertex}")
        
        for neighbor in self.graph.get(vertex, []):
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append(neighbor)
        
        return self.bfs_recursive(start, visited, queue)
    
    def bfs_iterative(self, start):
        """
        큐를 이용한 BFS (권장 방법)
        Args:
            start: 시작 정점
        Returns:
            list: BFS 순서로 방문한 정점들의 리스트
        """
        visited = set()
        queue = deque([start])
        bfs_order = []
        
        while queue:
            vertex = queue.popleft()
            
            if vertex not in visited:
                visited.add(vertex)
                bfs_order.append(vertex)
                print(f"방문: {vertex}")
                
                # 인접한 정점들을 큐에 추가
                for neighbor in self.graph.get(vertex, []):
                    if neighbor not in visited:
                        queue.append(neighbor)
        
        return bfs_order
    
    def bfs_with_distance(self, start):
        """
        BFS로 각 정점까지의 최단 거리 계산
        Args:
            start: 시작 정점
        Returns:
            dict: 각 정점까지의 거리
        """
        visited = set()
        queue = deque([(start, 0)])  # (정점, 거리)
        distances = {}
        
        while queue:
            vertex, distance = queue.popleft()
            
            if vertex not in visited:
                visited.add(vertex)
                distances[vertex] = distance
                print(f"정점 {vertex}: 거리 {distance}")
                
                # 인접한 정점들을 큐에 추가 (거리 + 1)
                for neighbor in self.graph.get(vertex, []):
                    if neighbor not in visited:
                        queue.append((neighbor, distance + 1))
        
        return distances
    
    def bfs_path_finding(self, start, target):
        """
        BFS를 이용한 최단 경로 탐색
        Args:
            start: 시작 정점
            target: 목표 정점
        Returns:
            list: 시작점에서 목표점까지의 최단 경로
        """
        visited = set()
        queue = deque([(start, [start])])  # (현재 정점, 경로)
        
        while queue:
            current, path = queue.popleft()
            
            if current == target:
                return path
            
            if current not in visited:
                visited.add(current)
                
                for neighbor in self.graph.get(current, []):
                    if neighbor not in visited:
                        queue.append((neighbor, path + [neighbor]))
        
        return None  # 경로가 없는 경우

# 테스트
graph = Graph()
graph.add_edge(0, 1)
graph.add_edge(0, 2)
graph.add_edge(1, 2)
graph.add_edge(2, 0)
graph.add_edge(2, 3)
graph.add_edge(3, 3)

print("=== 그래프 BFS 테스트 ===")
print("그래프 구조:")
for vertex, neighbors in graph.graph.items():
    print(f"{vertex}: {neighbors}")

print("\nBFS 순서:")
bfs_order = graph.bfs_iterative(2)

print("\n거리 계산:")
distances = graph.bfs_with_distance(2)

print("\n경로 탐색 (0 -> 3):")
path = graph.bfs_path_finding(0, 3)
print(f"최단 경로: {path}")
```

### 1-2 트리의 BFS (레벨 순회)

```python
class TreeNode:
    """트리 노드 클래스"""
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class TreeBFS:
    """트리의 BFS 구현"""
    
    @staticmethod
    def level_order_traversal(root):
        """
        레벨 순회 (레벨별로 노드들을 리스트로 반환)
        Args:
            root: 트리의 루트 노드
        Returns:
            list: 각 레벨의 노드들을 담은 리스트
        """
        if not root:
            return []
        
        result = []
        queue = deque([root])
        
        while queue:
            level_size = len(queue)
            current_level = []
            
            # 현재 레벨의 모든 노드 처리
            for _ in range(level_size):
                node = queue.popleft()
                current_level.append(node.val)
                
                # 다음 레벨의 노드들을 큐에 추가
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
            
            result.append(current_level)
        
        return result
    
    @staticmethod
    def level_order_with_null(root):
        """
        레벨 순회 (null 값 포함)
        Args:
            root: 트리의 루트 노드
        Returns:
            list: 각 레벨의 노드들을 담은 리스트 (null 포함)
        """
        if not root:
            return []
        
        result = []
        queue = deque([root])
        
        while queue:
            level_size = len(queue)
            current_level = []
            has_next_level = False
            
            for _ in range(level_size):
                node = queue.popleft()
                
                if node:
                    current_level.append(node.val)
                    queue.append(node.left)
                    queue.append(node.right)
                    if node.left or node.right:
                        has_next_level = True
                else:
                    current_level.append(None)
                    queue.append(None)
                    queue.append(None)
            
            result.append(current_level)
            
            # 다음 레벨에 유효한 노드가 없으면 종료
            if not has_next_level:
                break
        
        return result
    
    @staticmethod
    def zigzag_level_order(root):
        """
        지그재그 레벨 순회 (홀수 레벨은 역순)
        Args:
            root: 트리의 루트 노드
        Returns:
            list: 지그재그 순서로 각 레벨의 노드들
        """
        if not root:
            return []
        
        result = []
        queue = deque([root])
        left_to_right = True
        
        while queue:
            level_size = len(queue)
            current_level = deque()
            
            for _ in range(level_size):
                node = queue.popleft()
                
                if left_to_right:
                    current_level.append(node.val)
                else:
                    current_level.appendleft(node.val)
                
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
            
            result.append(list(current_level))
            left_to_right = not left_to_right
        
        return result

# 테스트용 트리 생성
def create_test_tree():
    """
    테스트용 이진 트리 생성
           1
          / \
         2   3
        / \   \
       4   5   6
    """
    root = TreeNode(1)
    root.left = TreeNode(2)
    root.right = TreeNode(3)
    root.left.left = TreeNode(4)
    root.left.right = TreeNode(5)
    root.right.right = TreeNode(6)
    return root

# 테스트
tree = create_test_tree()

print("=== 트리 BFS 테스트 ===")
print("트리 구조:")
print("    1")
print("   / \\")
print("  2   3")
print(" / \\   \\")
print("4   5   6")

print("\n레벨 순회:")
level_order = TreeBFS.level_order_traversal(tree)
for i, level in enumerate(level_order):
    print(f"레벨 {i}: {level}")

print("\n지그재그 레벨 순회:")
zigzag_order = TreeBFS.zigzag_level_order(tree)
for i, level in enumerate(zigzag_order):
    print(f"레벨 {i}: {level}")
```

## 2. 회문 검사 (큐와 스택 조합)

큐와 스택을 함께 사용하여 회문을 검사하는 예제입니다.

```python
from collections import deque

class PalindromeChecker:
    """큐와 스택을 이용한 회문 검사"""
    
    def __init__(self):
        self.queue = deque()
        self.stack = []
    
    def is_palindrome_queue_stack(self, text):
        """
        큐와 스택을 이용한 회문 검사
        Args:
            text (str): 검사할 문자열
        Returns:
            bool: 회문이면 True, 아니면 False
        """
        # 대소문자 구분 없이, 공백과 특수문자 제거
        cleaned_text = ''.join(char.lower() for char in text if char.isalnum())
        
        if not cleaned_text:
            return True
        
        # 큐와 스택 초기화
        self.queue.clear()
        self.stack.clear()
        
        # 모든 문자를 큐와 스택에 추가
        for char in cleaned_text:
            self.queue.append(char)
            self.stack.append(char)
        
        # 큐와 스택에서 문자를 하나씩 비교
        while self.queue and self.stack:
            queue_char = self.queue.popleft()
            stack_char = self.stack.pop()
            
            if queue_char != stack_char:
                return False
        
        return True
    
    def is_palindrome_efficient(self, text):
        """더 효율적인 회문 검사 (투 포인터 방식)"""
        cleaned_text = ''.join(char.lower() for char in text if char.isalnum())
        
        left = 0
        right = len(cleaned_text) - 1
        
        while left < right:
            if cleaned_text[left] != cleaned_text[right]:
                return False
            left += 1
            right -= 1
        
        return True

# 테스트
checker = PalindromeChecker()

test_strings = [
    "racecar",           # True
    "level",             # True
    "deified",           # True
    "hello",             # False
    "world",             # False
    "A man a plan a canal Panama",  # True
    "Was it a car or a cat I saw?",  # True
    "No lemon, no melon",  # True
    "12321",             # True
    "12345",             # False
    "",                  # True (빈 문자열)
    "a",                 # True (한 글자)
]

print("=== 회문 검사 테스트 (큐와 스택) ===")
for text in test_strings:
    queue_stack_result = checker.is_palindrome_queue_stack(text)
    efficient_result = checker.is_palindrome_efficient(text)
    print(f"'{text}' -> 큐+스택: {queue_stack_result}, 효율적: {efficient_result}, 일치: {queue_stack_result == efficient_result}")
```

## 3. 요세푸스 문제 (Josephus Problem)

원형으로 배치된 사람들 중에서 k번째 사람을 순차적으로 제거하는 고전 문제입니다.

```python
from collections import deque

def josephus_problem(n, k):
    """
    요세푸스 문제 해결 (큐 사용)
    Args:
        n (int): 총 사람 수
        k (int): 제거할 간격 (k번째 사람)
    Returns:
        int: 마지막에 남은 사람의 번호 (1부터 시작)
    """
    if n <= 0 or k <= 0:
        raise ValueError("n과 k는 양수여야 합니다")
    
    if n == 1:
        return 1
    
    # 1부터 n까지의 번호를 가진 사람들을 큐에 추가
    people = deque(range(1, n + 1))
    
    print(f"요세푸스 문제: n={n}, k={k}")
    print(f"초기 사람들: {list(people)}")
    
    elimination_order = []
    
    while len(people) > 1:
        # k-1명을 큐의 뒤로 이동 (k번째 사람을 front에 위치시키기 위해)
        for _ in range(k - 1):
            people.append(people.popleft())
        
        # k번째 사람 제거
        eliminated = people.popleft()
        elimination_order.append(eliminated)
        print(f"제거된 사람: {eliminated}, 남은 사람들: {list(people)}")
    
    survivor = people[0]
    print(f"생존자: {survivor}")
    print(f"제거 순서: {elimination_order}")
    
    return survivor

def josephus_problem_recursive(n, k):
    """
    요세푸스 문제 해결 (재귀적 방법)
    Args:
        n (int): 총 사람 수
        k (int): 제거할 간격
    Returns:
        int: 마지막에 남은 사람의 번호 (0부터 시작)
    """
    if n == 1:
        return 0
    
    # 재귀적으로 (n-1, k) 문제를 해결하고, k를 더한 후 n으로 나머지 연산
    return (josephus_problem_recursive(n - 1, k) + k) % n

# 테스트
print("=== 요세푸스 문제 테스트 ===")

test_cases = [
    (7, 3),   # 7명, 3번째마다 제거
    (5, 2),   # 5명, 2번째마다 제거
    (10, 4),  # 10명, 4번째마다 제거
]

for n, k in test_cases:
    print(f"\n--- 테스트 케이스: n={n}, k={k} ---")
    
    # 큐를 이용한 해결
    survivor_queue = josephus_problem(n, k)
    
    # 재귀를 이용한 해결 (0-based indexing이므로 +1)
    survivor_recursive = josephus_problem_recursive(n, k) + 1
    
    print(f"큐 방법 결과: {survivor_queue}")
    print(f"재귀 방법 결과: {survivor_recursive}")
    print(f"일치 여부: {survivor_queue == survivor_recursive}")
```

## 4. 슬라이딩 윈도우 최댓값

고정 크기 윈도우에서 최댓값을 효율적으로 찾는 문제입니다. 덱(deque)을 사용하여 최적화할 수 있습니다.

```python
from collections import deque

def max_sliding_window_brute_force(nums, k):
    """
    슬라이딩 윈도우 최댓값 (브루트 포스)
    Args:
        nums (list): 정수 배열
        k (int): 윈도우 크기
    Returns:
        list: 각 윈도우의 최댓값들
    """
    if not nums or k <= 0 or k > len(nums):
        return []
    
    result = []
    
    for i in range(len(nums) - k + 1):
        window = nums[i:i + k]
        max_val = max(window)
        result.append(max_val)
        print(f"윈도우 {window}: 최댓값 {max_val}")
    
    return result

def max_sliding_window_deque(nums, k):
    """
    슬라이딩 윈도우 최댓값 (덱을 이용한 최적화)
    Args:
        nums (list): 정수 배열
        k (int): 윈도우 크기
    Returns:
        list: 각 윈도우의 최댓값들
    """
    if not nums or k <= 0 or k > len(nums):
        return []
    
    result = []
    dq = deque()  # 인덱스를 저장하는 덱
    
    # 첫 번째 윈도우 처리
    for i in range(k):
        # 현재 원소보다 작은 원소들의 인덱스를 덱에서 제거
        while dq and nums[dq[-1]] <= nums[i]:
            dq.pop()
        dq.append(i)
    
    # 첫 번째 윈도우의 최댓값
    result.append(nums[dq[0]])
    print(f"윈도우 {nums[0:k]}: 최댓값 {nums[dq[0]]}")
    
    # 나머지 윈도우들 처리
    for i in range(k, len(nums)):
        # 윈도우 범위를 벗어난 인덱스 제거
        while dq and dq[0] <= i - k:
            dq.popleft()
        
        # 현재 원소보다 작은 원소들의 인덱스를 덱에서 제거
        while dq and nums[dq[-1]] <= nums[i]:
            dq.pop()
        
        dq.append(i)
        result.append(nums[dq[0]])
        
        # 현재 윈도우 출력
        window_start = i - k + 1
        window = nums[window_start:i + 1]
        print(f"윈도우 {window}: 최댓값 {nums[dq[0]]}")
    
    return result

def sliding_window_maximum_with_explanation(nums, k):
    """
    슬라이딩 윈도우 최댓값 (상세한 설명 포함)
    """
    if not nums or k <= 0 or k > len(nums):
        return []
    
    print(f"배열: {nums}, 윈도우 크기: {k}")
    print("덱 상태 변화:")
    
    result = []
    dq = deque()
    
    for i in range(len(nums)):
        print(f"\n--- 인덱스 {i}: 값 {nums[i]} ---")
        
        # 윈도우 범위를 벗어난 인덱스 제거
        while dq and dq[0] <= i - k:
            removed_idx = dq.popleft()
            print(f"  범위 밖 인덱스 {removed_idx} 제거")
        
        # 현재 원소보다 작은 원소들의 인덱스 제거
        while dq and nums[dq[-1]] <= nums[i]:
            removed_idx = dq.pop()
            print(f"  작은 값 인덱스 {removed_idx} 제거 (값: {nums[removed_idx]} <= {nums[i]})")
        
        dq.append(i)
        print(f"  인덱스 {i} 추가")
        print(f"  현재 덱: {list(dq)}")
        
        # 윈도우가 완성된 경우 최댓값 추가
        if i >= k - 1:
            max_val = nums[dq[0]]
            result.append(max_val)
            window_start = i - k + 1
            window = nums[window_start:i + 1]
            print(f"  윈도우 {window}: 최댓값 {max_val}")
    
    return result

# 테스트
print("=== 슬라이딩 윈도우 최댓값 테스트 ===")

test_cases = [
    ([1, 3, -1, -3, 5, 3, 6, 7], 3),
    ([1, -1], 1),
    ([7, 2, 4], 2),
    ([9, 11], 2),
    ([4, -2], 2),
]

for nums, k in test_cases:
    print(f"\n--- 테스트: {nums}, k={k} ---")
    
    # 브루트 포스 방법
    print("브루트 포스 방법:")
    brute_result = max_sliding_window_brute_force(nums, k)
    print(f"결과: {brute_result}")
    
    # 덱을 이용한 최적화 방법
    print("\n덱을 이용한 최적화 방법:")
    deque_result = max_sliding_window_deque(nums, k)
    print(f"결과: {deque_result}")
    
    print(f"일치 여부: {brute_result == deque_result}")
    
    # 상세한 설명
    print("\n상세한 동작 과정:")
    detailed_result = sliding_window_maximum_with_explanation(nums, k)
    print(f"최종 결과: {detailed_result}")
```

## 5. 큐를 이용한 스케줄링 시뮬레이션

```python
import time
from collections import deque
import random

class Task:
    """작업 클래스"""
    def __init__(self, task_id, priority=1, duration=1):
        self.task_id = task_id
        self.priority = priority  # 1: 높음, 2: 중간, 3: 낮음
        self.duration = duration  # 작업 소요 시간 (초)
        self.arrival_time = time.time()
    
    def __str__(self):
        return f"Task({self.task_id}, 우선순위:{self.priority}, 소요시간:{self.duration}초)"

class TaskScheduler:
    """작업 스케줄러 (FIFO 큐 사용)"""
    
    def __init__(self):
        self.task_queue = deque()
        self.completed_tasks = []
        self.current_task = None
    
    def add_task(self, task):
        """작업 추가"""
        self.task_queue.append(task)
        print(f"작업 추가: {task}")
    
    def execute_next_task(self):
        """다음 작업 실행"""
        if not self.task_queue:
            print("실행할 작업이 없습니다.")
            return False
        
        self.current_task = self.task_queue.popleft()
        print(f"작업 시작: {self.current_task}")
        
        # 작업 시뮬레이션 (실제로는 sleep 대신 다른 처리)
        start_time = time.time()
        time.sleep(self.current_task.duration)  # 실제 작업 시간
        end_time = time.time()
        
        # 작업 완료 처리
        self.current_task.completion_time = end_time
        self.current_task.total_time = end_time - self.current_task.arrival_time
        self.completed_tasks.append(self.current_task)
        
        print(f"작업 완료: {self.current_task} (총 소요시간: {self.current_task.total_time:.2f}초)")
        self.current_task = None
        
        return True
    
    def get_queue_status(self):
        """큐 상태 반환"""
        return {
            '대기 중인 작업 수': len(self.task_queue),
            '완료된 작업 수': len(self.completed_tasks),
            '현재 작업': self.current_task
        }
    
    def get_average_waiting_time(self):
        """평균 대기 시간 계산"""
        if not self.completed_tasks:
            return 0
        
        total_waiting_time = sum(task.total_time - task.duration for task in self.completed_tasks)
        return total_waiting_time / len(self.completed_tasks)

# 테스트
print("=== 작업 스케줄링 시뮬레이션 ===")

scheduler = TaskScheduler()

# 작업들 생성 및 추가
tasks = [
    Task(1, priority=1, duration=2),
    Task(2, priority=2, duration=1),
    Task(3, priority=1, duration=3),
    Task(4, priority=3, duration=1),
    Task(5, priority=2, duration=2),
]

for task in tasks:
    scheduler.add_task(task)

print(f"\n초기 큐 상태: {scheduler.get_queue_status()}")

# 작업들 실행
print("\n작업 실행:")
while scheduler.execute_next_task():
    print(f"큐 상태: {scheduler.get_queue_status()}")
    print("-" * 40)

print(f"\n모든 작업 완료!")
print(f"평균 대기 시간: {scheduler.get_average_waiting_time():.2f}초")

# 완료된 작업들 요약
print("\n완료된 작업들:")
for i, task in enumerate(scheduler.completed_tasks, 1):
    print(f"{i}. {task} (총 소요시간: {task.total_time:.2f}초)")
```

## 정리

이번 포스트에서는 큐를 활용한 기본적인 문제 해결 예제들을 살펴보았습니다.

**핵심 예제 정리**
1. **BFS 알고리즘**: 그래프와 트리 탐색에서 큐의 핵심 활용
2. **레벨 순회**: 트리의 각 레벨을 순서대로 방문하는 방법
3. **회문 검사**: 큐와 스택을 조합한 문제 해결 접근법
4. **요세푸스 문제**: 원형 큐를 시뮬레이션하는 고전 문제
5. **슬라이딩 윈도우**: 덱을 이용한 효율적인 최댓값 찾기

**큐 활용의 핵심 원칙**
- **FIFO 특성 활용**: 먼저 들어온 것을 먼저 처리해야 하는 상황
- **레벨별 처리**: 동일한 레벨의 요소들을 함께 처리해야 하는 경우
- **순차적 처리**: 순서가 중요한 데이터의 순차적 처리
- **대기열 관리**: 작업이나 요청을 순서대로 처리하는 시스템

**다음 학습 계획**
다음 포스트에서는 큐의 고급 활용과 알고리즘 최적화에 대해 알아보겠습니다:
- [[학습] [자료구조] 큐(Queue) 활용 - 2. 고급 활용]({% post_url 2025-10-05-[자료구조] 큐(Queue) - 활용 - 2 %}) - 우선순위 큐, 이중 큐, 스레드 풀 등
- [[학습] [자료구조] 큐(Queue) 활용 - 3. 실무 활용]({% post_url 2025-10-05-[자료구조] 큐(Queue) - 활용 - 3 %}) - 메시지 큐, 작업 큐, 이벤트 시스템 등

# 📚 레퍼런스
- [Breadth-First Search - Wikipedia](https://en.wikipedia.org/wiki/Breadth-first_search)
- [Josephus Problem - Wikipedia](https://en.wikipedia.org/wiki/Josephus_problem)
- [Sliding Window Maximum - LeetCode](https://leetcode.com/problems/sliding-window-maximum/)
- [Tree Level Order Traversal - LeetCode](https://leetcode.com/problems/binary-tree-level-order-traversal/)

---
*이 포스트는 자료구조 학습 과정을 정리한 내용입니다.*
