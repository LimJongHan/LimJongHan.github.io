---
layout: post
title: "[ìë£Œêµ¬ì¡°] í(Queue) - í™œìš© - 1"
date: 2025-01-08 20:45:00 +0900
categories: [ìë£Œêµ¬ì¡°, í]
tags: [ìë£Œêµ¬ì¡°, í, Queue, BFS, ë¬¸ì œí•´ê²°, ì•Œê³ ë¦¬ì¦˜, ì˜ˆì œ, íŠ¸ë¦¬ìˆœíšŒ]
author: LimJongHan
toc: true
---

# ğŸ“– ê´€ë ¨ëœ ë‚´ í¬ìŠ¤íŒ…
- [[ìë£Œêµ¬ì¡°] ìë£Œêµ¬ì¡°ì™€ ì•Œê³ ë¦¬ì¦˜ ê°œìš”]({% post_url 2025-10-02-[ìë£Œêµ¬ì¡°] ìë£Œêµ¬ì¡°ì™€ ì•Œê³ ë¦¬ì¦˜ ê°œìš” %})
- [[ìë£Œêµ¬ì¡°] ë°°ì—´(Array) - ê¸°ë³¸ ì˜ˆì œ]({% post_url 2025-10-03-[ìë£Œêµ¬ì¡°] ë°°ì—´(Array) - ê¸°ë³¸ ì˜ˆì œ %})
- [[ìë£Œêµ¬ì¡°] ë°°ì—´(Array) - í™œìš© - 1]({% post_url 2025-10-03-[ìë£Œêµ¬ì¡°] ë°°ì—´(Array) - í™œìš© - 1 %})
- [[ìë£Œêµ¬ì¡°] ë°°ì—´(Array) - í™œìš© - 2]({% post_url 2025-10-03-[ìë£Œêµ¬ì¡°] ë°°ì—´(Array) - í™œìš© - 2 %})
- [[ìë£Œêµ¬ì¡°] ë°°ì—´(Array) - í™œìš© - 3]({% post_url 2025-10-03-[ìë£Œêµ¬ì¡°] ë°°ì—´(Array) - í™œìš© - 3 %})
- [[ìë£Œêµ¬ì¡°] ì—°ê²°ë¦¬ìŠ¤íŠ¸(Linked List) - ê¸°ë³¸ ì˜ˆì œ]({% post_url 2025-10-04-[ìë£Œêµ¬ì¡°] ì—°ê²°ë¦¬ìŠ¤íŠ¸(Linked List) - ê¸°ë³¸ ì˜ˆì œ %})
- [[ìë£Œêµ¬ì¡°] ì—°ê²°ë¦¬ìŠ¤íŠ¸(Linked List) - í™œìš© - 1]({% post_url 2025-10-04-[ìë£Œêµ¬ì¡°] ì—°ê²°ë¦¬ìŠ¤íŠ¸(Linked List) - í™œìš© - 1 %})
- [[ìë£Œêµ¬ì¡°] ì—°ê²°ë¦¬ìŠ¤íŠ¸(Linked List) - í™œìš© - 2]({% post_url 2025-10-04-[ìë£Œêµ¬ì¡°] ì—°ê²°ë¦¬ìŠ¤íŠ¸(Linked List) - í™œìš© - 2 %})
- [[ìë£Œêµ¬ì¡°] ì—°ê²°ë¦¬ìŠ¤íŠ¸(Linked List) - í™œìš© - 3]({% post_url 2025-10-04-[ìë£Œêµ¬ì¡°] ì—°ê²°ë¦¬ìŠ¤íŠ¸(Linked List) - í™œìš© - 3 %})
- [[ìë£Œêµ¬ì¡°] ìŠ¤íƒ(Stack) - ê¸°ë³¸ ì˜ˆì œ]({% post_url 2025-10-04-[ìë£Œêµ¬ì¡°] ìŠ¤íƒ(Stack) - ê¸°ë³¸ ì˜ˆì œ %})
- [[ìë£Œêµ¬ì¡°] ìŠ¤íƒ(Stack) - í™œìš© - 1]({% post_url 2025-10-04-[ìë£Œêµ¬ì¡°] ìŠ¤íƒ(Stack) - í™œìš© - 1 %})
- [[ìë£Œêµ¬ì¡°] ìŠ¤íƒ(Stack) - í™œìš© - 2]({% post_url 2025-10-04-[ìë£Œêµ¬ì¡°] ìŠ¤íƒ(Stack) - í™œìš© - 2 %})
- [[ìë£Œêµ¬ì¡°] ìŠ¤íƒ(Stack) - í™œìš© - 3]({% post_url 2025-10-04-[ìë£Œêµ¬ì¡°] ìŠ¤íƒ(Stack) - í™œìš© - 3 %})
- [[ìë£Œêµ¬ì¡°] í(Queue) - ê¸°ë³¸ ì˜ˆì œ]({% post_url 2025-10-05-[ìë£Œêµ¬ì¡°] í(Queue) - ê¸°ë³¸ ì˜ˆì œ %})
- [[ìë£Œêµ¬ì¡°] í(Queue) - í™œìš© - 2]({% post_url 2025-10-05-[ìë£Œêµ¬ì¡°] í(Queue) - í™œìš© - 2 %})
- [[ìë£Œêµ¬ì¡°] í(Queue) - í™œìš© - 3]({% post_url 2025-10-05-[ìë£Œêµ¬ì¡°] í(Queue) - í™œìš© - 3 %})

# ğŸ“ ë‚´ìš©

## ê°œìš”

íì˜ FIFO(First In, First Out) íŠ¹ì„±ì€ ë‹¤ì–‘í•œ ë¬¸ì œ í•´ê²°ì— ë§¤ìš° ìœ ìš©í•©ë‹ˆë‹¤. ì´ë²ˆ í¬ìŠ¤íŠ¸ì—ì„œëŠ” íë¥¼ í™œìš©í•œ ê¸°ë³¸ì ì¸ ë¬¸ì œ í•´ê²° ì˜ˆì œë“¤ì„ ì‚´í´ë³´ê² ìŠµë‹ˆë‹¤. ê° ì˜ˆì œëŠ” íì˜ í•µì‹¬ ê°œë…ì„ ì´í•´í•˜ê³  ì‹¤ì œ ë¬¸ì œì— ì–´ë–»ê²Œ ì ìš©í•  ìˆ˜ ìˆëŠ”ì§€ ë³´ì—¬ì¤ë‹ˆë‹¤.

**ë‹¤ë£° ì˜ˆì œë“¤:**
- **BFS (ë„ˆë¹„ ìš°ì„  íƒìƒ‰)**: ê·¸ë˜í”„ì™€ íŠ¸ë¦¬ íƒìƒ‰ì—ì„œì˜ í í™œìš©
- **ë ˆë²¨ ìˆœíšŒ**: íŠ¸ë¦¬ì˜ ê° ë ˆë²¨ì„ ìˆœì„œëŒ€ë¡œ ë°©ë¬¸
- **íšŒë¬¸ ê²€ì‚¬**: íì™€ ìŠ¤íƒì„ ì¡°í•©í•œ ë¬¸ì œ í•´ê²°
- **ìš”ì„¸í‘¸ìŠ¤ ë¬¸ì œ**: ì›í˜• íë¥¼ ì´ìš©í•œ ê³ ì „ ë¬¸ì œ
- **ìŠ¬ë¼ì´ë”© ìœˆë„ìš° ìµœëŒ“ê°’**: ë±ì„ ì´ìš©í•œ ìµœì í™” ë¬¸ì œ

## 1. BFS (ë„ˆë¹„ ìš°ì„  íƒìƒ‰)

BFSëŠ” íì˜ ê°€ì¥ ëŒ€í‘œì ì¸ í™œìš© ì˜ˆì œì…ë‹ˆë‹¤. ê·¸ë˜í”„ë‚˜ íŠ¸ë¦¬ë¥¼ ë ˆë²¨ë³„ë¡œ íƒìƒ‰í•  ë•Œ íë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤.

### 1-1 ê·¸ë˜í”„ì˜ BFS êµ¬í˜„

```python
from collections import deque

class Graph:
    """ì¸ì ‘ ë¦¬ìŠ¤íŠ¸ë¥¼ ì´ìš©í•œ ê·¸ë˜í”„ êµ¬í˜„"""
    def __init__(self):
        self.graph = {}
    
    def add_edge(self, u, v):
        """ê°„ì„  ì¶”ê°€ (ë¬´ë°©í–¥ ê·¸ë˜í”„)"""
        if u not in self.graph:
            self.graph[u] = []
        if v not in self.graph:
            self.graph[v] = []
        
        self.graph[u].append(v)
        self.graph[v].append(u)
    
    def bfs_recursive(self, start, visited=None, queue=None):
        """ì¬ê·€ë¥¼ ì´ìš©í•œ BFS (ë¹„ì¶”ì²œ - íì˜ ë³¸ë˜ ëª©ì ì— ë§ì§€ ì•ŠìŒ)"""
        if visited is None:
            visited = set()
            queue = deque([start])
            visited.add(start)
        
        if not queue:
            return visited
        
        vertex = queue.popleft()
        print(f"ë°©ë¬¸: {vertex}")
        
        for neighbor in self.graph.get(vertex, []):
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append(neighbor)
        
        return self.bfs_recursive(start, visited, queue)
    
    def bfs_iterative(self, start):
        """
        íë¥¼ ì´ìš©í•œ BFS (ê¶Œì¥ ë°©ë²•)
        Args:
            start: ì‹œì‘ ì •ì 
        Returns:
            list: BFS ìˆœì„œë¡œ ë°©ë¬¸í•œ ì •ì ë“¤ì˜ ë¦¬ìŠ¤íŠ¸
        """
        visited = set()
        queue = deque([start])
        bfs_order = []
        
        while queue:
            vertex = queue.popleft()
            
            if vertex not in visited:
                visited.add(vertex)
                bfs_order.append(vertex)
                print(f"ë°©ë¬¸: {vertex}")
                
                # ì¸ì ‘í•œ ì •ì ë“¤ì„ íì— ì¶”ê°€
                for neighbor in self.graph.get(vertex, []):
                    if neighbor not in visited:
                        queue.append(neighbor)
        
        return bfs_order
    
    def bfs_with_distance(self, start):
        """
        BFSë¡œ ê° ì •ì ê¹Œì§€ì˜ ìµœë‹¨ ê±°ë¦¬ ê³„ì‚°
        Args:
            start: ì‹œì‘ ì •ì 
        Returns:
            dict: ê° ì •ì ê¹Œì§€ì˜ ê±°ë¦¬
        """
        visited = set()
        queue = deque([(start, 0)])  # (ì •ì , ê±°ë¦¬)
        distances = {}
        
        while queue:
            vertex, distance = queue.popleft()
            
            if vertex not in visited:
                visited.add(vertex)
                distances[vertex] = distance
                print(f"ì •ì  {vertex}: ê±°ë¦¬ {distance}")
                
                # ì¸ì ‘í•œ ì •ì ë“¤ì„ íì— ì¶”ê°€ (ê±°ë¦¬ + 1)
                for neighbor in self.graph.get(vertex, []):
                    if neighbor not in visited:
                        queue.append((neighbor, distance + 1))
        
        return distances
    
    def bfs_path_finding(self, start, target):
        """
        BFSë¥¼ ì´ìš©í•œ ìµœë‹¨ ê²½ë¡œ íƒìƒ‰
        Args:
            start: ì‹œì‘ ì •ì 
            target: ëª©í‘œ ì •ì 
        Returns:
            list: ì‹œì‘ì ì—ì„œ ëª©í‘œì ê¹Œì§€ì˜ ìµœë‹¨ ê²½ë¡œ
        """
        visited = set()
        queue = deque([(start, [start])])  # (í˜„ì¬ ì •ì , ê²½ë¡œ)
        
        while queue:
            current, path = queue.popleft()
            
            if current == target:
                return path
            
            if current not in visited:
                visited.add(current)
                
                for neighbor in self.graph.get(current, []):
                    if neighbor not in visited:
                        queue.append((neighbor, path + [neighbor]))
        
        return None  # ê²½ë¡œê°€ ì—†ëŠ” ê²½ìš°

# í…ŒìŠ¤íŠ¸
graph = Graph()
graph.add_edge(0, 1)
graph.add_edge(0, 2)
graph.add_edge(1, 2)
graph.add_edge(2, 0)
graph.add_edge(2, 3)
graph.add_edge(3, 3)

print("=== ê·¸ë˜í”„ BFS í…ŒìŠ¤íŠ¸ ===")
print("ê·¸ë˜í”„ êµ¬ì¡°:")
for vertex, neighbors in graph.graph.items():
    print(f"{vertex}: {neighbors}")

print("\nBFS ìˆœì„œ:")
bfs_order = graph.bfs_iterative(2)

print("\nê±°ë¦¬ ê³„ì‚°:")
distances = graph.bfs_with_distance(2)

print("\nê²½ë¡œ íƒìƒ‰ (0 -> 3):")
path = graph.bfs_path_finding(0, 3)
print(f"ìµœë‹¨ ê²½ë¡œ: {path}")
```

### 1-2 íŠ¸ë¦¬ì˜ BFS (ë ˆë²¨ ìˆœíšŒ)

```python
class TreeNode:
    """íŠ¸ë¦¬ ë…¸ë“œ í´ë˜ìŠ¤"""
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class TreeBFS:
    """íŠ¸ë¦¬ì˜ BFS êµ¬í˜„"""
    
    @staticmethod
    def level_order_traversal(root):
        """
        ë ˆë²¨ ìˆœíšŒ (ë ˆë²¨ë³„ë¡œ ë…¸ë“œë“¤ì„ ë¦¬ìŠ¤íŠ¸ë¡œ ë°˜í™˜)
        Args:
            root: íŠ¸ë¦¬ì˜ ë£¨íŠ¸ ë…¸ë“œ
        Returns:
            list: ê° ë ˆë²¨ì˜ ë…¸ë“œë“¤ì„ ë‹´ì€ ë¦¬ìŠ¤íŠ¸
        """
        if not root:
            return []
        
        result = []
        queue = deque([root])
        
        while queue:
            level_size = len(queue)
            current_level = []
            
            # í˜„ì¬ ë ˆë²¨ì˜ ëª¨ë“  ë…¸ë“œ ì²˜ë¦¬
            for _ in range(level_size):
                node = queue.popleft()
                current_level.append(node.val)
                
                # ë‹¤ìŒ ë ˆë²¨ì˜ ë…¸ë“œë“¤ì„ íì— ì¶”ê°€
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
            
            result.append(current_level)
        
        return result
    
    @staticmethod
    def level_order_with_null(root):
        """
        ë ˆë²¨ ìˆœíšŒ (null ê°’ í¬í•¨)
        Args:
            root: íŠ¸ë¦¬ì˜ ë£¨íŠ¸ ë…¸ë“œ
        Returns:
            list: ê° ë ˆë²¨ì˜ ë…¸ë“œë“¤ì„ ë‹´ì€ ë¦¬ìŠ¤íŠ¸ (null í¬í•¨)
        """
        if not root:
            return []
        
        result = []
        queue = deque([root])
        
        while queue:
            level_size = len(queue)
            current_level = []
            has_next_level = False
            
            for _ in range(level_size):
                node = queue.popleft()
                
                if node:
                    current_level.append(node.val)
                    queue.append(node.left)
                    queue.append(node.right)
                    if node.left or node.right:
                        has_next_level = True
                else:
                    current_level.append(None)
                    queue.append(None)
                    queue.append(None)
            
            result.append(current_level)
            
            # ë‹¤ìŒ ë ˆë²¨ì— ìœ íš¨í•œ ë…¸ë“œê°€ ì—†ìœ¼ë©´ ì¢…ë£Œ
            if not has_next_level:
                break
        
        return result
    
    @staticmethod
    def zigzag_level_order(root):
        """
        ì§€ê·¸ì¬ê·¸ ë ˆë²¨ ìˆœíšŒ (í™€ìˆ˜ ë ˆë²¨ì€ ì—­ìˆœ)
        Args:
            root: íŠ¸ë¦¬ì˜ ë£¨íŠ¸ ë…¸ë“œ
        Returns:
            list: ì§€ê·¸ì¬ê·¸ ìˆœì„œë¡œ ê° ë ˆë²¨ì˜ ë…¸ë“œë“¤
        """
        if not root:
            return []
        
        result = []
        queue = deque([root])
        left_to_right = True
        
        while queue:
            level_size = len(queue)
            current_level = deque()
            
            for _ in range(level_size):
                node = queue.popleft()
                
                if left_to_right:
                    current_level.append(node.val)
                else:
                    current_level.appendleft(node.val)
                
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
            
            result.append(list(current_level))
            left_to_right = not left_to_right
        
        return result

# í…ŒìŠ¤íŠ¸ìš© íŠ¸ë¦¬ ìƒì„±
def create_test_tree():
    """
    í…ŒìŠ¤íŠ¸ìš© ì´ì§„ íŠ¸ë¦¬ ìƒì„±
           1
          / \
         2   3
        / \   \
       4   5   6
    """
    root = TreeNode(1)
    root.left = TreeNode(2)
    root.right = TreeNode(3)
    root.left.left = TreeNode(4)
    root.left.right = TreeNode(5)
    root.right.right = TreeNode(6)
    return root

# í…ŒìŠ¤íŠ¸
tree = create_test_tree()

print("=== íŠ¸ë¦¬ BFS í…ŒìŠ¤íŠ¸ ===")
print("íŠ¸ë¦¬ êµ¬ì¡°:")
print("    1")
print("   / \\")
print("  2   3")
print(" / \\   \\")
print("4   5   6")

print("\në ˆë²¨ ìˆœíšŒ:")
level_order = TreeBFS.level_order_traversal(tree)
for i, level in enumerate(level_order):
    print(f"ë ˆë²¨ {i}: {level}")

print("\nì§€ê·¸ì¬ê·¸ ë ˆë²¨ ìˆœíšŒ:")
zigzag_order = TreeBFS.zigzag_level_order(tree)
for i, level in enumerate(zigzag_order):
    print(f"ë ˆë²¨ {i}: {level}")
```

## 2. íšŒë¬¸ ê²€ì‚¬ (íì™€ ìŠ¤íƒ ì¡°í•©)

íì™€ ìŠ¤íƒì„ í•¨ê»˜ ì‚¬ìš©í•˜ì—¬ íšŒë¬¸ì„ ê²€ì‚¬í•˜ëŠ” ì˜ˆì œì…ë‹ˆë‹¤.

```python
from collections import deque

class PalindromeChecker:
    """íì™€ ìŠ¤íƒì„ ì´ìš©í•œ íšŒë¬¸ ê²€ì‚¬"""
    
    def __init__(self):
        self.queue = deque()
        self.stack = []
    
    def is_palindrome_queue_stack(self, text):
        """
        íì™€ ìŠ¤íƒì„ ì´ìš©í•œ íšŒë¬¸ ê²€ì‚¬
        Args:
            text (str): ê²€ì‚¬í•  ë¬¸ìì—´
        Returns:
            bool: íšŒë¬¸ì´ë©´ True, ì•„ë‹ˆë©´ False
        """
        # ëŒ€ì†Œë¬¸ì êµ¬ë¶„ ì—†ì´, ê³µë°±ê³¼ íŠ¹ìˆ˜ë¬¸ì ì œê±°
        cleaned_text = ''.join(char.lower() for char in text if char.isalnum())
        
        if not cleaned_text:
            return True
        
        # íì™€ ìŠ¤íƒ ì´ˆê¸°í™”
        self.queue.clear()
        self.stack.clear()
        
        # ëª¨ë“  ë¬¸ìë¥¼ íì™€ ìŠ¤íƒì— ì¶”ê°€
        for char in cleaned_text:
            self.queue.append(char)
            self.stack.append(char)
        
        # íì™€ ìŠ¤íƒì—ì„œ ë¬¸ìë¥¼ í•˜ë‚˜ì”© ë¹„êµ
        while self.queue and self.stack:
            queue_char = self.queue.popleft()
            stack_char = self.stack.pop()
            
            if queue_char != stack_char:
                return False
        
        return True
    
    def is_palindrome_efficient(self, text):
        """ë” íš¨ìœ¨ì ì¸ íšŒë¬¸ ê²€ì‚¬ (íˆ¬ í¬ì¸í„° ë°©ì‹)"""
        cleaned_text = ''.join(char.lower() for char in text if char.isalnum())
        
        left = 0
        right = len(cleaned_text) - 1
        
        while left < right:
            if cleaned_text[left] != cleaned_text[right]:
                return False
            left += 1
            right -= 1
        
        return True

# í…ŒìŠ¤íŠ¸
checker = PalindromeChecker()

test_strings = [
    "racecar",           # True
    "level",             # True
    "deified",           # True
    "hello",             # False
    "world",             # False
    "A man a plan a canal Panama",  # True
    "Was it a car or a cat I saw?",  # True
    "No lemon, no melon",  # True
    "12321",             # True
    "12345",             # False
    "",                  # True (ë¹ˆ ë¬¸ìì—´)
    "a",                 # True (í•œ ê¸€ì)
]

print("=== íšŒë¬¸ ê²€ì‚¬ í…ŒìŠ¤íŠ¸ (íì™€ ìŠ¤íƒ) ===")
for text in test_strings:
    queue_stack_result = checker.is_palindrome_queue_stack(text)
    efficient_result = checker.is_palindrome_efficient(text)
    print(f"'{text}' -> í+ìŠ¤íƒ: {queue_stack_result}, íš¨ìœ¨ì : {efficient_result}, ì¼ì¹˜: {queue_stack_result == efficient_result}")
```

## 3. ìš”ì„¸í‘¸ìŠ¤ ë¬¸ì œ (Josephus Problem)

ì›í˜•ìœ¼ë¡œ ë°°ì¹˜ëœ ì‚¬ëŒë“¤ ì¤‘ì—ì„œ kë²ˆì§¸ ì‚¬ëŒì„ ìˆœì°¨ì ìœ¼ë¡œ ì œê±°í•˜ëŠ” ê³ ì „ ë¬¸ì œì…ë‹ˆë‹¤.

```python
from collections import deque

def josephus_problem(n, k):
    """
    ìš”ì„¸í‘¸ìŠ¤ ë¬¸ì œ í•´ê²° (í ì‚¬ìš©)
    Args:
        n (int): ì´ ì‚¬ëŒ ìˆ˜
        k (int): ì œê±°í•  ê°„ê²© (kë²ˆì§¸ ì‚¬ëŒ)
    Returns:
        int: ë§ˆì§€ë§‰ì— ë‚¨ì€ ì‚¬ëŒì˜ ë²ˆí˜¸ (1ë¶€í„° ì‹œì‘)
    """
    if n <= 0 or k <= 0:
        raise ValueError("nê³¼ këŠ” ì–‘ìˆ˜ì—¬ì•¼ í•©ë‹ˆë‹¤")
    
    if n == 1:
        return 1
    
    # 1ë¶€í„° nê¹Œì§€ì˜ ë²ˆí˜¸ë¥¼ ê°€ì§„ ì‚¬ëŒë“¤ì„ íì— ì¶”ê°€
    people = deque(range(1, n + 1))
    
    print(f"ìš”ì„¸í‘¸ìŠ¤ ë¬¸ì œ: n={n}, k={k}")
    print(f"ì´ˆê¸° ì‚¬ëŒë“¤: {list(people)}")
    
    elimination_order = []
    
    while len(people) > 1:
        # k-1ëª…ì„ íì˜ ë’¤ë¡œ ì´ë™ (kë²ˆì§¸ ì‚¬ëŒì„ frontì— ìœ„ì¹˜ì‹œí‚¤ê¸° ìœ„í•´)
        for _ in range(k - 1):
            people.append(people.popleft())
        
        # kë²ˆì§¸ ì‚¬ëŒ ì œê±°
        eliminated = people.popleft()
        elimination_order.append(eliminated)
        print(f"ì œê±°ëœ ì‚¬ëŒ: {eliminated}, ë‚¨ì€ ì‚¬ëŒë“¤: {list(people)}")
    
    survivor = people[0]
    print(f"ìƒì¡´ì: {survivor}")
    print(f"ì œê±° ìˆœì„œ: {elimination_order}")
    
    return survivor

def josephus_problem_recursive(n, k):
    """
    ìš”ì„¸í‘¸ìŠ¤ ë¬¸ì œ í•´ê²° (ì¬ê·€ì  ë°©ë²•)
    Args:
        n (int): ì´ ì‚¬ëŒ ìˆ˜
        k (int): ì œê±°í•  ê°„ê²©
    Returns:
        int: ë§ˆì§€ë§‰ì— ë‚¨ì€ ì‚¬ëŒì˜ ë²ˆí˜¸ (0ë¶€í„° ì‹œì‘)
    """
    if n == 1:
        return 0
    
    # ì¬ê·€ì ìœ¼ë¡œ (n-1, k) ë¬¸ì œë¥¼ í•´ê²°í•˜ê³ , kë¥¼ ë”í•œ í›„ nìœ¼ë¡œ ë‚˜ë¨¸ì§€ ì—°ì‚°
    return (josephus_problem_recursive(n - 1, k) + k) % n

# í…ŒìŠ¤íŠ¸
print("=== ìš”ì„¸í‘¸ìŠ¤ ë¬¸ì œ í…ŒìŠ¤íŠ¸ ===")

test_cases = [
    (7, 3),   # 7ëª…, 3ë²ˆì§¸ë§ˆë‹¤ ì œê±°
    (5, 2),   # 5ëª…, 2ë²ˆì§¸ë§ˆë‹¤ ì œê±°
    (10, 4),  # 10ëª…, 4ë²ˆì§¸ë§ˆë‹¤ ì œê±°
]

for n, k in test_cases:
    print(f"\n--- í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤: n={n}, k={k} ---")
    
    # íë¥¼ ì´ìš©í•œ í•´ê²°
    survivor_queue = josephus_problem(n, k)
    
    # ì¬ê·€ë¥¼ ì´ìš©í•œ í•´ê²° (0-based indexingì´ë¯€ë¡œ +1)
    survivor_recursive = josephus_problem_recursive(n, k) + 1
    
    print(f"í ë°©ë²• ê²°ê³¼: {survivor_queue}")
    print(f"ì¬ê·€ ë°©ë²• ê²°ê³¼: {survivor_recursive}")
    print(f"ì¼ì¹˜ ì—¬ë¶€: {survivor_queue == survivor_recursive}")
```

## 4. ìŠ¬ë¼ì´ë”© ìœˆë„ìš° ìµœëŒ“ê°’

ê³ ì • í¬ê¸° ìœˆë„ìš°ì—ì„œ ìµœëŒ“ê°’ì„ íš¨ìœ¨ì ìœ¼ë¡œ ì°¾ëŠ” ë¬¸ì œì…ë‹ˆë‹¤. ë±(deque)ì„ ì‚¬ìš©í•˜ì—¬ ìµœì í™”í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

```python
from collections import deque

def max_sliding_window_brute_force(nums, k):
    """
    ìŠ¬ë¼ì´ë”© ìœˆë„ìš° ìµœëŒ“ê°’ (ë¸Œë£¨íŠ¸ í¬ìŠ¤)
    Args:
        nums (list): ì •ìˆ˜ ë°°ì—´
        k (int): ìœˆë„ìš° í¬ê¸°
    Returns:
        list: ê° ìœˆë„ìš°ì˜ ìµœëŒ“ê°’ë“¤
    """
    if not nums or k <= 0 or k > len(nums):
        return []
    
    result = []
    
    for i in range(len(nums) - k + 1):
        window = nums[i:i + k]
        max_val = max(window)
        result.append(max_val)
        print(f"ìœˆë„ìš° {window}: ìµœëŒ“ê°’ {max_val}")
    
    return result

def max_sliding_window_deque(nums, k):
    """
    ìŠ¬ë¼ì´ë”© ìœˆë„ìš° ìµœëŒ“ê°’ (ë±ì„ ì´ìš©í•œ ìµœì í™”)
    Args:
        nums (list): ì •ìˆ˜ ë°°ì—´
        k (int): ìœˆë„ìš° í¬ê¸°
    Returns:
        list: ê° ìœˆë„ìš°ì˜ ìµœëŒ“ê°’ë“¤
    """
    if not nums or k <= 0 or k > len(nums):
        return []
    
    result = []
    dq = deque()  # ì¸ë±ìŠ¤ë¥¼ ì €ì¥í•˜ëŠ” ë±
    
    # ì²« ë²ˆì§¸ ìœˆë„ìš° ì²˜ë¦¬
    for i in range(k):
        # í˜„ì¬ ì›ì†Œë³´ë‹¤ ì‘ì€ ì›ì†Œë“¤ì˜ ì¸ë±ìŠ¤ë¥¼ ë±ì—ì„œ ì œê±°
        while dq and nums[dq[-1]] <= nums[i]:
            dq.pop()
        dq.append(i)
    
    # ì²« ë²ˆì§¸ ìœˆë„ìš°ì˜ ìµœëŒ“ê°’
    result.append(nums[dq[0]])
    print(f"ìœˆë„ìš° {nums[0:k]}: ìµœëŒ“ê°’ {nums[dq[0]]}")
    
    # ë‚˜ë¨¸ì§€ ìœˆë„ìš°ë“¤ ì²˜ë¦¬
    for i in range(k, len(nums)):
        # ìœˆë„ìš° ë²”ìœ„ë¥¼ ë²—ì–´ë‚œ ì¸ë±ìŠ¤ ì œê±°
        while dq and dq[0] <= i - k:
            dq.popleft()
        
        # í˜„ì¬ ì›ì†Œë³´ë‹¤ ì‘ì€ ì›ì†Œë“¤ì˜ ì¸ë±ìŠ¤ë¥¼ ë±ì—ì„œ ì œê±°
        while dq and nums[dq[-1]] <= nums[i]:
            dq.pop()
        
        dq.append(i)
        result.append(nums[dq[0]])
        
        # í˜„ì¬ ìœˆë„ìš° ì¶œë ¥
        window_start = i - k + 1
        window = nums[window_start:i + 1]
        print(f"ìœˆë„ìš° {window}: ìµœëŒ“ê°’ {nums[dq[0]]}")
    
    return result

def sliding_window_maximum_with_explanation(nums, k):
    """
    ìŠ¬ë¼ì´ë”© ìœˆë„ìš° ìµœëŒ“ê°’ (ìƒì„¸í•œ ì„¤ëª… í¬í•¨)
    """
    if not nums or k <= 0 or k > len(nums):
        return []
    
    print(f"ë°°ì—´: {nums}, ìœˆë„ìš° í¬ê¸°: {k}")
    print("ë± ìƒíƒœ ë³€í™”:")
    
    result = []
    dq = deque()
    
    for i in range(len(nums)):
        print(f"\n--- ì¸ë±ìŠ¤ {i}: ê°’ {nums[i]} ---")
        
        # ìœˆë„ìš° ë²”ìœ„ë¥¼ ë²—ì–´ë‚œ ì¸ë±ìŠ¤ ì œê±°
        while dq and dq[0] <= i - k:
            removed_idx = dq.popleft()
            print(f"  ë²”ìœ„ ë°– ì¸ë±ìŠ¤ {removed_idx} ì œê±°")
        
        # í˜„ì¬ ì›ì†Œë³´ë‹¤ ì‘ì€ ì›ì†Œë“¤ì˜ ì¸ë±ìŠ¤ ì œê±°
        while dq and nums[dq[-1]] <= nums[i]:
            removed_idx = dq.pop()
            print(f"  ì‘ì€ ê°’ ì¸ë±ìŠ¤ {removed_idx} ì œê±° (ê°’: {nums[removed_idx]} <= {nums[i]})")
        
        dq.append(i)
        print(f"  ì¸ë±ìŠ¤ {i} ì¶”ê°€")
        print(f"  í˜„ì¬ ë±: {list(dq)}")
        
        # ìœˆë„ìš°ê°€ ì™„ì„±ëœ ê²½ìš° ìµœëŒ“ê°’ ì¶”ê°€
        if i >= k - 1:
            max_val = nums[dq[0]]
            result.append(max_val)
            window_start = i - k + 1
            window = nums[window_start:i + 1]
            print(f"  ìœˆë„ìš° {window}: ìµœëŒ“ê°’ {max_val}")
    
    return result

# í…ŒìŠ¤íŠ¸
print("=== ìŠ¬ë¼ì´ë”© ìœˆë„ìš° ìµœëŒ“ê°’ í…ŒìŠ¤íŠ¸ ===")

test_cases = [
    ([1, 3, -1, -3, 5, 3, 6, 7], 3),
    ([1, -1], 1),
    ([7, 2, 4], 2),
    ([9, 11], 2),
    ([4, -2], 2),
]

for nums, k in test_cases:
    print(f"\n--- í…ŒìŠ¤íŠ¸: {nums}, k={k} ---")
    
    # ë¸Œë£¨íŠ¸ í¬ìŠ¤ ë°©ë²•
    print("ë¸Œë£¨íŠ¸ í¬ìŠ¤ ë°©ë²•:")
    brute_result = max_sliding_window_brute_force(nums, k)
    print(f"ê²°ê³¼: {brute_result}")
    
    # ë±ì„ ì´ìš©í•œ ìµœì í™” ë°©ë²•
    print("\në±ì„ ì´ìš©í•œ ìµœì í™” ë°©ë²•:")
    deque_result = max_sliding_window_deque(nums, k)
    print(f"ê²°ê³¼: {deque_result}")
    
    print(f"ì¼ì¹˜ ì—¬ë¶€: {brute_result == deque_result}")
    
    # ìƒì„¸í•œ ì„¤ëª…
    print("\nìƒì„¸í•œ ë™ì‘ ê³¼ì •:")
    detailed_result = sliding_window_maximum_with_explanation(nums, k)
    print(f"ìµœì¢… ê²°ê³¼: {detailed_result}")
```

## 5. íë¥¼ ì´ìš©í•œ ìŠ¤ì¼€ì¤„ë§ ì‹œë®¬ë ˆì´ì…˜

```python
import time
from collections import deque
import random

class Task:
    """ì‘ì—… í´ë˜ìŠ¤"""
    def __init__(self, task_id, priority=1, duration=1):
        self.task_id = task_id
        self.priority = priority  # 1: ë†’ìŒ, 2: ì¤‘ê°„, 3: ë‚®ìŒ
        self.duration = duration  # ì‘ì—… ì†Œìš” ì‹œê°„ (ì´ˆ)
        self.arrival_time = time.time()
    
    def __str__(self):
        return f"Task({self.task_id}, ìš°ì„ ìˆœìœ„:{self.priority}, ì†Œìš”ì‹œê°„:{self.duration}ì´ˆ)"

class TaskScheduler:
    """ì‘ì—… ìŠ¤ì¼€ì¤„ëŸ¬ (FIFO í ì‚¬ìš©)"""
    
    def __init__(self):
        self.task_queue = deque()
        self.completed_tasks = []
        self.current_task = None
    
    def add_task(self, task):
        """ì‘ì—… ì¶”ê°€"""
        self.task_queue.append(task)
        print(f"ì‘ì—… ì¶”ê°€: {task}")
    
    def execute_next_task(self):
        """ë‹¤ìŒ ì‘ì—… ì‹¤í–‰"""
        if not self.task_queue:
            print("ì‹¤í–‰í•  ì‘ì—…ì´ ì—†ìŠµë‹ˆë‹¤.")
            return False
        
        self.current_task = self.task_queue.popleft()
        print(f"ì‘ì—… ì‹œì‘: {self.current_task}")
        
        # ì‘ì—… ì‹œë®¬ë ˆì´ì…˜ (ì‹¤ì œë¡œëŠ” sleep ëŒ€ì‹  ë‹¤ë¥¸ ì²˜ë¦¬)
        start_time = time.time()
        time.sleep(self.current_task.duration)  # ì‹¤ì œ ì‘ì—… ì‹œê°„
        end_time = time.time()
        
        # ì‘ì—… ì™„ë£Œ ì²˜ë¦¬
        self.current_task.completion_time = end_time
        self.current_task.total_time = end_time - self.current_task.arrival_time
        self.completed_tasks.append(self.current_task)
        
        print(f"ì‘ì—… ì™„ë£Œ: {self.current_task} (ì´ ì†Œìš”ì‹œê°„: {self.current_task.total_time:.2f}ì´ˆ)")
        self.current_task = None
        
        return True
    
    def get_queue_status(self):
        """í ìƒíƒœ ë°˜í™˜"""
        return {
            'ëŒ€ê¸° ì¤‘ì¸ ì‘ì—… ìˆ˜': len(self.task_queue),
            'ì™„ë£Œëœ ì‘ì—… ìˆ˜': len(self.completed_tasks),
            'í˜„ì¬ ì‘ì—…': self.current_task
        }
    
    def get_average_waiting_time(self):
        """í‰ê·  ëŒ€ê¸° ì‹œê°„ ê³„ì‚°"""
        if not self.completed_tasks:
            return 0
        
        total_waiting_time = sum(task.total_time - task.duration for task in self.completed_tasks)
        return total_waiting_time / len(self.completed_tasks)

# í…ŒìŠ¤íŠ¸
print("=== ì‘ì—… ìŠ¤ì¼€ì¤„ë§ ì‹œë®¬ë ˆì´ì…˜ ===")

scheduler = TaskScheduler()

# ì‘ì—…ë“¤ ìƒì„± ë° ì¶”ê°€
tasks = [
    Task(1, priority=1, duration=2),
    Task(2, priority=2, duration=1),
    Task(3, priority=1, duration=3),
    Task(4, priority=3, duration=1),
    Task(5, priority=2, duration=2),
]

for task in tasks:
    scheduler.add_task(task)

print(f"\nì´ˆê¸° í ìƒíƒœ: {scheduler.get_queue_status()}")

# ì‘ì—…ë“¤ ì‹¤í–‰
print("\nì‘ì—… ì‹¤í–‰:")
while scheduler.execute_next_task():
    print(f"í ìƒíƒœ: {scheduler.get_queue_status()}")
    print("-" * 40)

print(f"\nëª¨ë“  ì‘ì—… ì™„ë£Œ!")
print(f"í‰ê·  ëŒ€ê¸° ì‹œê°„: {scheduler.get_average_waiting_time():.2f}ì´ˆ")

# ì™„ë£Œëœ ì‘ì—…ë“¤ ìš”ì•½
print("\nì™„ë£Œëœ ì‘ì—…ë“¤:")
for i, task in enumerate(scheduler.completed_tasks, 1):
    print(f"{i}. {task} (ì´ ì†Œìš”ì‹œê°„: {task.total_time:.2f}ì´ˆ)")
```

## ì •ë¦¬

ì´ë²ˆ í¬ìŠ¤íŠ¸ì—ì„œëŠ” íë¥¼ í™œìš©í•œ ê¸°ë³¸ì ì¸ ë¬¸ì œ í•´ê²° ì˜ˆì œë“¤ì„ ì‚´í´ë³´ì•˜ìŠµë‹ˆë‹¤.

**í•µì‹¬ ì˜ˆì œ ì •ë¦¬**
1. **BFS ì•Œê³ ë¦¬ì¦˜**: ê·¸ë˜í”„ì™€ íŠ¸ë¦¬ íƒìƒ‰ì—ì„œ íì˜ í•µì‹¬ í™œìš©
2. **ë ˆë²¨ ìˆœíšŒ**: íŠ¸ë¦¬ì˜ ê° ë ˆë²¨ì„ ìˆœì„œëŒ€ë¡œ ë°©ë¬¸í•˜ëŠ” ë°©ë²•
3. **íšŒë¬¸ ê²€ì‚¬**: íì™€ ìŠ¤íƒì„ ì¡°í•©í•œ ë¬¸ì œ í•´ê²° ì ‘ê·¼ë²•
4. **ìš”ì„¸í‘¸ìŠ¤ ë¬¸ì œ**: ì›í˜• íë¥¼ ì‹œë®¬ë ˆì´ì…˜í•˜ëŠ” ê³ ì „ ë¬¸ì œ
5. **ìŠ¬ë¼ì´ë”© ìœˆë„ìš°**: ë±ì„ ì´ìš©í•œ íš¨ìœ¨ì ì¸ ìµœëŒ“ê°’ ì°¾ê¸°

**í í™œìš©ì˜ í•µì‹¬ ì›ì¹™**
- **FIFO íŠ¹ì„± í™œìš©**: ë¨¼ì € ë“¤ì–´ì˜¨ ê²ƒì„ ë¨¼ì € ì²˜ë¦¬í•´ì•¼ í•˜ëŠ” ìƒí™©
- **ë ˆë²¨ë³„ ì²˜ë¦¬**: ë™ì¼í•œ ë ˆë²¨ì˜ ìš”ì†Œë“¤ì„ í•¨ê»˜ ì²˜ë¦¬í•´ì•¼ í•˜ëŠ” ê²½ìš°
- **ìˆœì°¨ì  ì²˜ë¦¬**: ìˆœì„œê°€ ì¤‘ìš”í•œ ë°ì´í„°ì˜ ìˆœì°¨ì  ì²˜ë¦¬
- **ëŒ€ê¸°ì—´ ê´€ë¦¬**: ì‘ì—…ì´ë‚˜ ìš”ì²­ì„ ìˆœì„œëŒ€ë¡œ ì²˜ë¦¬í•˜ëŠ” ì‹œìŠ¤í…œ

**ë‹¤ìŒ í•™ìŠµ ê³„íš**
ë‹¤ìŒ í¬ìŠ¤íŠ¸ì—ì„œëŠ” íì˜ ê³ ê¸‰ í™œìš©ê³¼ ì•Œê³ ë¦¬ì¦˜ ìµœì í™”ì— ëŒ€í•´ ì•Œì•„ë³´ê² ìŠµë‹ˆë‹¤:
- [[í•™ìŠµ] [ìë£Œêµ¬ì¡°] í(Queue) í™œìš© - 2. ê³ ê¸‰ í™œìš©]({% post_url 2025-10-05-[ìë£Œêµ¬ì¡°] í(Queue) - í™œìš© - 2 %}) - ìš°ì„ ìˆœìœ„ í, ì´ì¤‘ í, ìŠ¤ë ˆë“œ í’€ ë“±
- [[í•™ìŠµ] [ìë£Œêµ¬ì¡°] í(Queue) í™œìš© - 3. ì‹¤ë¬´ í™œìš©]({% post_url 2025-10-05-[ìë£Œêµ¬ì¡°] í(Queue) - í™œìš© - 3 %}) - ë©”ì‹œì§€ í, ì‘ì—… í, ì´ë²¤íŠ¸ ì‹œìŠ¤í…œ ë“±

# ğŸ“š ë ˆí¼ëŸ°ìŠ¤
- [Breadth-First Search - Wikipedia](https://en.wikipedia.org/wiki/Breadth-first_search)
- [Josephus Problem - Wikipedia](https://en.wikipedia.org/wiki/Josephus_problem)
- [Sliding Window Maximum - LeetCode](https://leetcode.com/problems/sliding-window-maximum/)
- [Tree Level Order Traversal - LeetCode](https://leetcode.com/problems/binary-tree-level-order-traversal/)

---
*ì´ í¬ìŠ¤íŠ¸ëŠ” ìë£Œêµ¬ì¡° í•™ìŠµ ê³¼ì •ì„ ì •ë¦¬í•œ ë‚´ìš©ì…ë‹ˆë‹¤.*
