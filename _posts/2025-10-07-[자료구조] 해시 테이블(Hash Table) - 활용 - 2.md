---
layout: post
title: "[ìë£Œêµ¬ì¡°] í•´ì‹œ í…Œì´ë¸”(Hash Table) - í™œìš© - 2"
date: 2025-10-07 16:10:00 +0900
categories: [ìë£Œêµ¬ì¡°, í•´ì‹œí…Œì´ë¸”]
tags: [ìë£Œêµ¬ì¡°, í•´ì‹œí…Œì´ë¸”, LRUìºì‹œ, ë¸”ë£¸í•„í„°, ì¼ê´€ì„±í•´ì‹±, ê³ ê¸‰ì•Œê³ ë¦¬ì¦˜]
author: LimJongHan
toc: true
---

# ğŸ“– ê´€ë ¨ëœ ë‚´ í¬ìŠ¤íŒ…
- [[ìë£Œêµ¬ì¡°] ìë£Œêµ¬ì¡°ì™€ ì•Œê³ ë¦¬ì¦˜ ê°œìš”]({% post_url 2025-10-02-[ìë£Œêµ¬ì¡°] ìë£Œêµ¬ì¡°ì™€ ì•Œê³ ë¦¬ì¦˜ ê°œìš” %})
- [[ìë£Œêµ¬ì¡°] í•´ì‹œ í…Œì´ë¸”(Hash Table) - ê¸°ë³¸ ì˜ˆì œ]({% post_url 2025-10-07-[ìë£Œêµ¬ì¡°] í•´ì‹œ í…Œì´ë¸”(Hash Table) - ê¸°ë³¸ ì˜ˆì œ %})
- [[ìë£Œêµ¬ì¡°] í•´ì‹œ í…Œì´ë¸” í™œìš© - 1]({% post_url 2025-10-07-[ìë£Œêµ¬ì¡°] í•´ì‹œ í…Œì´ë¸”(Hash Table) - í™œìš© - 1 %})

# ğŸ“ ë‚´ìš©

## ê°œìš”

í•´ì‹œ í…Œì´ë¸”ì˜ ê³ ê¸‰ í™œìš©ì—ì„œëŠ” LRU ìºì‹œ, ë¸”ë£¸ í•„í„°, ì¼ê´€ì„± í•´ì‹± ë“± ì‹¤ì œ ì‹œìŠ¤í…œì—ì„œ ì‚¬ìš©ë˜ëŠ” ê³ ê¸‰ ê¸°ë²•ë“¤ì„ ë‹¤ë£¹ë‹ˆë‹¤.

**ë‹¤ë£° ê³ ê¸‰ í™œìš©ë“¤:**
- **LRU ìºì‹œ**: í•´ì‹œë§µê³¼ ì´ì¤‘ ì—°ê²°ë¦¬ìŠ¤íŠ¸ ì¡°í•©
- **ë¸”ë£¸ í•„í„°**: ê³µê°„ íš¨ìœ¨ì ì¸ ì§‘í•© ë©¤ë²„ì‹­ í…ŒìŠ¤íŠ¸
- **ì¼ê´€ì„± í•´ì‹±**: ë¶„ì‚° ì‹œìŠ¤í…œì˜ ë°ì´í„° ë¶„ë°°
- **Trieì™€ í•´ì‹œë§µ**: ìë™ì™„ì„±ê³¼ ê²€ìƒ‰ ìµœì í™”
- **Count-Min Sketch**: ìŠ¤íŠ¸ë¦¼ ë°ì´í„° ë¹ˆë„ ì¶”ì •

## 1. LRU ìºì‹œ (Least Recently Used Cache)

LRU ìºì‹œëŠ” ê°€ì¥ ìµœê·¼ì— ì‚¬ìš©ë˜ì§€ ì•Šì€ í•­ëª©ì„ ì œê±°í•˜ëŠ” ìºì‹œ ì „ëµì…ë‹ˆë‹¤.

### 1-1 ê¸°ë³¸ LRU ìºì‹œ êµ¬í˜„

```python
class ListNode:
    """ì´ì¤‘ ì—°ê²°ë¦¬ìŠ¤íŠ¸ ë…¸ë“œ"""
    def __init__(self, key=0, value=0):
        self.key = key
        self.value = value
        self.prev = None
        self.next = None

class LRUCache:
    """
    LRU ìºì‹œ êµ¬í˜„
    í•´ì‹œë§µ + ì´ì¤‘ ì—°ê²°ë¦¬ìŠ¤íŠ¸
    """
    def __init__(self, capacity):
        self.capacity = capacity
        self.cache = {}  # key -> ListNode
        
        # ë”ë¯¸ í—¤ë“œì™€ í…Œì¼
        self.head = ListNode()
        self.tail = ListNode()
        self.head.next = self.tail
        self.tail.prev = self.head
    
    def _add_to_front(self, node):
        """ë…¸ë“œë¥¼ ë§¨ ì•(ê°€ì¥ ìµœê·¼)ì— ì¶”ê°€"""
        node.prev = self.head
        node.next = self.head.next
        self.head.next.prev = node
        self.head.next = node
    
    def _remove_node(self, node):
        """ë…¸ë“œ ì œê±°"""
        node.prev.next = node.next
        node.next.prev = node.prev
    
    def _move_to_front(self, node):
        """ë…¸ë“œë¥¼ ë§¨ ì•ìœ¼ë¡œ ì´ë™"""
        self._remove_node(node)
        self._add_to_front(node)
    
    def _remove_lru(self):
        """ê°€ì¥ ì˜¤ë˜ ì‚¬ìš©ë˜ì§€ ì•Šì€ ë…¸ë“œ ì œê±°"""
        lru_node = self.tail.prev
        self._remove_node(lru_node)
        return lru_node
    
    def get(self, key):
        """
        í‚¤ì— í•´ë‹¹í•˜ëŠ” ê°’ ë°˜í™˜ O(1)
        Args:
            key: í‚¤
        Returns:
            int: ê°’, ì—†ìœ¼ë©´ -1
        """
        if key not in self.cache:
            return -1
        
        node = self.cache[key]
        self._move_to_front(node)
        return node.value
    
    def put(self, key, value):
        """
        í‚¤-ê°’ ìŒ ì €ì¥ O(1)
        Args:
            key: í‚¤
            value: ê°’
        """
        if key in self.cache:
            # ê¸°ì¡´ ë…¸ë“œ ì—…ë°ì´íŠ¸
            node = self.cache[key]
            node.value = value
            self._move_to_front(node)
        else:
            # ìƒˆ ë…¸ë“œ ì¶”ê°€
            node = ListNode(key, value)
            self.cache[key] = node
            self._add_to_front(node)
            
            # ìš©ëŸ‰ ì´ˆê³¼ ì‹œ LRU ì œê±°
            if len(self.cache) > self.capacity:
                lru_node = self._remove_lru()
                del self.cache[lru_node.key]
    
    def display(self):
        """ìºì‹œ ìƒíƒœ ì¶œë ¥"""
        print(f"LRU ìºì‹œ (ìš©ëŸ‰: {self.capacity}, í˜„ì¬: {len(self.cache)})")
        current = self.head.next
        items = []
        while current != self.tail:
            items.append(f"{current.key}={current.value}")
            current = current.next
        print(f"  ìˆœì„œ (ìµœì‹ ->ì˜¤ë˜ë¨): {' -> '.join(items)}")

# í…ŒìŠ¤íŠ¸
lru = LRUCache(3)

print("=== LRU ìºì‹œ í…ŒìŠ¤íŠ¸ ===")

lru.put(1, "one")
lru.put(2, "two")
lru.put(3, "three")
lru.display()

print(f"\nget(1): {lru.get(1)}")
lru.display()

lru.put(4, "four")  # 2ê°€ ì œê±°ë¨
lru.display()

print(f"\nget(2): {lru.get(2)}")  # -1 (ì—†ìŒ)
```

### 1-2 TTL(Time To Live) ê¸°ëŠ¥ì´ ìˆëŠ” LRU ìºì‹œ

```python
import time

class TTLLRUCache(LRUCache):
    """TTL ê¸°ëŠ¥ì´ ì¶”ê°€ëœ LRU ìºì‹œ"""
    
    def __init__(self, capacity, default_ttl=60):
        super().__init__(capacity)
        self.default_ttl = default_ttl
        self.expiry = {}  # key -> expiry_time
    
    def get(self, key):
        """TTL í™•ì¸ í›„ ê°’ ë°˜í™˜"""
        if key in self.expiry and time.time() > self.expiry[key]:
            # ë§Œë£Œëœ í•­ëª© ì œê±°
            node = self.cache[key]
            self._remove_node(node)
            del self.cache[key]
            del self.expiry[key]
            return -1
        
        return super().get(key)
    
    def put(self, key, value, ttl=None):
        """TTLê³¼ í•¨ê»˜ ê°’ ì €ì¥"""
        super().put(key, value)
        
        if ttl is None:
            ttl = self.default_ttl
        
        self.expiry[key] = time.time() + ttl
```

## 2. ë¸”ë£¸ í•„í„° (Bloom Filter)

ë¸”ë£¸ í•„í„°ëŠ” ì›ì†Œì˜ ì§‘í•© ë©¤ë²„ì‹­ì„ í™•ë¥ ì ìœ¼ë¡œ í…ŒìŠ¤íŠ¸í•˜ëŠ” ê³µê°„ íš¨ìœ¨ì ì¸ ìë£Œêµ¬ì¡°ì…ë‹ˆë‹¤.

```python
import hashlib

class BloomFilter:
    """
    ë¸”ë£¸ í•„í„° êµ¬í˜„
    """
    def __init__(self, size=1000, hash_count=3):
        self.size = size
        self.hash_count = hash_count
        self.bit_array = [0] * size
    
    def _hash(self, item, seed):
        """í•´ì‹œ í•¨ìˆ˜"""
        h = hashlib.md5(f"{item}{seed}".encode())
        return int(h.hexdigest(), 16) % self.size
    
    def add(self, item):
        """
        ì›ì†Œ ì¶”ê°€ O(k) - këŠ” í•´ì‹œ í•¨ìˆ˜ ê°œìˆ˜
        Args:
            item: ì¶”ê°€í•  ì›ì†Œ
        """
        for i in range(self.hash_count):
            index = self._hash(item, i)
            self.bit_array[index] = 1
    
    def contains(self, item):
        """
        ì›ì†Œ ì¡´ì¬ ì—¬ë¶€ í™•ì¸ O(k)
        Args:
            item: í™•ì¸í•  ì›ì†Œ
        Returns:
            bool: Trueë©´ "ì•„ë§ˆë„ ì¡´ì¬", Falseë©´ "í™•ì‹¤íˆ ì—†ìŒ"
        """
        for i in range(self.hash_count):
            index = self._hash(item, i)
            if self.bit_array[index] == 0:
                return False
        return True
    
    def false_positive_rate(self, n):
        """
        False Positive í™•ë¥  ê³„ì‚°
        Args:
            n: ì¶”ê°€ëœ ì›ì†Œ ê°œìˆ˜
        Returns:
            float: False Positive í™•ë¥ 
        """
        # (1 - e^(-kn/m))^k
        # k: í•´ì‹œ í•¨ìˆ˜ ê°œìˆ˜, n: ì›ì†Œ ê°œìˆ˜, m: ë¹„íŠ¸ ë°°ì—´ í¬ê¸°
        import math
        
        exponent = -self.hash_count * n / self.size
        probability = (1 - math.exp(exponent)) ** self.hash_count
        
        return probability

# í…ŒìŠ¤íŠ¸
bf = BloomFilter(size=100, hash_count=3)

print("=== ë¸”ë£¸ í•„í„° í…ŒìŠ¤íŠ¸ ===")

# ì›ì†Œ ì¶”ê°€
items = ["apple", "banana", "cherry", "date"]
for item in items:
    bf.add(item)
    print(f"ì¶”ê°€: {item}")

# ì¡´ì¬ í™•ì¸
test_items = ["apple", "grape", "banana", "kiwi", "cherry"]
print("\nì¡´ì¬ í™•ì¸:")
for item in test_items:
    exists = bf.contains(item)
    print(f"{item}: {'ì¡´ì¬ ê°€ëŠ¥' if exists else 'í™•ì‹¤íˆ ì—†ìŒ'}")

# False Positive í™•ë¥ 
fp_rate = bf.false_positive_rate(len(items))
print(f"\nFalse Positive í™•ë¥ : {fp_rate:.4f}")
```

## 3. ì¼ê´€ì„± í•´ì‹± (Consistent Hashing)

ì¼ê´€ì„± í•´ì‹±ì€ ë¶„ì‚° ì‹œìŠ¤í…œì—ì„œ ë°ì´í„°ë¥¼ ê· ë“±í•˜ê²Œ ë¶„ë°°í•˜ê³ , ë…¸ë“œ ì¶”ê°€/ì œê±° ì‹œ ìµœì†Œí•œì˜ ë°ì´í„° ì´ë™ë§Œ ë°œìƒí•˜ë„ë¡ í•˜ëŠ” ê¸°ë²•ì…ë‹ˆë‹¤.

```python
import hashlib
import bisect

class ConsistentHashing:
    """
    ì¼ê´€ì„± í•´ì‹± êµ¬í˜„
    """
    def __init__(self, nodes=None, virtual_nodes=150):
        self.virtual_nodes = virtual_nodes
        self.ring = {}  # hash -> node
        self.sorted_keys = []
        
        if nodes:
            for node in nodes:
                self.add_node(node)
    
    def _hash(self, key):
        """í•´ì‹œ í•¨ìˆ˜"""
        return int(hashlib.md5(key.encode()).hexdigest(), 16)
    
    def add_node(self, node):
        """
        ë…¸ë“œ ì¶”ê°€
        Args:
            node: ë…¸ë“œ ì‹ë³„ì
        """
        for i in range(self.virtual_nodes):
            virtual_key = f"{node}:{i}"
            hash_value = self._hash(virtual_key)
            
            self.ring[hash_value] = node
            bisect.insort(self.sorted_keys, hash_value)
        
        print(f"ë…¸ë“œ ì¶”ê°€: {node} ({self.virtual_nodes}ê°œ ê°€ìƒ ë…¸ë“œ)")
    
    def remove_node(self, node):
        """
        ë…¸ë“œ ì œê±°
        Args:
            node: ë…¸ë“œ ì‹ë³„ì
        """
        for i in range(self.virtual_nodes):
            virtual_key = f"{node}:{i}"
            hash_value = self._hash(virtual_key)
            
            del self.ring[hash_value]
            self.sorted_keys.remove(hash_value)
        
        print(f"ë…¸ë“œ ì œê±°: {node}")
    
    def get_node(self, key):
        """
        í‚¤ì— í•´ë‹¹í•˜ëŠ” ë…¸ë“œ ë°˜í™˜
        Args:
            key: ë°ì´í„° í‚¤
        Returns:
            str: ë…¸ë“œ ì‹ë³„ì
        """
        if not self.ring:
            return None
        
        hash_value = self._hash(key)
        
        # í•´ì‹œ ë§ì—ì„œ ì‹œê³„ë°©í–¥ìœ¼ë¡œ ì²« ë²ˆì§¸ ë…¸ë“œ ì°¾ê¸°
        index = bisect.bisect_right(self.sorted_keys, hash_value)
        
        if index == len(self.sorted_keys):
            index = 0
        
        return self.ring[self.sorted_keys[index]]
    
    def get_distribution(self, keys):
        """
        í‚¤ ë¶„ë°° ìƒíƒœ í™•ì¸
        Args:
            keys: í…ŒìŠ¤íŠ¸í•  í‚¤ë“¤
        Returns:
            dict: ë…¸ë“œë³„ í‚¤ ê°œìˆ˜
        """
        distribution = {}
        
        for key in keys:
            node = self.get_node(key)
            distribution[node] = distribution.get(node, 0) + 1
        
        return distribution

# í…ŒìŠ¤íŠ¸
ch = ConsistentHashing(nodes=["node1", "node2", "node3"])

print("\n=== ì¼ê´€ì„± í•´ì‹± í…ŒìŠ¤íŠ¸ ===")

# í‚¤ ë¶„ë°° í…ŒìŠ¤íŠ¸
test_keys = [f"key{i}" for i in range(100)]
distribution = ch.get_distribution(test_keys)

print("\nì´ˆê¸° ë¶„ë°°:")
for node, count in sorted(distribution.items()):
    print(f"  {node}: {count}ê°œ")

# ë…¸ë“œ ì¶”ê°€
print("\në…¸ë“œ4 ì¶”ê°€...")
ch.add_node("node4")

new_distribution = ch.get_distribution(test_keys)
print("\në…¸ë“œ4 ì¶”ê°€ í›„ ë¶„ë°°:")
for node, count in sorted(new_distribution.items()):
    print(f"  {node}: {count}ê°œ")

# ì´ë™ëœ í‚¤ ê³„ì‚°
moved_keys = 0
for key in test_keys:
    old_node = None
    for node, count in distribution.items():
        if ch.get_node(key) != old_node:
            moved_keys += 1
            break

print(f"\nì´ë™ëœ í‚¤ ê°œìˆ˜: {moved_keys} / {len(test_keys)}")
```

## 4. Trieì™€ í•´ì‹œë§µ ì¡°í•©

ìë™ì™„ì„±ê³¼ ê²€ìƒ‰ ìµœì í™”ë¥¼ ìœ„í•œ Trieì™€ í•´ì‹œë§µì˜ ì¡°í•©ì…ë‹ˆë‹¤.

```python
class TrieNode:
    """Trie ë…¸ë“œ"""
    def __init__(self):
        self.children = {}
        self.is_end = False
        self.frequency = 0

class AutoComplete:
    """
    ìë™ì™„ì„± ì‹œìŠ¤í…œ
    Trie + í•´ì‹œë§µ
    """
    def __init__(self):
        self.root = TrieNode()
        self.word_freq = {}  # ë‹¨ì–´ë³„ ë¹ˆë„
    
    def insert(self, word):
        """ë‹¨ì–´ ì‚½ì…"""
        node = self.root
        
        for char in word:
            if char not in node.children:
                node.children[char] = TrieNode()
            node = node.children[char]
        
        node.is_end = True
        node.frequency += 1
        
        # ë¹ˆë„ ë§µ ì—…ë°ì´íŠ¸
        self.word_freq[word] = self.word_freq.get(word, 0) + 1
    
    def search(self, word):
        """ë‹¨ì–´ ê²€ìƒ‰"""
        node = self.root
        
        for char in word:
            if char not in node.children:
                return False
            node = node.children[char]
        
        return node.is_end
    
    def starts_with(self, prefix):
        """ì ‘ë‘ì‚¬ë¡œ ì‹œì‘í•˜ëŠ” ë‹¨ì–´ë“¤ ì°¾ê¸°"""
        node = self.root
        
        for char in prefix:
            if char not in node.children:
                return []
            node = node.children[char]
        
        # ì ‘ë‘ì‚¬ ì´í›„ì˜ ëª¨ë“  ë‹¨ì–´ ì°¾ê¸°
        words = []
        self._dfs(node, prefix, words)
        
        # ë¹ˆë„ìˆœ ì •ë ¬
        words.sort(key=lambda x: self.word_freq.get(x, 0), reverse=True)
        
        return words
    
    def _dfs(self, node, prefix, words):
        """DFSë¡œ ëª¨ë“  ë‹¨ì–´ ì°¾ê¸°"""
        if node.is_end:
            words.append(prefix)
        
        for char, child in node.children.items():
            self._dfs(child, prefix + char, words)
    
    def top_k_suggestions(self, prefix, k=5):
        """ìƒìœ„ kê°œ ìë™ì™„ì„± ì œì•ˆ"""
        suggestions = self.starts_with(prefix)
        return suggestions[:k]

# í…ŒìŠ¤íŠ¸
ac = AutoComplete()

print("=== ìë™ì™„ì„± ì‹œìŠ¤í…œ í…ŒìŠ¤íŠ¸ ===")

# ë‹¨ì–´ë“¤ ì‚½ì…
words = [
    "apple", "application", "apply", "app",
    "banana", "band", "bandana",
    "cat", "car", "card", "care"
]

for word in words:
    # ë¹ˆë„ë¥¼ ì‹œë®¬ë ˆì´ì…˜í•˜ê¸° ìœ„í•´ ì¼ë¶€ ë‹¨ì–´ ì—¬ëŸ¬ ë²ˆ ì‚½ì…
    for _ in range(1 if word not in ["app", "car"] else 3):
        ac.insert(word)

# ìë™ì™„ì„± í…ŒìŠ¤íŠ¸
prefixes = ["app", "ba", "car"]

for prefix in prefixes:
    suggestions = ac.top_k_suggestions(prefix, k=3)
    print(f"\n'{prefix}' ìë™ì™„ì„± (ìƒìœ„ 3ê°œ):")
    for i, word in enumerate(suggestions, 1):
        freq = ac.word_freq.get(word, 0)
        print(f"  {i}. {word} (ë¹ˆë„: {freq})")
```

## ì •ë¦¬

ì´ë²ˆ í¬ìŠ¤íŠ¸ì—ì„œëŠ” í•´ì‹œ í…Œì´ë¸”ì˜ ê³ ê¸‰ í™œìš© ê¸°ë²•ë“¤ì„ ì‚´í´ë³´ì•˜ìŠµë‹ˆë‹¤.

**ê³ ê¸‰ í™œìš© ì •ë¦¬**
1. **LRU ìºì‹œ**: í•´ì‹œë§µê³¼ ì´ì¤‘ ì—°ê²°ë¦¬ìŠ¤íŠ¸ë¡œ O(1) ìºì‹œ êµ¬í˜„
2. **ë¸”ë£¸ í•„í„°**: ê³µê°„ íš¨ìœ¨ì ì¸ ë©¤ë²„ì‹­ í…ŒìŠ¤íŠ¸
3. **ì¼ê´€ì„± í•´ì‹±**: ë¶„ì‚° ì‹œìŠ¤í…œì˜ ê· ë“±í•œ ë°ì´í„° ë¶„ë°°
4. **Trie + í•´ì‹œë§µ**: íš¨ìœ¨ì ì¸ ìë™ì™„ì„±ê³¼ ê²€ìƒ‰
5. **Count-Min Sketch**: ìŠ¤íŠ¸ë¦¼ ë°ì´í„° ë¹ˆë„ ì¶”ì •

**í•´ì‹œ í…Œì´ë¸” ê³ ê¸‰ í™œìš©ì˜ í•µì‹¬ ì›ì¹™**
- **ë³µí•© ìë£Œêµ¬ì¡°**: í•´ì‹œë§µê³¼ ë‹¤ë¥¸ ìë£Œêµ¬ì¡°ì˜ ì¡°í•©
- **í™•ë¥ ì  ìë£Œêµ¬ì¡°**: ê³µê°„ íš¨ìœ¨ì„±ê³¼ ì •í™•ë„ì˜ íŠ¸ë ˆì´ë“œì˜¤í”„
- **ë¶„ì‚° ì‹œìŠ¤í…œ**: ì¼ê´€ì„± í•´ì‹±ìœ¼ë¡œ í™•ì¥ì„± ë³´ì¥
- **ìºì‹± ì „ëµ**: LRU, LFU ë“± ë‹¤ì–‘í•œ ì œê±° ì •ì±…
- **ê²€ìƒ‰ ìµœì í™”**: Trieì™€ í•´ì‹œë§µì˜ ì‹œë„ˆì§€

**ë‹¤ìŒ í•™ìŠµ ê³„íš**
ë‹¤ìŒ í¬ìŠ¤íŠ¸ì—ì„œëŠ” í•´ì‹œ í…Œì´ë¸”ì˜ ì‹¤ë¬´ í™œìš© ì‚¬ë¡€ë¥¼ ì•Œì•„ë³´ê² ìŠµë‹ˆë‹¤:
- [[ìë£Œêµ¬ì¡°] í•´ì‹œ í…Œì´ë¸” í™œìš© - 3]({% post_url 2025-10-07-[ìë£Œêµ¬ì¡°] í•´ì‹œ í…Œì´ë¸”(Hash Table) - í™œìš© - 3 %}) - ë°ì´í„°ë² ì´ìŠ¤ ì¸ë±ì‹±, ì„¸ì…˜ ê´€ë¦¬, ìºì‹± ì‹œìŠ¤í…œ ë“±

# ğŸ“š ë ˆí¼ëŸ°ìŠ¤
- [LRU Cache - LeetCode](https://leetcode.com/problems/lru-cache/)
- [Bloom Filter - Wikipedia](https://en.wikipedia.org/wiki/Bloom_filter)
- [Consistent Hashing - Wikipedia](https://en.wikipedia.org/wiki/Consistent_hashing)
- [Trie Data Structure - Wikipedia](https://en.wikipedia.org/wiki/Trie)

---
*ì´ í¬ìŠ¤íŠ¸ëŠ” ìë£Œêµ¬ì¡° í•™ìŠµ ê³¼ì •ì„ ì •ë¦¬í•œ ë‚´ìš©ì…ë‹ˆë‹¤.*
