---
layout: post
title: "[자료구조] 해시 테이블(Hash Table) - 활용 - 2"
date: 2025-10-07 16:10:00 +0900
categories: [자료구조, 해시테이블]
tags: [자료구조, 해시테이블, LRU캐시, 블룸필터, 일관성해싱, 고급알고리즘]
author: LimJongHan
toc: true
---

# 📖 관련된 내 포스팅
- [[자료구조] 자료구조와 알고리즘 개요]({% post_url 2025-10-02-[자료구조] 자료구조와 알고리즘 개요 %})
- [[자료구조] 해시 테이블(Hash Table) - 기본 예제]({% post_url 2025-10-07-[자료구조] 해시 테이블(Hash Table) - 기본 예제 %})
- [[자료구조] 해시 테이블 활용 - 1]({% post_url 2025-10-07-[자료구조] 해시 테이블(Hash Table) - 활용 - 1 %})

# 📝 내용

## 개요

해시 테이블의 고급 활용에서는 LRU 캐시, 블룸 필터, 일관성 해싱 등 실제 시스템에서 사용되는 고급 기법들을 다룹니다.

**다룰 고급 활용들:**
- **LRU 캐시**: 해시맵과 이중 연결리스트 조합
- **블룸 필터**: 공간 효율적인 집합 멤버십 테스트
- **일관성 해싱**: 분산 시스템의 데이터 분배
- **Trie와 해시맵**: 자동완성과 검색 최적화
- **Count-Min Sketch**: 스트림 데이터 빈도 추정

## 1. LRU 캐시 (Least Recently Used Cache)

LRU 캐시는 가장 최근에 사용되지 않은 항목을 제거하는 캐시 전략입니다.

### 1-1 기본 LRU 캐시 구현

```python
class ListNode:
    """이중 연결리스트 노드"""
    def __init__(self, key=0, value=0):
        self.key = key
        self.value = value
        self.prev = None
        self.next = None

class LRUCache:
    """
    LRU 캐시 구현
    해시맵 + 이중 연결리스트
    """
    def __init__(self, capacity):
        self.capacity = capacity
        self.cache = {}  # key -> ListNode
        
        # 더미 헤드와 테일
        self.head = ListNode()
        self.tail = ListNode()
        self.head.next = self.tail
        self.tail.prev = self.head
    
    def _add_to_front(self, node):
        """노드를 맨 앞(가장 최근)에 추가"""
        node.prev = self.head
        node.next = self.head.next
        self.head.next.prev = node
        self.head.next = node
    
    def _remove_node(self, node):
        """노드 제거"""
        node.prev.next = node.next
        node.next.prev = node.prev
    
    def _move_to_front(self, node):
        """노드를 맨 앞으로 이동"""
        self._remove_node(node)
        self._add_to_front(node)
    
    def _remove_lru(self):
        """가장 오래 사용되지 않은 노드 제거"""
        lru_node = self.tail.prev
        self._remove_node(lru_node)
        return lru_node
    
    def get(self, key):
        """
        키에 해당하는 값 반환 O(1)
        Args:
            key: 키
        Returns:
            int: 값, 없으면 -1
        """
        if key not in self.cache:
            return -1
        
        node = self.cache[key]
        self._move_to_front(node)
        return node.value
    
    def put(self, key, value):
        """
        키-값 쌍 저장 O(1)
        Args:
            key: 키
            value: 값
        """
        if key in self.cache:
            # 기존 노드 업데이트
            node = self.cache[key]
            node.value = value
            self._move_to_front(node)
        else:
            # 새 노드 추가
            node = ListNode(key, value)
            self.cache[key] = node
            self._add_to_front(node)
            
            # 용량 초과 시 LRU 제거
            if len(self.cache) > self.capacity:
                lru_node = self._remove_lru()
                del self.cache[lru_node.key]
    
    def display(self):
        """캐시 상태 출력"""
        print(f"LRU 캐시 (용량: {self.capacity}, 현재: {len(self.cache)})")
        current = self.head.next
        items = []
        while current != self.tail:
            items.append(f"{current.key}={current.value}")
            current = current.next
        print(f"  순서 (최신->오래됨): {' -> '.join(items)}")

# 테스트
lru = LRUCache(3)

print("=== LRU 캐시 테스트 ===")

lru.put(1, "one")
lru.put(2, "two")
lru.put(3, "three")
lru.display()

print(f"\nget(1): {lru.get(1)}")
lru.display()

lru.put(4, "four")  # 2가 제거됨
lru.display()

print(f"\nget(2): {lru.get(2)}")  # -1 (없음)
```

### 1-2 TTL(Time To Live) 기능이 있는 LRU 캐시

```python
import time

class TTLLRUCache(LRUCache):
    """TTL 기능이 추가된 LRU 캐시"""
    
    def __init__(self, capacity, default_ttl=60):
        super().__init__(capacity)
        self.default_ttl = default_ttl
        self.expiry = {}  # key -> expiry_time
    
    def get(self, key):
        """TTL 확인 후 값 반환"""
        if key in self.expiry and time.time() > self.expiry[key]:
            # 만료된 항목 제거
            node = self.cache[key]
            self._remove_node(node)
            del self.cache[key]
            del self.expiry[key]
            return -1
        
        return super().get(key)
    
    def put(self, key, value, ttl=None):
        """TTL과 함께 값 저장"""
        super().put(key, value)
        
        if ttl is None:
            ttl = self.default_ttl
        
        self.expiry[key] = time.time() + ttl
```

## 2. 블룸 필터 (Bloom Filter)

블룸 필터는 원소의 집합 멤버십을 확률적으로 테스트하는 공간 효율적인 자료구조입니다.

```python
import hashlib

class BloomFilter:
    """
    블룸 필터 구현
    """
    def __init__(self, size=1000, hash_count=3):
        self.size = size
        self.hash_count = hash_count
        self.bit_array = [0] * size
    
    def _hash(self, item, seed):
        """해시 함수"""
        h = hashlib.md5(f"{item}{seed}".encode())
        return int(h.hexdigest(), 16) % self.size
    
    def add(self, item):
        """
        원소 추가 O(k) - k는 해시 함수 개수
        Args:
            item: 추가할 원소
        """
        for i in range(self.hash_count):
            index = self._hash(item, i)
            self.bit_array[index] = 1
    
    def contains(self, item):
        """
        원소 존재 여부 확인 O(k)
        Args:
            item: 확인할 원소
        Returns:
            bool: True면 "아마도 존재", False면 "확실히 없음"
        """
        for i in range(self.hash_count):
            index = self._hash(item, i)
            if self.bit_array[index] == 0:
                return False
        return True
    
    def false_positive_rate(self, n):
        """
        False Positive 확률 계산
        Args:
            n: 추가된 원소 개수
        Returns:
            float: False Positive 확률
        """
        # (1 - e^(-kn/m))^k
        # k: 해시 함수 개수, n: 원소 개수, m: 비트 배열 크기
        import math
        
        exponent = -self.hash_count * n / self.size
        probability = (1 - math.exp(exponent)) ** self.hash_count
        
        return probability

# 테스트
bf = BloomFilter(size=100, hash_count=3)

print("=== 블룸 필터 테스트 ===")

# 원소 추가
items = ["apple", "banana", "cherry", "date"]
for item in items:
    bf.add(item)
    print(f"추가: {item}")

# 존재 확인
test_items = ["apple", "grape", "banana", "kiwi", "cherry"]
print("\n존재 확인:")
for item in test_items:
    exists = bf.contains(item)
    print(f"{item}: {'존재 가능' if exists else '확실히 없음'}")

# False Positive 확률
fp_rate = bf.false_positive_rate(len(items))
print(f"\nFalse Positive 확률: {fp_rate:.4f}")
```

## 3. 일관성 해싱 (Consistent Hashing)

일관성 해싱은 분산 시스템에서 데이터를 균등하게 분배하고, 노드 추가/제거 시 최소한의 데이터 이동만 발생하도록 하는 기법입니다.

```python
import hashlib
import bisect

class ConsistentHashing:
    """
    일관성 해싱 구현
    """
    def __init__(self, nodes=None, virtual_nodes=150):
        self.virtual_nodes = virtual_nodes
        self.ring = {}  # hash -> node
        self.sorted_keys = []
        
        if nodes:
            for node in nodes:
                self.add_node(node)
    
    def _hash(self, key):
        """해시 함수"""
        return int(hashlib.md5(key.encode()).hexdigest(), 16)
    
    def add_node(self, node):
        """
        노드 추가
        Args:
            node: 노드 식별자
        """
        for i in range(self.virtual_nodes):
            virtual_key = f"{node}:{i}"
            hash_value = self._hash(virtual_key)
            
            self.ring[hash_value] = node
            bisect.insort(self.sorted_keys, hash_value)
        
        print(f"노드 추가: {node} ({self.virtual_nodes}개 가상 노드)")
    
    def remove_node(self, node):
        """
        노드 제거
        Args:
            node: 노드 식별자
        """
        for i in range(self.virtual_nodes):
            virtual_key = f"{node}:{i}"
            hash_value = self._hash(virtual_key)
            
            del self.ring[hash_value]
            self.sorted_keys.remove(hash_value)
        
        print(f"노드 제거: {node}")
    
    def get_node(self, key):
        """
        키에 해당하는 노드 반환
        Args:
            key: 데이터 키
        Returns:
            str: 노드 식별자
        """
        if not self.ring:
            return None
        
        hash_value = self._hash(key)
        
        # 해시 링에서 시계방향으로 첫 번째 노드 찾기
        index = bisect.bisect_right(self.sorted_keys, hash_value)
        
        if index == len(self.sorted_keys):
            index = 0
        
        return self.ring[self.sorted_keys[index]]
    
    def get_distribution(self, keys):
        """
        키 분배 상태 확인
        Args:
            keys: 테스트할 키들
        Returns:
            dict: 노드별 키 개수
        """
        distribution = {}
        
        for key in keys:
            node = self.get_node(key)
            distribution[node] = distribution.get(node, 0) + 1
        
        return distribution

# 테스트
ch = ConsistentHashing(nodes=["node1", "node2", "node3"])

print("\n=== 일관성 해싱 테스트 ===")

# 키 분배 테스트
test_keys = [f"key{i}" for i in range(100)]
distribution = ch.get_distribution(test_keys)

print("\n초기 분배:")
for node, count in sorted(distribution.items()):
    print(f"  {node}: {count}개")

# 노드 추가
print("\n노드4 추가...")
ch.add_node("node4")

new_distribution = ch.get_distribution(test_keys)
print("\n노드4 추가 후 분배:")
for node, count in sorted(new_distribution.items()):
    print(f"  {node}: {count}개")

# 이동된 키 계산
moved_keys = 0
for key in test_keys:
    old_node = None
    for node, count in distribution.items():
        if ch.get_node(key) != old_node:
            moved_keys += 1
            break

print(f"\n이동된 키 개수: {moved_keys} / {len(test_keys)}")
```

## 4. Trie와 해시맵 조합

자동완성과 검색 최적화를 위한 Trie와 해시맵의 조합입니다.

```python
class TrieNode:
    """Trie 노드"""
    def __init__(self):
        self.children = {}
        self.is_end = False
        self.frequency = 0

class AutoComplete:
    """
    자동완성 시스템
    Trie + 해시맵
    """
    def __init__(self):
        self.root = TrieNode()
        self.word_freq = {}  # 단어별 빈도
    
    def insert(self, word):
        """단어 삽입"""
        node = self.root
        
        for char in word:
            if char not in node.children:
                node.children[char] = TrieNode()
            node = node.children[char]
        
        node.is_end = True
        node.frequency += 1
        
        # 빈도 맵 업데이트
        self.word_freq[word] = self.word_freq.get(word, 0) + 1
    
    def search(self, word):
        """단어 검색"""
        node = self.root
        
        for char in word:
            if char not in node.children:
                return False
            node = node.children[char]
        
        return node.is_end
    
    def starts_with(self, prefix):
        """접두사로 시작하는 단어들 찾기"""
        node = self.root
        
        for char in prefix:
            if char not in node.children:
                return []
            node = node.children[char]
        
        # 접두사 이후의 모든 단어 찾기
        words = []
        self._dfs(node, prefix, words)
        
        # 빈도순 정렬
        words.sort(key=lambda x: self.word_freq.get(x, 0), reverse=True)
        
        return words
    
    def _dfs(self, node, prefix, words):
        """DFS로 모든 단어 찾기"""
        if node.is_end:
            words.append(prefix)
        
        for char, child in node.children.items():
            self._dfs(child, prefix + char, words)
    
    def top_k_suggestions(self, prefix, k=5):
        """상위 k개 자동완성 제안"""
        suggestions = self.starts_with(prefix)
        return suggestions[:k]

# 테스트
ac = AutoComplete()

print("=== 자동완성 시스템 테스트 ===")

# 단어들 삽입
words = [
    "apple", "application", "apply", "app",
    "banana", "band", "bandana",
    "cat", "car", "card", "care"
]

for word in words:
    # 빈도를 시뮬레이션하기 위해 일부 단어 여러 번 삽입
    for _ in range(1 if word not in ["app", "car"] else 3):
        ac.insert(word)

# 자동완성 테스트
prefixes = ["app", "ba", "car"]

for prefix in prefixes:
    suggestions = ac.top_k_suggestions(prefix, k=3)
    print(f"\n'{prefix}' 자동완성 (상위 3개):")
    for i, word in enumerate(suggestions, 1):
        freq = ac.word_freq.get(word, 0)
        print(f"  {i}. {word} (빈도: {freq})")
```

## 정리

이번 포스트에서는 해시 테이블의 고급 활용 기법들을 살펴보았습니다.

**고급 활용 정리**
1. **LRU 캐시**: 해시맵과 이중 연결리스트로 O(1) 캐시 구현
2. **블룸 필터**: 공간 효율적인 멤버십 테스트
3. **일관성 해싱**: 분산 시스템의 균등한 데이터 분배
4. **Trie + 해시맵**: 효율적인 자동완성과 검색
5. **Count-Min Sketch**: 스트림 데이터 빈도 추정

**해시 테이블 고급 활용의 핵심 원칙**
- **복합 자료구조**: 해시맵과 다른 자료구조의 조합
- **확률적 자료구조**: 공간 효율성과 정확도의 트레이드오프
- **분산 시스템**: 일관성 해싱으로 확장성 보장
- **캐싱 전략**: LRU, LFU 등 다양한 제거 정책
- **검색 최적화**: Trie와 해시맵의 시너지

**다음 학습 계획**
다음 포스트에서는 해시 테이블의 실무 활용 사례를 알아보겠습니다:
- [[자료구조] 해시 테이블 활용 - 3]({% post_url 2025-10-07-[자료구조] 해시 테이블(Hash Table) - 활용 - 3 %}) - 데이터베이스 인덱싱, 세션 관리, 캐싱 시스템 등

# 📚 레퍼런스
- [LRU Cache - LeetCode](https://leetcode.com/problems/lru-cache/)
- [Bloom Filter - Wikipedia](https://en.wikipedia.org/wiki/Bloom_filter)
- [Consistent Hashing - Wikipedia](https://en.wikipedia.org/wiki/Consistent_hashing)
- [Trie Data Structure - Wikipedia](https://en.wikipedia.org/wiki/Trie)

---
*이 포스트는 자료구조 학습 과정을 정리한 내용입니다.*
