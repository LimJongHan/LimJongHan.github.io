---
layout: post
title: "[학습] [자료구조] 스택(Stack) 활용 - 3. 실무 활용"
date: 2025-10-04 23:20:00 +0900
categories: [학습, 자료구조]
tags: [자료구조, 스택, Stack, 실무, 브라우저, 실행취소, 웹서버, 계산기, 미들웨어]
author: LimJongHan
toc: true
---

# 📖 관련된 내 포스팅
- [[학습] [자료구조] 자료구조와 알고리즘 개요]({% post_url 2025-10-02-자료구조와-알고리즘-개요 %})
- [[학습] [자료구조] 스택(Stack)]({% post_url 2025-10-04-스택(Stack) %})
- [[학습] [자료구조] 스택(Stack) 활용 - 1. 예제]({% post_url 2025-10-04-스택(Stack)-활용-1-예제 %})
- [[학습] [자료구조] 스택(Stack) 활용 - 2. 고급 활용]({% post_url 2025-10-04-스택(Stack)-활용-2-고급-활용 %})

# 📝 내용

## 개요

스택은 이론적인 자료구조를 넘어서 실제 소프트웨어 개발에서 매우 중요한 역할을 합니다. 이번 포스트에서는 스택이 실제 프로젝트와 시스템에서 어떻게 활용되는지 살펴보겠습니다. 브라우저의 뒤로가기/앞으로가기, 텍스트 편집기의 실행 취소/다시 실행, 웹 서버의 미들웨어 스택, 계산기 애플리케이션 등 실무에서 자주 접하는 시스템들의 내부 동작 원리를 이해할 수 있습니다.

**다룰 실무 활용 사례들:**
- **브라우저 히스토리 관리**: 뒤로가기/앞으로가기 기능 구현
- **실행 취소/다시 실행 시스템**: 텍스트 편집기, 그래픽 편집기 등
- **웹 서버 미들웨어 스택**: Express.js, Flask 등 웹 프레임워크
- **계산기 애플리케이션**: 수식 파싱과 계산
- **메모리 관리와 호출 스택**: 프로그램 실행 시 스택의 역할

## 1. 브라우저 히스토리 관리 시스템

웹 브라우저의 뒤로가기/앞으로가기 기능은 스택을 활용한 대표적인 예시입니다.

### 1-1 기본 브라우저 히스토리 구현

```python
class BrowserHistory:
    """
    브라우저 히스토리 관리 시스템
    뒤로가기/앞으로가기 기능을 스택으로 구현
    """
    def __init__(self, homepage):
        """
        Args:
            homepage (str): 초기 홈페이지 URL
        """
        self.back_stack = []  # 뒤로가기 스택
        self.forward_stack = []  # 앞으로가기 스택
        self.current_url = homepage
        self.history = [homepage]  # 전체 히스토리 기록
    
    def visit(self, url):
        """
        새로운 페이지 방문
        Args:
            url (str): 방문할 URL
        """
        # 앞으로가기 스택 초기화 (새로운 방문이므로)
        self.forward_stack = []
        
        # 현재 URL을 뒤로가기 스택에 추가
        if self.current_url:
            self.back_stack.append(self.current_url)
        
        # 새 URL로 이동
        self.current_url = url
        self.history.append(url)
        
        print(f"방문: {url}")
        print(f"뒤로가기 스택: {self.back_stack}")
        print(f"앞으로가기 스택: {self.forward_stack}")
    
    def back(self, steps=1):
        """
        뒤로가기
        Args:
            steps (int): 뒤로 갈 단계 수
        Returns:
            str: 현재 URL
        """
        if not self.back_stack:
            print("뒤로 갈 페이지가 없습니다.")
            return self.current_url
        
        for _ in range(min(steps, len(self.back_stack))):
            # 현재 URL을 앞으로가기 스택에 추가
            self.forward_stack.append(self.current_url)
            # 뒤로가기 스택에서 URL 가져오기
            self.current_url = self.back_stack.pop()
        
        print(f"뒤로가기 {steps}단계: {self.current_url}")
        return self.current_url
    
    def forward(self, steps=1):
        """
        앞으로가기
        Args:
            steps (int): 앞으로 갈 단계 수
        Returns:
            str: 현재 URL
        """
        if not self.forward_stack:
            print("앞으로 갈 페이지가 없습니다.")
            return self.current_url
        
        for _ in range(min(steps, len(self.forward_stack))):
            # 현재 URL을 뒤로가기 스택에 추가
            self.back_stack.append(self.current_url)
            # 앞으로가기 스택에서 URL 가져오기
            self.current_url = self.forward_stack.pop()
        
        print(f"앞으로가기 {steps}단계: {self.current_url}")
        return self.current_url
    
    def get_current_url(self):
        """현재 URL 반환"""
        return self.current_url
    
    def get_full_history(self):
        """전체 히스토리 반환"""
        return self.history.copy()

# 테스트
print("=== 브라우저 히스토리 시스템 테스트 ===")
browser = BrowserHistory("https://www.google.com")

browser.visit("https://www.github.com")
browser.visit("https://www.stackoverflow.com")
browser.visit("https://www.reddit.com")

print(f"\n현재 페이지: {browser.get_current_url()}")

browser.back(2)  # 2단계 뒤로가기
print(f"뒤로가기 후 현재 페이지: {browser.get_current_url()}")

browser.forward(1)  # 1단계 앞으로가기
print(f"앞으로가기 후 현재 페이지: {browser.get_current_url()}")

browser.visit("https://www.python.org")  # 새 페이지 방문
print(f"새 페이지 방문 후: {browser.get_current_url()}")
print(f"전체 히스토리: {browser.get_full_history()}")
```

### 1-2 고급 브라우저 히스토리 (세션 관리 포함)

```python
import time
from datetime import datetime

class AdvancedBrowserHistory:
    """
    고급 브라우저 히스토리 시스템
    세션 관리, 방문 시간 기록, 즐겨찾기 기능 포함
    """
    def __init__(self, homepage):
        self.back_stack = []
        self.forward_stack = []
        self.current_url = homepage
        self.visit_history = []  # 방문 기록 (URL, 시간, 제목)
        self.bookmarks = set()   # 즐겨찾기
        self.session_start = time.time()
        
        self._add_to_history(homepage, "Homepage")
    
    def _add_to_history(self, url, title="Untitled"):
        """히스토리에 방문 기록 추가"""
        visit_info = {
            'url': url,
            'title': title,
            'timestamp': datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
            'session_time': time.time() - self.session_start
        }
        self.visit_history.append(visit_info)
    
    def visit(self, url, title="Untitled"):
        """페이지 방문"""
        # 앞으로가기 스택 초기화
        self.forward_stack = []
        
        # 현재 URL을 뒤로가기 스택에 추가
        if self.current_url:
            self.back_stack.append(self.current_url)
        
        self.current_url = url
        self._add_to_history(url, title)
        
        print(f"방문: {title} ({url})")
    
    def back(self, steps=1):
        """뒤로가기"""
        if not self.back_stack:
            return self.current_url
        
        for _ in range(min(steps, len(self.back_stack))):
            self.forward_stack.append(self.current_url)
            self.current_url = self.back_stack.pop()
        
        print(f"뒤로가기: {self.current_url}")
        return self.current_url
    
    def forward(self, steps=1):
        """앞으로가기"""
        if not self.forward_stack:
            return self.current_url
        
        for _ in range(min(steps, len(self.forward_stack))):
            self.back_stack.append(self.current_url)
            self.current_url = self.forward_stack.pop()
        
        print(f"앞으로가기: {self.current_url}")
        return self.current_url
    
    def add_bookmark(self, url=None):
        """즐겨찾기 추가"""
        bookmark_url = url or self.current_url
        self.bookmarks.add(bookmark_url)
        print(f"즐겨찾기 추가: {bookmark_url}")
    
    def get_recent_visits(self, count=5):
        """최근 방문 기록 반환"""
        return self.visit_history[-count:]
    
    def get_session_stats(self):
        """세션 통계 반환"""
        total_time = time.time() - self.session_start
        unique_pages = len(set(visit['url'] for visit in self.visit_history))
        
        return {
            'total_visits': len(self.visit_history),
            'unique_pages': unique_pages,
            'session_duration': f"{total_time:.1f}초",
            'bookmarks_count': len(self.bookmarks)
        }

# 테스트
print("\n=== 고급 브라우저 히스토리 테스트 ===")
advanced_browser = AdvancedBrowserHistory("https://www.google.com")

advanced_browser.visit("https://www.github.com", "GitHub")
advanced_browser.visit("https://www.stackoverflow.com", "Stack Overflow")
advanced_browser.add_bookmark("https://www.github.com")

advanced_browser.back(1)
advanced_browser.visit("https://www.python.org", "Python.org")

print(f"\n최근 방문 기록:")
for visit in advanced_browser.get_recent_visits(3):
    print(f"  {visit['timestamp']}: {visit['title']}")

print(f"\n세션 통계: {advanced_browser.get_session_stats()}")
```

## 2. 실행 취소/다시 실행 시스템

텍스트 편집기, 그래픽 편집기 등에서 사용되는 실행 취소/다시 실행 기능을 스택으로 구현합니다.

### 2-1 기본 실행 취소/다시 실행 시스템

```python
class Command:
    """실행 취소 가능한 명령의 기본 클래스"""
    def __init__(self):
        self.executed = False
    
    def execute(self):
        """명령 실행"""
        raise NotImplementedError
    
    def undo(self):
        """명령 취소"""
        raise NotImplementedError

class TextInsertCommand(Command):
    """텍스트 삽입 명령"""
    def __init__(self, text, position):
        super().__init__()
        self.text = text
        self.position = position
        self.original_content = None
    
    def execute(self, document):
        """텍스트 삽입 실행"""
        if not self.executed:
            self.original_content = document.content
            document.insert_text(self.position, self.text)
            self.executed = True
    
    def undo(self, document):
        """텍스트 삽입 취소"""
        if self.executed and self.original_content:
            document.content = self.original_content
            self.executed = False

class TextDeleteCommand(Command):
    """텍스트 삭제 명령"""
    def __init__(self, position, length):
        super().__init__()
        self.position = position
        self.length = length
        self.deleted_text = None
        self.original_content = None
    
    def execute(self, document):
        """텍스트 삭제 실행"""
        if not self.executed:
            self.original_content = document.content
            self.deleted_text = document.content[self.position:self.position + self.length]
            document.delete_text(self.position, self.length)
            self.executed = True
    
    def undo(self, document):
        """텍스트 삭제 취소"""
        if self.executed and self.original_content:
            document.content = self.original_content
            self.executed = False

class Document:
    """문서 클래스"""
    def __init__(self):
        self.content = ""
    
    def insert_text(self, position, text):
        """텍스트 삽입"""
        self.content = self.content[:position] + text + self.content[position:]
    
    def delete_text(self, position, length):
        """텍스트 삭제"""
        self.content = self.content[:position] + self.content[position + length:]
    
    def get_content(self):
        """문서 내용 반환"""
        return self.content

class UndoRedoManager:
    """
    실행 취소/다시 실행 관리자
    스택을 이용하여 명령 히스토리 관리
    """
    def __init__(self, document):
        self.document = document
        self.undo_stack = []  # 실행 취소 스택
        self.redo_stack = []  # 다시 실행 스택
        self.max_history = 50  # 최대 히스토리 수
    
    def execute_command(self, command):
        """명령 실행"""
        # 명령 실행
        command.execute(self.document)
        
        # 실행 취소 스택에 추가
        self.undo_stack.append(command)
        
        # 다시 실행 스택 초기화 (새로운 명령이 실행되었으므로)
        self.redo_stack = []
        
        # 히스토리 크기 제한
        if len(self.undo_stack) > self.max_history:
            self.undo_stack.pop(0)
        
        print(f"명령 실행: {type(command).__name__}")
        print(f"문서 내용: '{self.document.get_content()}'")
    
    def undo(self):
        """실행 취소"""
        if not self.undo_stack:
            print("실행 취소할 명령이 없습니다.")
            return
        
        # 가장 최근 명령을 실행 취소 스택에서 제거
        command = self.undo_stack.pop()
        command.undo(self.document)
        
        # 다시 실행 스택에 추가
        self.redo_stack.append(command)
        
        print(f"실행 취소: {type(command).__name__}")
        print(f"문서 내용: '{self.document.get_content()}'")
    
    def redo(self):
        """다시 실행"""
        if not self.redo_stack:
            print("다시 실행할 명령이 없습니다.")
            return
        
        # 다시 실행 스택에서 명령을 가져와서 실행
        command = self.redo_stack.pop()
        command.execute(self.document)
        
        # 실행 취소 스택에 다시 추가
        self.undo_stack.append(command)
        
        print(f"다시 실행: {type(command).__name__}")
        print(f"문서 내용: '{self.document.get_content()}'")
    
    def can_undo(self):
        """실행 취소 가능 여부"""
        return len(self.undo_stack) > 0
    
    def can_redo(self):
        """다시 실행 가능 여부"""
        return len(self.redo_stack) > 0
    
    def get_history_info(self):
        """히스토리 정보 반환"""
        return {
            'undo_stack_size': len(self.undo_stack),
            'redo_stack_size': len(self.redo_stack),
            'can_undo': self.can_undo(),
            'can_redo': self.can_redo()
        }

# 테스트
print("=== 실행 취소/다시 실행 시스템 테스트 ===")
document = Document()
undo_redo_manager = UndoRedoManager(document)

# 텍스트 삽입
insert_cmd1 = TextInsertCommand("Hello", 0)
undo_redo_manager.execute_command(insert_cmd1)

insert_cmd2 = TextInsertCommand(" World", 5)
undo_redo_manager.execute_command(insert_cmd2)

# 텍스트 삭제
delete_cmd1 = TextDeleteCommand(0, 6)  # "Hello " 삭제
undo_redo_manager.execute_command(delete_cmd1)

print(f"\n현재 문서: '{document.get_content()}'")
print(f"히스토리 정보: {undo_redo_manager.get_history_info()}")

# 실행 취소
undo_redo_manager.undo()
undo_redo_manager.undo()

print(f"\n2번 실행 취소 후: '{document.get_content()}'")

# 다시 실행
undo_redo_manager.redo()
print(f"1번 다시 실행 후: '{document.get_content()}'")
```

### 2-2 고급 실행 취소 시스템 (마이크로 명령 지원)

```python
class MicroCommand(Command):
    """마이크로 명령 (키 입력 단위)"""
    def __init__(self, char, position):
        super().__init__()
        self.char = char
        self.position = position
        self.original_content = None
    
    def execute(self, document):
        if not self.executed:
            self.original_content = document.content
            document.insert_text(self.position, self.char)
            self.executed = True
    
    def undo(self, document):
        if self.executed and self.original_content:
            document.content = self.original_content
            self.executed = False

class MacroCommand(Command):
    """매크로 명령 (여러 명령의 조합)"""
    def __init__(self, commands):
        super().__init__()
        self.commands = commands
        self.original_content = None
    
    def execute(self, document):
        if not self.executed:
            self.original_content = document.content
            for cmd in self.commands:
                cmd.execute(document)
            self.executed = True
    
    def undo(self, document):
        if self.executed and self.original_content:
            document.content = self.original_content
            self.executed = False

class AdvancedUndoRedoManager(UndoRedoManager):
    """고급 실행 취소/다시 실행 관리자"""
    
    def __init__(self, document):
        super().__init__(document)
        self.macro_mode = False
        self.current_macro = []
    
    def start_macro(self):
        """매크로 모드 시작"""
        self.macro_mode = True
        self.current_macro = []
        print("매크로 모드 시작")
    
    def end_macro(self):
        """매크로 모드 종료"""
        if self.macro_mode and self.current_macro:
            macro_command = MacroCommand(self.current_macro.copy())
            self.execute_command(macro_command)
        
        self.macro_mode = False
        self.current_macro = []
        print("매크로 모드 종료")
    
    def execute_command(self, command):
        """명령 실행 (매크로 모드 지원)"""
        if self.macro_mode:
            self.current_macro.append(command)
        else:
            super().execute_command(command)

# 테스트
print("\n=== 고급 실행 취소 시스템 테스트 ===")
advanced_doc = Document()
advanced_manager = AdvancedUndoRedoManager(advanced_doc)

# 매크로 모드로 여러 명령 실행
advanced_manager.start_macro()

cmd1 = MicroCommand("H", 0)
cmd2 = MicroCommand("e", 1)
cmd3 = MicroCommand("l", 2)
cmd4 = MicroCommand("l", 3)
cmd5 = MicroCommand("o", 4)

for cmd in [cmd1, cmd2, cmd3, cmd4, cmd5]:
    advanced_manager.execute_command(cmd)

advanced_manager.end_macro()

print(f"매크로 실행 후: '{advanced_doc.get_content()}'")
print(f"히스토리: {advanced_manager.get_history_info()}")

# 매크로 전체 실행 취소
advanced_manager.undo()
print(f"매크로 실행 취소 후: '{advanced_doc.get_content()}'")
```

## 3. 웹 서버 미들웨어 스택

웹 프레임워크에서 미들웨어는 요청과 응답을 처리하는 중간 단계로, 스택 구조로 관리됩니다.

### 3-1 기본 미들웨어 스택 구현

```python
from functools import wraps
import time
import json

class Middleware:
    """미들웨어 기본 클래스"""
    def __init__(self):
        self.next_middleware = None
    
    def set_next(self, middleware):
        """다음 미들웨어 설정"""
        self.next_middleware = middleware
        return middleware
    
    def process_request(self, request):
        """요청 처리"""
        pass
    
    def process_response(self, response):
        """응답 처리"""
        pass
    
    def handle(self, request):
        """미들웨어 체인 실행"""
        # 요청 처리
        self.process_request(request)
        
        # 다음 미들웨어 실행
        if self.next_middleware:
            response = self.next_middleware.handle(request)
        else:
            # 마지막 미들웨어인 경우 기본 응답 생성
            response = {
                'status': 200,
                'headers': {},
                'body': 'OK'
            }
        
        # 응답 처리
        self.process_response(response)
        return response

class LoggingMiddleware(Middleware):
    """로깅 미들웨어"""
    def __init__(self):
        super().__init__()
        self.logs = []
    
    def process_request(self, request):
        request['start_time'] = time.time()
        log_entry = f"[{time.strftime('%H:%M:%S')}] {request['method']} {request['path']}"
        self.logs.append(log_entry)
        print(f"요청 로그: {log_entry}")
    
    def process_response(self, response):
        if 'start_time' in response.get('request', {}):
            duration = time.time() - response['request']['start_time']
            log_entry = f"응답 시간: {duration:.3f}초"
            self.logs.append(log_entry)
            print(log_entry)

class AuthenticationMiddleware(Middleware):
    """인증 미들웨어"""
    def __init__(self):
        super().__init__()
        self.valid_tokens = {'user123', 'admin456', 'guest789'}
    
    def process_request(self, request):
        token = request.get('headers', {}).get('Authorization', '')
        
        if not token:
            raise Exception("인증 토큰이 필요합니다")
        
        if token not in self.valid_tokens:
            raise Exception("유효하지 않은 인증 토큰")
        
        print(f"인증 성공: {token}")

class CORSMiddleware(Middleware):
    """CORS 미들웨어"""
    def __init__(self):
        super().__init__()
        self.allowed_origins = ['http://localhost:3000', 'https://example.com']
    
    def process_request(self, request):
        origin = request.get('headers', {}).get('Origin', '')
        if origin and origin not in self.allowed_origins:
            raise Exception(f"허용되지 않은 Origin: {origin}")
    
    def process_response(self, response):
        response['headers']['Access-Control-Allow-Origin'] = '*'
        response['headers']['Access-Control-Allow-Methods'] = 'GET, POST, PUT, DELETE'
        response['headers']['Access-Control-Allow-Headers'] = 'Content-Type, Authorization'

class RateLimitMiddleware(Middleware):
    """속도 제한 미들웨어"""
    def __init__(self, max_requests=10, time_window=60):
        super().__init__()
        self.max_requests = max_requests
        self.time_window = time_window
        self.requests = {}  # IP별 요청 기록
    
    def process_request(self, request):
        client_ip = request.get('client_ip', 'unknown')
        current_time = time.time()
        
        # 오래된 요청 기록 정리
        if client_ip in self.requests:
            self.requests[client_ip] = [
                req_time for req_time in self.requests[client_ip]
                if current_time - req_time < self.time_window
            ]
        else:
            self.requests[client_ip] = []
        
        # 요청 수 확인
        if len(self.requests[client_ip]) >= self.max_requests:
            raise Exception(f"속도 제한 초과: {client_ip}")
        
        # 현재 요청 기록
        self.requests[client_ip].append(current_time)
        print(f"속도 제한 확인: {client_ip} ({len(self.requests[client_ip])}/{self.max_requests})")

class WebServer:
    """웹 서버 클래스"""
    def __init__(self):
        self.middleware_stack = None
    
    def add_middleware(self, middleware):
        """미들웨어 추가"""
        if self.middleware_stack is None:
            self.middleware_stack = middleware
        else:
            self.middleware_stack.set_next(middleware)
    
    def handle_request(self, request):
        """요청 처리"""
        try:
            if self.middleware_stack:
                response = self.middleware_stack.handle(request)
            else:
                response = {'status': 200, 'headers': {}, 'body': 'OK'}
            
            print(f"응답: {response['status']}")
            return response
        
        except Exception as e:
            error_response = {
                'status': 400,
                'headers': {'Content-Type': 'application/json'},
                'body': json.dumps({'error': str(e)})
            }
            print(f"오류 응답: {error_response}")
            return error_response

# 테스트
print("=== 웹 서버 미들웨어 스택 테스트 ===")
server = WebServer()

# 미들웨어 스택 구성 (순서 중요)
server.add_middleware(LoggingMiddleware())
server.add_middleware(CORSMiddleware())
server.add_middleware(RateLimitMiddleware(max_requests=5, time_window=10))
server.add_middleware(AuthenticationMiddleware())

# 테스트 요청
test_requests = [
    {
        'method': 'GET',
        'path': '/api/users',
        'headers': {'Authorization': 'user123', 'Origin': 'http://localhost:3000'},
        'client_ip': '192.168.1.1'
    },
    {
        'method': 'POST',
        'path': '/api/posts',
        'headers': {'Authorization': 'admin456', 'Origin': 'http://localhost:3000'},
        'client_ip': '192.168.1.1'
    }
]

for request in test_requests:
    print(f"\n--- 요청 처리: {request['method']} {request['path']} ---")
    response = server.handle_request(request)
    print(f"최종 응답: {response['status']} - {response['body']}")
```

### 3-2 Express.js 스타일 미들웨어 시스템

```python
class ExpressStyleMiddleware:
    """Express.js 스타일 미들웨어 시스템"""
    
    def __init__(self):
        self.middlewares = []
        self.error_handlers = []
    
    def use(self, middleware):
        """미들웨어 등록"""
        self.middlewares.append(middleware)
        return self
    
    def use_error_handler(self, error_handler):
        """에러 핸들러 등록"""
        self.error_handlers.append(error_handler)
        return self
    
    def _execute_middleware(self, middleware, request, response, next):
        """미들웨어 실행"""
        try:
            if isinstance(middleware, dict) and 'path' in middleware:
                # 경로별 미들웨어
                if request['path'].startswith(middleware['path']):
                    middleware['handler'](request, response, next)
                else:
                    next()
            else:
                # 일반 미들웨어
                middleware(request, response, next)
        except Exception as e:
            next(e)
    
    def handle_request(self, request):
        """요청 처리"""
        response = {
            'status': 200,
            'headers': {},
            'body': '',
            'locals': {}
        }
        
        middleware_index = 0
        
        def next(error=None):
            nonlocal middleware_index
            
            if error:
                # 에러 처리
                if middleware_index < len(self.error_handlers):
                    error_handler = self.error_handlers[middleware_index - len(self.middlewares)]
                    error_handler(error, request, response, next)
                else:
                    response['status'] = 500
                    response['body'] = f'Internal Server Error: {error}'
                return
            
            if middleware_index < len(self.middlewares):
                middleware = self.middlewares[middleware_index]
                middleware_index += 1
                self._execute_middleware(middleware, request, response, next)
            else:
                # 모든 미들웨어 처리 완료
                if response['body'] == '':
                    response['body'] = 'OK'
        
        next()
        return response

# Express.js 스타일 테스트
print("\n=== Express.js 스타일 미들웨어 테스트 ===")

def logger_middleware(req, res, next):
    print(f"Logger: {req['method']} {req['path']}")
    next()

def auth_middleware(req, res, next):
    if req.get('headers', {}).get('Authorization'):
        print("인증 확인됨")
        next()
    else:
        next("인증 필요")

def api_middleware(req, res, next):
    if req['path'].startswith('/api'):
        res['body'] = f"API Response for {req['path']}"
        print(f"API 처리: {req['path']}")
    next()

def error_handler(error, req, res, next):
    print(f"에러 처리: {error}")
    res['status'] = 401
    res['body'] = f"Error: {error}"

# Express 스타일 서버 구성
express_server = ExpressStyleMiddleware()
express_server.use(logger_middleware)
express_server.use(auth_middleware)
express_server.use(api_middleware)
express_server.use_error_handler(error_handler)

# 테스트 요청
test_request = {
    'method': 'GET',
    'path': '/api/users',
    'headers': {'Authorization': 'Bearer token123'}
}

response = express_server.handle_request(test_request)
print(f"Express 스타일 응답: {response}")
```

## 4. 계산기 애플리케이션

스택을 이용한 수식 계산기 구현입니다.

### 4-1 기본 계산기 (후위 표기법)

```python
class Calculator:
    """스택 기반 계산기"""
    
    def __init__(self):
        self.operators = {
            '+': lambda x, y: x + y,
            '-': lambda x, y: x - y,
            '*': lambda x, y: x * y,
            '/': lambda x, y: x / y if y != 0 else float('inf'),
            '^': lambda x, y: x ** y
        }
    
    def infix_to_postfix(self, expression):
        """중위 표기법을 후위 표기법으로 변환"""
        precedence = {'^': 4, '*': 3, '/': 3, '+': 2, '-': 2}
        stack = []
        output = []
        
        i = 0
        while i < len(expression):
            char = expression[i]
            
            if char.isdigit() or char == '.':
                # 숫자 파싱
                num = ""
                while i < len(expression) and (expression[i].isdigit() or expression[i] == '.'):
                    num += expression[i]
                    i += 1
                output.append(num)
                continue
            
            elif char == '(':
                stack.append(char)
            
            elif char == ')':
                while stack and stack[-1] != '(':
                    output.append(stack.pop())
                stack.pop()
            
            elif char in precedence:
                while (stack and stack[-1] != '(' and 
                       precedence[stack[-1]] >= precedence[char]):
                    output.append(stack.pop())
                stack.append(char)
            
            i += 1
        
        while stack:
            output.append(stack.pop())
        
        return output
    
    def evaluate_postfix(self, postfix):
        """후위 표기법 계산"""
        stack = []
        
        for token in postfix:
            if token in self.operators:
                if len(stack) < 2:
                    raise ValueError("피연산자 부족")
                
                b = float(stack.pop())
                a = float(stack.pop())
                result = self.operators[token](a, b)
                stack.append(result)
            else:
                stack.append(float(token))
        
        if len(stack) != 1:
            raise ValueError("잘못된 수식")
        
        return stack[0]
    
    def calculate(self, expression):
        """수식 계산 (중위 표기법 입력)"""
        try:
            # 공백 제거
            expression = expression.replace(" ", "")
            
            # 괄호 검사
            if not self._is_valid_expression(expression):
                raise ValueError("잘못된 수식")
            
            # 후위 표기법으로 변환
            postfix = self.infix_to_postfix(expression)
            print(f"후위 표기법: {' '.join(postfix)}")
            
            # 계산
            result = self.evaluate_postfix(postfix)
            return result
        
        except Exception as e:
            raise ValueError(f"계산 오류: {e}")
    
    def _is_valid_expression(self, expression):
        """수식 유효성 검사"""
        stack = []
        for char in expression:
            if char == '(':
                stack.append(char)
            elif char == ')':
                if not stack:
                    return False
                stack.pop()
        return len(stack) == 0

# 테스트
print("=== 계산기 애플리케이션 테스트 ===")
calc = Calculator()

test_expressions = [
    "3 + 4 * 2",
    "(3 + 4) * 2",
    "2 ^ 3",
    "10 / (2 + 3)",
    "3 * (4 + 2) - 1"
]

for expr in test_expressions:
    try:
        result = calc.calculate(expr)
        print(f"{expr} = {result}")
    except Exception as e:
        print(f"{expr} -> 오류: {e}")
```

### 4-2 고급 계산기 (기능 확장)

```python
import math

class AdvancedCalculator(Calculator):
    """고급 계산기 (삼각함수, 로그, 상수 지원)"""
    
    def __init__(self):
        super().__init__()
        
        # 추가 연산자
        self.operators.update({
            'sin': lambda x: math.sin(math.radians(x)),
            'cos': lambda x: math.cos(math.radians(x)),
            'tan': lambda x: math.tan(math.radians(x)),
            'log': lambda x: math.log10(x),
            'ln': lambda x: math.log(x),
            'sqrt': lambda x: math.sqrt(x),
            'abs': lambda x: abs(x)
        })
        
        # 상수
        self.constants = {
            'pi': math.pi,
            'e': math.e
        }
    
    def tokenize(self, expression):
        """수식을 토큰으로 분리"""
        tokens = []
        i = 0
        
        while i < len(expression):
            char = expression[i]
            
            if char.isdigit() or char == '.':
                # 숫자 파싱
                num = ""
                while i < len(expression) and (expression[i].isdigit() or expression[i] == '.'):
                    num += expression[i]
                    i += 1
                tokens.append(('number', num))
                continue
            
            elif char.isalpha():
                # 함수명이나 상수 파싱
                word = ""
                while i < len(expression) and expression[i].isalpha():
                    word += expression[i]
                    i += 1
                
                if word in self.constants:
                    tokens.append(('constant', word))
                elif word in self.operators:
                    tokens.append(('function', word))
                else:
                    raise ValueError(f"알 수 없는 식별자: {word}")
                continue
            
            elif char in '+-*/^()':
                tokens.append(('operator', char))
            
            elif char == ' ':
                pass  # 공백 무시
            
            else:
                raise ValueError(f"알 수 없는 문자: {char}")
            
            i += 1
        
        return tokens
    
    def advanced_infix_to_postfix(self, expression):
        """고급 중위 표기법을 후위 표기법으로 변환"""
        tokens = self.tokenize(expression)
        precedence = {'^': 4, '*': 3, '/': 3, '+': 2, '-': 2}
        stack = []
        output = []
        
        for token_type, token_value in tokens:
            if token_type == 'number':
                output.append(token_value)
            
            elif token_type == 'constant':
                output.append(str(self.constants[token_value]))
            
            elif token_type == 'function':
                stack.append(token_value)
            
            elif token_value == '(':
                stack.append(token_value)
            
            elif token_value == ')':
                while stack and stack[-1] != '(':
                    output.append(stack.pop())
                stack.pop()  # '(' 제거
                
                # 함수가 있으면 추가
                if stack and stack[-1] in self.operators:
                    output.append(stack.pop())
            
            elif token_value in precedence:
                while (stack and stack[-1] != '(' and 
                       stack[-1] in precedence and
                       precedence[stack[-1]] >= precedence[token_value]):
                    output.append(stack.pop())
                stack.append(token_value)
        
        while stack:
            output.append(stack.pop())
        
        return output
    
    def advanced_evaluate_postfix(self, postfix):
        """고급 후위 표기법 계산"""
        stack = []
        
        for token in postfix:
            if token in self.operators:
                if token in ['sin', 'cos', 'tan', 'log', 'ln', 'sqrt', 'abs']:
                    # 단항 연산자
                    if not stack:
                        raise ValueError("피연산자 부족")
                    a = float(stack.pop())
                    result = self.operators[token](a)
                    stack.append(result)
                else:
                    # 이항 연산자
                    if len(stack) < 2:
                        raise ValueError("피연산자 부족")
                    b = float(stack.pop())
                    a = float(stack.pop())
                    result = self.operators[token](a, b)
                    stack.append(result)
            else:
                stack.append(float(token))
        
        if len(stack) != 1:
            raise ValueError("잘못된 수식")
        
        return stack[0]
    
    def advanced_calculate(self, expression):
        """고급 수식 계산"""
        try:
            expression = expression.replace(" ", "")
            
            if not self._is_valid_expression(expression):
                raise ValueError("잘못된 수식")
            
            postfix = self.advanced_infix_to_postfix(expression)
            print(f"후위 표기법: {' '.join(postfix)}")
            
            result = self.advanced_evaluate_postfix(postfix)
            return result
        
        except Exception as e:
            raise ValueError(f"계산 오류: {e}")

# 테스트
print("\n=== 고급 계산기 테스트 ===")
advanced_calc = AdvancedCalculator()

advanced_expressions = [
    "sin(30) + cos(60)",
    "sqrt(16) + log(100)",
    "pi * 2",
    "abs(-5) + ln(e)",
    "sin(90) + cos(0)"
]

for expr in advanced_expressions:
    try:
        result = advanced_calc.advanced_calculate(expr)
        print(f"{expr} = {result:.6f}")
    except Exception as e:
        print(f"{expr} -> 오류: {e}")
```

## 정리

이번 포스트에서는 스택의 실무 활용 사례들을 살펴보았습니다.

**실무 활용 정리**
1. **브라우저 히스토리**: 뒤로가기/앞으로가기 기능의 스택 기반 구현
2. **실행 취소/다시 실행**: 텍스트 편집기와 그래픽 편집기의 핵심 기능
3. **웹 서버 미들웨어**: Express.js, Flask 등 웹 프레임워크의 요청 처리 파이프라인
4. **계산기 애플리케이션**: 수식 파싱과 계산에서 스택의 활용
5. **메모리 관리**: 프로그램 실행 시 호출 스택과 메모리 스택의 역할

**스택 실무 활용의 핵심 원칙**
- **상태 관리**: 이전 상태를 기억하고 복원하는 기능
- **파이프라인 처리**: 순차적으로 처리되어야 하는 작업들의 체인
- **역순 처리**: LIFO 특성을 활용한 역방향 처리
- **메모리 효율성**: 제한된 메모리 환경에서의 효율적인 데이터 관리
- **사용자 경험**: 직관적이고 예측 가능한 동작 제공

**실무에서의 스택 활용 패턴**
- **히스토리 관리**: 브라우저, 편집기, 게임 등에서의 되돌리기 기능
- **중간 처리**: 웹 서버의 미들웨어, 컴파일러의 파싱 과정
- **계산 엔진**: 수식 계산기, 인터프리터, 가상 머신
- **메모리 관리**: 함수 호출, 지역 변수, 실행 컨텍스트

스택은 단순한 자료구조이지만, 실제 소프트웨어 개발에서 매우 중요한 역할을 합니다. 이러한 실무 활용 사례들을 이해하면 더욱 효과적인 시스템 설계와 구현이 가능해집니다.

# 📚 레퍼런스
- [Express.js Middleware - Official Documentation](https://expressjs.com/en/guide/using-middleware.html)
- [Browser History API - MDN Web Docs](https://developer.mozilla.org/en-US/docs/Web/API/History_API)
- [Command Pattern - Wikipedia](https://en.wikipedia.org/wiki/Command_pattern)
- [Call Stack - MDN Web Docs](https://developer.mozilla.org/en-US/docs/Glossary/Call_stack)

---
*이 포스트는 자료구조 학습 과정을 정리한 내용입니다.*
