---
layout: post
title: "[í•™ìŠµ] [ìë£Œêµ¬ì¡°] ìŠ¤íƒ(Stack) í™œìš© - 3. ì‹¤ë¬´ í™œìš©"
date: 2025-10-04 23:20:00 +0900
categories: [í•™ìŠµ, ìë£Œêµ¬ì¡°]
tags: [ìë£Œêµ¬ì¡°, ìŠ¤íƒ, Stack, ì‹¤ë¬´, ë¸Œë¼ìš°ì €, ì‹¤í–‰ì·¨ì†Œ, ì›¹ì„œë²„, ê³„ì‚°ê¸°, ë¯¸ë“¤ì›¨ì–´]
author: LimJongHan
toc: true
---

# ğŸ“– ê´€ë ¨ëœ ë‚´ í¬ìŠ¤íŒ…
- [[í•™ìŠµ] [ìë£Œêµ¬ì¡°] ìë£Œêµ¬ì¡°ì™€ ì•Œê³ ë¦¬ì¦˜ ê°œìš”]({% post_url 2025-10-02-ìë£Œêµ¬ì¡°ì™€-ì•Œê³ ë¦¬ì¦˜-ê°œìš” %})
- [[í•™ìŠµ] [ìë£Œêµ¬ì¡°] ìŠ¤íƒ(Stack)]({% post_url 2025-10-04-ìŠ¤íƒ(Stack) %})
- [[í•™ìŠµ] [ìë£Œêµ¬ì¡°] ìŠ¤íƒ(Stack) í™œìš© - 1. ì˜ˆì œ]({% post_url 2025-10-04-ìŠ¤íƒ(Stack)-í™œìš©-1-ì˜ˆì œ %})
- [[í•™ìŠµ] [ìë£Œêµ¬ì¡°] ìŠ¤íƒ(Stack) í™œìš© - 2. ê³ ê¸‰ í™œìš©]({% post_url 2025-10-04-ìŠ¤íƒ(Stack)-í™œìš©-2-ê³ ê¸‰-í™œìš© %})

# ğŸ“ ë‚´ìš©

## ê°œìš”

ìŠ¤íƒì€ ì´ë¡ ì ì¸ ìë£Œêµ¬ì¡°ë¥¼ ë„˜ì–´ì„œ ì‹¤ì œ ì†Œí”„íŠ¸ì›¨ì–´ ê°œë°œì—ì„œ ë§¤ìš° ì¤‘ìš”í•œ ì—­í• ì„ í•©ë‹ˆë‹¤. ì´ë²ˆ í¬ìŠ¤íŠ¸ì—ì„œëŠ” ìŠ¤íƒì´ ì‹¤ì œ í”„ë¡œì íŠ¸ì™€ ì‹œìŠ¤í…œì—ì„œ ì–´ë–»ê²Œ í™œìš©ë˜ëŠ”ì§€ ì‚´í´ë³´ê² ìŠµë‹ˆë‹¤. ë¸Œë¼ìš°ì €ì˜ ë’¤ë¡œê°€ê¸°/ì•ìœ¼ë¡œê°€ê¸°, í…ìŠ¤íŠ¸ í¸ì§‘ê¸°ì˜ ì‹¤í–‰ ì·¨ì†Œ/ë‹¤ì‹œ ì‹¤í–‰, ì›¹ ì„œë²„ì˜ ë¯¸ë“¤ì›¨ì–´ ìŠ¤íƒ, ê³„ì‚°ê¸° ì• í”Œë¦¬ì¼€ì´ì…˜ ë“± ì‹¤ë¬´ì—ì„œ ìì£¼ ì ‘í•˜ëŠ” ì‹œìŠ¤í…œë“¤ì˜ ë‚´ë¶€ ë™ì‘ ì›ë¦¬ë¥¼ ì´í•´í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

**ë‹¤ë£° ì‹¤ë¬´ í™œìš© ì‚¬ë¡€ë“¤:**
- **ë¸Œë¼ìš°ì € íˆìŠ¤í† ë¦¬ ê´€ë¦¬**: ë’¤ë¡œê°€ê¸°/ì•ìœ¼ë¡œê°€ê¸° ê¸°ëŠ¥ êµ¬í˜„
- **ì‹¤í–‰ ì·¨ì†Œ/ë‹¤ì‹œ ì‹¤í–‰ ì‹œìŠ¤í…œ**: í…ìŠ¤íŠ¸ í¸ì§‘ê¸°, ê·¸ë˜í”½ í¸ì§‘ê¸° ë“±
- **ì›¹ ì„œë²„ ë¯¸ë“¤ì›¨ì–´ ìŠ¤íƒ**: Express.js, Flask ë“± ì›¹ í”„ë ˆì„ì›Œí¬
- **ê³„ì‚°ê¸° ì• í”Œë¦¬ì¼€ì´ì…˜**: ìˆ˜ì‹ íŒŒì‹±ê³¼ ê³„ì‚°
- **ë©”ëª¨ë¦¬ ê´€ë¦¬ì™€ í˜¸ì¶œ ìŠ¤íƒ**: í”„ë¡œê·¸ë¨ ì‹¤í–‰ ì‹œ ìŠ¤íƒì˜ ì—­í• 

## 1. ë¸Œë¼ìš°ì € íˆìŠ¤í† ë¦¬ ê´€ë¦¬ ì‹œìŠ¤í…œ

ì›¹ ë¸Œë¼ìš°ì €ì˜ ë’¤ë¡œê°€ê¸°/ì•ìœ¼ë¡œê°€ê¸° ê¸°ëŠ¥ì€ ìŠ¤íƒì„ í™œìš©í•œ ëŒ€í‘œì ì¸ ì˜ˆì‹œì…ë‹ˆë‹¤.

### 1-1 ê¸°ë³¸ ë¸Œë¼ìš°ì € íˆìŠ¤í† ë¦¬ êµ¬í˜„

```python
class BrowserHistory:
    """
    ë¸Œë¼ìš°ì € íˆìŠ¤í† ë¦¬ ê´€ë¦¬ ì‹œìŠ¤í…œ
    ë’¤ë¡œê°€ê¸°/ì•ìœ¼ë¡œê°€ê¸° ê¸°ëŠ¥ì„ ìŠ¤íƒìœ¼ë¡œ êµ¬í˜„
    """
    def __init__(self, homepage):
        """
        Args:
            homepage (str): ì´ˆê¸° í™ˆí˜ì´ì§€ URL
        """
        self.back_stack = []  # ë’¤ë¡œê°€ê¸° ìŠ¤íƒ
        self.forward_stack = []  # ì•ìœ¼ë¡œê°€ê¸° ìŠ¤íƒ
        self.current_url = homepage
        self.history = [homepage]  # ì „ì²´ íˆìŠ¤í† ë¦¬ ê¸°ë¡
    
    def visit(self, url):
        """
        ìƒˆë¡œìš´ í˜ì´ì§€ ë°©ë¬¸
        Args:
            url (str): ë°©ë¬¸í•  URL
        """
        # ì•ìœ¼ë¡œê°€ê¸° ìŠ¤íƒ ì´ˆê¸°í™” (ìƒˆë¡œìš´ ë°©ë¬¸ì´ë¯€ë¡œ)
        self.forward_stack = []
        
        # í˜„ì¬ URLì„ ë’¤ë¡œê°€ê¸° ìŠ¤íƒì— ì¶”ê°€
        if self.current_url:
            self.back_stack.append(self.current_url)
        
        # ìƒˆ URLë¡œ ì´ë™
        self.current_url = url
        self.history.append(url)
        
        print(f"ë°©ë¬¸: {url}")
        print(f"ë’¤ë¡œê°€ê¸° ìŠ¤íƒ: {self.back_stack}")
        print(f"ì•ìœ¼ë¡œê°€ê¸° ìŠ¤íƒ: {self.forward_stack}")
    
    def back(self, steps=1):
        """
        ë’¤ë¡œê°€ê¸°
        Args:
            steps (int): ë’¤ë¡œ ê°ˆ ë‹¨ê³„ ìˆ˜
        Returns:
            str: í˜„ì¬ URL
        """
        if not self.back_stack:
            print("ë’¤ë¡œ ê°ˆ í˜ì´ì§€ê°€ ì—†ìŠµë‹ˆë‹¤.")
            return self.current_url
        
        for _ in range(min(steps, len(self.back_stack))):
            # í˜„ì¬ URLì„ ì•ìœ¼ë¡œê°€ê¸° ìŠ¤íƒì— ì¶”ê°€
            self.forward_stack.append(self.current_url)
            # ë’¤ë¡œê°€ê¸° ìŠ¤íƒì—ì„œ URL ê°€ì ¸ì˜¤ê¸°
            self.current_url = self.back_stack.pop()
        
        print(f"ë’¤ë¡œê°€ê¸° {steps}ë‹¨ê³„: {self.current_url}")
        return self.current_url
    
    def forward(self, steps=1):
        """
        ì•ìœ¼ë¡œê°€ê¸°
        Args:
            steps (int): ì•ìœ¼ë¡œ ê°ˆ ë‹¨ê³„ ìˆ˜
        Returns:
            str: í˜„ì¬ URL
        """
        if not self.forward_stack:
            print("ì•ìœ¼ë¡œ ê°ˆ í˜ì´ì§€ê°€ ì—†ìŠµë‹ˆë‹¤.")
            return self.current_url
        
        for _ in range(min(steps, len(self.forward_stack))):
            # í˜„ì¬ URLì„ ë’¤ë¡œê°€ê¸° ìŠ¤íƒì— ì¶”ê°€
            self.back_stack.append(self.current_url)
            # ì•ìœ¼ë¡œê°€ê¸° ìŠ¤íƒì—ì„œ URL ê°€ì ¸ì˜¤ê¸°
            self.current_url = self.forward_stack.pop()
        
        print(f"ì•ìœ¼ë¡œê°€ê¸° {steps}ë‹¨ê³„: {self.current_url}")
        return self.current_url
    
    def get_current_url(self):
        """í˜„ì¬ URL ë°˜í™˜"""
        return self.current_url
    
    def get_full_history(self):
        """ì „ì²´ íˆìŠ¤í† ë¦¬ ë°˜í™˜"""
        return self.history.copy()

# í…ŒìŠ¤íŠ¸
print("=== ë¸Œë¼ìš°ì € íˆìŠ¤í† ë¦¬ ì‹œìŠ¤í…œ í…ŒìŠ¤íŠ¸ ===")
browser = BrowserHistory("https://www.google.com")

browser.visit("https://www.github.com")
browser.visit("https://www.stackoverflow.com")
browser.visit("https://www.reddit.com")

print(f"\ní˜„ì¬ í˜ì´ì§€: {browser.get_current_url()}")

browser.back(2)  # 2ë‹¨ê³„ ë’¤ë¡œê°€ê¸°
print(f"ë’¤ë¡œê°€ê¸° í›„ í˜„ì¬ í˜ì´ì§€: {browser.get_current_url()}")

browser.forward(1)  # 1ë‹¨ê³„ ì•ìœ¼ë¡œê°€ê¸°
print(f"ì•ìœ¼ë¡œê°€ê¸° í›„ í˜„ì¬ í˜ì´ì§€: {browser.get_current_url()}")

browser.visit("https://www.python.org")  # ìƒˆ í˜ì´ì§€ ë°©ë¬¸
print(f"ìƒˆ í˜ì´ì§€ ë°©ë¬¸ í›„: {browser.get_current_url()}")
print(f"ì „ì²´ íˆìŠ¤í† ë¦¬: {browser.get_full_history()}")
```

### 1-2 ê³ ê¸‰ ë¸Œë¼ìš°ì € íˆìŠ¤í† ë¦¬ (ì„¸ì…˜ ê´€ë¦¬ í¬í•¨)

```python
import time
from datetime import datetime

class AdvancedBrowserHistory:
    """
    ê³ ê¸‰ ë¸Œë¼ìš°ì € íˆìŠ¤í† ë¦¬ ì‹œìŠ¤í…œ
    ì„¸ì…˜ ê´€ë¦¬, ë°©ë¬¸ ì‹œê°„ ê¸°ë¡, ì¦ê²¨ì°¾ê¸° ê¸°ëŠ¥ í¬í•¨
    """
    def __init__(self, homepage):
        self.back_stack = []
        self.forward_stack = []
        self.current_url = homepage
        self.visit_history = []  # ë°©ë¬¸ ê¸°ë¡ (URL, ì‹œê°„, ì œëª©)
        self.bookmarks = set()   # ì¦ê²¨ì°¾ê¸°
        self.session_start = time.time()
        
        self._add_to_history(homepage, "Homepage")
    
    def _add_to_history(self, url, title="Untitled"):
        """íˆìŠ¤í† ë¦¬ì— ë°©ë¬¸ ê¸°ë¡ ì¶”ê°€"""
        visit_info = {
            'url': url,
            'title': title,
            'timestamp': datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
            'session_time': time.time() - self.session_start
        }
        self.visit_history.append(visit_info)
    
    def visit(self, url, title="Untitled"):
        """í˜ì´ì§€ ë°©ë¬¸"""
        # ì•ìœ¼ë¡œê°€ê¸° ìŠ¤íƒ ì´ˆê¸°í™”
        self.forward_stack = []
        
        # í˜„ì¬ URLì„ ë’¤ë¡œê°€ê¸° ìŠ¤íƒì— ì¶”ê°€
        if self.current_url:
            self.back_stack.append(self.current_url)
        
        self.current_url = url
        self._add_to_history(url, title)
        
        print(f"ë°©ë¬¸: {title} ({url})")
    
    def back(self, steps=1):
        """ë’¤ë¡œê°€ê¸°"""
        if not self.back_stack:
            return self.current_url
        
        for _ in range(min(steps, len(self.back_stack))):
            self.forward_stack.append(self.current_url)
            self.current_url = self.back_stack.pop()
        
        print(f"ë’¤ë¡œê°€ê¸°: {self.current_url}")
        return self.current_url
    
    def forward(self, steps=1):
        """ì•ìœ¼ë¡œê°€ê¸°"""
        if not self.forward_stack:
            return self.current_url
        
        for _ in range(min(steps, len(self.forward_stack))):
            self.back_stack.append(self.current_url)
            self.current_url = self.forward_stack.pop()
        
        print(f"ì•ìœ¼ë¡œê°€ê¸°: {self.current_url}")
        return self.current_url
    
    def add_bookmark(self, url=None):
        """ì¦ê²¨ì°¾ê¸° ì¶”ê°€"""
        bookmark_url = url or self.current_url
        self.bookmarks.add(bookmark_url)
        print(f"ì¦ê²¨ì°¾ê¸° ì¶”ê°€: {bookmark_url}")
    
    def get_recent_visits(self, count=5):
        """ìµœê·¼ ë°©ë¬¸ ê¸°ë¡ ë°˜í™˜"""
        return self.visit_history[-count:]
    
    def get_session_stats(self):
        """ì„¸ì…˜ í†µê³„ ë°˜í™˜"""
        total_time = time.time() - self.session_start
        unique_pages = len(set(visit['url'] for visit in self.visit_history))
        
        return {
            'total_visits': len(self.visit_history),
            'unique_pages': unique_pages,
            'session_duration': f"{total_time:.1f}ì´ˆ",
            'bookmarks_count': len(self.bookmarks)
        }

# í…ŒìŠ¤íŠ¸
print("\n=== ê³ ê¸‰ ë¸Œë¼ìš°ì € íˆìŠ¤í† ë¦¬ í…ŒìŠ¤íŠ¸ ===")
advanced_browser = AdvancedBrowserHistory("https://www.google.com")

advanced_browser.visit("https://www.github.com", "GitHub")
advanced_browser.visit("https://www.stackoverflow.com", "Stack Overflow")
advanced_browser.add_bookmark("https://www.github.com")

advanced_browser.back(1)
advanced_browser.visit("https://www.python.org", "Python.org")

print(f"\nìµœê·¼ ë°©ë¬¸ ê¸°ë¡:")
for visit in advanced_browser.get_recent_visits(3):
    print(f"  {visit['timestamp']}: {visit['title']}")

print(f"\nì„¸ì…˜ í†µê³„: {advanced_browser.get_session_stats()}")
```

## 2. ì‹¤í–‰ ì·¨ì†Œ/ë‹¤ì‹œ ì‹¤í–‰ ì‹œìŠ¤í…œ

í…ìŠ¤íŠ¸ í¸ì§‘ê¸°, ê·¸ë˜í”½ í¸ì§‘ê¸° ë“±ì—ì„œ ì‚¬ìš©ë˜ëŠ” ì‹¤í–‰ ì·¨ì†Œ/ë‹¤ì‹œ ì‹¤í–‰ ê¸°ëŠ¥ì„ ìŠ¤íƒìœ¼ë¡œ êµ¬í˜„í•©ë‹ˆë‹¤.

### 2-1 ê¸°ë³¸ ì‹¤í–‰ ì·¨ì†Œ/ë‹¤ì‹œ ì‹¤í–‰ ì‹œìŠ¤í…œ

```python
class Command:
    """ì‹¤í–‰ ì·¨ì†Œ ê°€ëŠ¥í•œ ëª…ë ¹ì˜ ê¸°ë³¸ í´ë˜ìŠ¤"""
    def __init__(self):
        self.executed = False
    
    def execute(self):
        """ëª…ë ¹ ì‹¤í–‰"""
        raise NotImplementedError
    
    def undo(self):
        """ëª…ë ¹ ì·¨ì†Œ"""
        raise NotImplementedError

class TextInsertCommand(Command):
    """í…ìŠ¤íŠ¸ ì‚½ì… ëª…ë ¹"""
    def __init__(self, text, position):
        super().__init__()
        self.text = text
        self.position = position
        self.original_content = None
    
    def execute(self, document):
        """í…ìŠ¤íŠ¸ ì‚½ì… ì‹¤í–‰"""
        if not self.executed:
            self.original_content = document.content
            document.insert_text(self.position, self.text)
            self.executed = True
    
    def undo(self, document):
        """í…ìŠ¤íŠ¸ ì‚½ì… ì·¨ì†Œ"""
        if self.executed and self.original_content:
            document.content = self.original_content
            self.executed = False

class TextDeleteCommand(Command):
    """í…ìŠ¤íŠ¸ ì‚­ì œ ëª…ë ¹"""
    def __init__(self, position, length):
        super().__init__()
        self.position = position
        self.length = length
        self.deleted_text = None
        self.original_content = None
    
    def execute(self, document):
        """í…ìŠ¤íŠ¸ ì‚­ì œ ì‹¤í–‰"""
        if not self.executed:
            self.original_content = document.content
            self.deleted_text = document.content[self.position:self.position + self.length]
            document.delete_text(self.position, self.length)
            self.executed = True
    
    def undo(self, document):
        """í…ìŠ¤íŠ¸ ì‚­ì œ ì·¨ì†Œ"""
        if self.executed and self.original_content:
            document.content = self.original_content
            self.executed = False

class Document:
    """ë¬¸ì„œ í´ë˜ìŠ¤"""
    def __init__(self):
        self.content = ""
    
    def insert_text(self, position, text):
        """í…ìŠ¤íŠ¸ ì‚½ì…"""
        self.content = self.content[:position] + text + self.content[position:]
    
    def delete_text(self, position, length):
        """í…ìŠ¤íŠ¸ ì‚­ì œ"""
        self.content = self.content[:position] + self.content[position + length:]
    
    def get_content(self):
        """ë¬¸ì„œ ë‚´ìš© ë°˜í™˜"""
        return self.content

class UndoRedoManager:
    """
    ì‹¤í–‰ ì·¨ì†Œ/ë‹¤ì‹œ ì‹¤í–‰ ê´€ë¦¬ì
    ìŠ¤íƒì„ ì´ìš©í•˜ì—¬ ëª…ë ¹ íˆìŠ¤í† ë¦¬ ê´€ë¦¬
    """
    def __init__(self, document):
        self.document = document
        self.undo_stack = []  # ì‹¤í–‰ ì·¨ì†Œ ìŠ¤íƒ
        self.redo_stack = []  # ë‹¤ì‹œ ì‹¤í–‰ ìŠ¤íƒ
        self.max_history = 50  # ìµœëŒ€ íˆìŠ¤í† ë¦¬ ìˆ˜
    
    def execute_command(self, command):
        """ëª…ë ¹ ì‹¤í–‰"""
        # ëª…ë ¹ ì‹¤í–‰
        command.execute(self.document)
        
        # ì‹¤í–‰ ì·¨ì†Œ ìŠ¤íƒì— ì¶”ê°€
        self.undo_stack.append(command)
        
        # ë‹¤ì‹œ ì‹¤í–‰ ìŠ¤íƒ ì´ˆê¸°í™” (ìƒˆë¡œìš´ ëª…ë ¹ì´ ì‹¤í–‰ë˜ì—ˆìœ¼ë¯€ë¡œ)
        self.redo_stack = []
        
        # íˆìŠ¤í† ë¦¬ í¬ê¸° ì œí•œ
        if len(self.undo_stack) > self.max_history:
            self.undo_stack.pop(0)
        
        print(f"ëª…ë ¹ ì‹¤í–‰: {type(command).__name__}")
        print(f"ë¬¸ì„œ ë‚´ìš©: '{self.document.get_content()}'")
    
    def undo(self):
        """ì‹¤í–‰ ì·¨ì†Œ"""
        if not self.undo_stack:
            print("ì‹¤í–‰ ì·¨ì†Œí•  ëª…ë ¹ì´ ì—†ìŠµë‹ˆë‹¤.")
            return
        
        # ê°€ì¥ ìµœê·¼ ëª…ë ¹ì„ ì‹¤í–‰ ì·¨ì†Œ ìŠ¤íƒì—ì„œ ì œê±°
        command = self.undo_stack.pop()
        command.undo(self.document)
        
        # ë‹¤ì‹œ ì‹¤í–‰ ìŠ¤íƒì— ì¶”ê°€
        self.redo_stack.append(command)
        
        print(f"ì‹¤í–‰ ì·¨ì†Œ: {type(command).__name__}")
        print(f"ë¬¸ì„œ ë‚´ìš©: '{self.document.get_content()}'")
    
    def redo(self):
        """ë‹¤ì‹œ ì‹¤í–‰"""
        if not self.redo_stack:
            print("ë‹¤ì‹œ ì‹¤í–‰í•  ëª…ë ¹ì´ ì—†ìŠµë‹ˆë‹¤.")
            return
        
        # ë‹¤ì‹œ ì‹¤í–‰ ìŠ¤íƒì—ì„œ ëª…ë ¹ì„ ê°€ì ¸ì™€ì„œ ì‹¤í–‰
        command = self.redo_stack.pop()
        command.execute(self.document)
        
        # ì‹¤í–‰ ì·¨ì†Œ ìŠ¤íƒì— ë‹¤ì‹œ ì¶”ê°€
        self.undo_stack.append(command)
        
        print(f"ë‹¤ì‹œ ì‹¤í–‰: {type(command).__name__}")
        print(f"ë¬¸ì„œ ë‚´ìš©: '{self.document.get_content()}'")
    
    def can_undo(self):
        """ì‹¤í–‰ ì·¨ì†Œ ê°€ëŠ¥ ì—¬ë¶€"""
        return len(self.undo_stack) > 0
    
    def can_redo(self):
        """ë‹¤ì‹œ ì‹¤í–‰ ê°€ëŠ¥ ì—¬ë¶€"""
        return len(self.redo_stack) > 0
    
    def get_history_info(self):
        """íˆìŠ¤í† ë¦¬ ì •ë³´ ë°˜í™˜"""
        return {
            'undo_stack_size': len(self.undo_stack),
            'redo_stack_size': len(self.redo_stack),
            'can_undo': self.can_undo(),
            'can_redo': self.can_redo()
        }

# í…ŒìŠ¤íŠ¸
print("=== ì‹¤í–‰ ì·¨ì†Œ/ë‹¤ì‹œ ì‹¤í–‰ ì‹œìŠ¤í…œ í…ŒìŠ¤íŠ¸ ===")
document = Document()
undo_redo_manager = UndoRedoManager(document)

# í…ìŠ¤íŠ¸ ì‚½ì…
insert_cmd1 = TextInsertCommand("Hello", 0)
undo_redo_manager.execute_command(insert_cmd1)

insert_cmd2 = TextInsertCommand(" World", 5)
undo_redo_manager.execute_command(insert_cmd2)

# í…ìŠ¤íŠ¸ ì‚­ì œ
delete_cmd1 = TextDeleteCommand(0, 6)  # "Hello " ì‚­ì œ
undo_redo_manager.execute_command(delete_cmd1)

print(f"\ní˜„ì¬ ë¬¸ì„œ: '{document.get_content()}'")
print(f"íˆìŠ¤í† ë¦¬ ì •ë³´: {undo_redo_manager.get_history_info()}")

# ì‹¤í–‰ ì·¨ì†Œ
undo_redo_manager.undo()
undo_redo_manager.undo()

print(f"\n2ë²ˆ ì‹¤í–‰ ì·¨ì†Œ í›„: '{document.get_content()}'")

# ë‹¤ì‹œ ì‹¤í–‰
undo_redo_manager.redo()
print(f"1ë²ˆ ë‹¤ì‹œ ì‹¤í–‰ í›„: '{document.get_content()}'")
```

### 2-2 ê³ ê¸‰ ì‹¤í–‰ ì·¨ì†Œ ì‹œìŠ¤í…œ (ë§ˆì´í¬ë¡œ ëª…ë ¹ ì§€ì›)

```python
class MicroCommand(Command):
    """ë§ˆì´í¬ë¡œ ëª…ë ¹ (í‚¤ ì…ë ¥ ë‹¨ìœ„)"""
    def __init__(self, char, position):
        super().__init__()
        self.char = char
        self.position = position
        self.original_content = None
    
    def execute(self, document):
        if not self.executed:
            self.original_content = document.content
            document.insert_text(self.position, self.char)
            self.executed = True
    
    def undo(self, document):
        if self.executed and self.original_content:
            document.content = self.original_content
            self.executed = False

class MacroCommand(Command):
    """ë§¤í¬ë¡œ ëª…ë ¹ (ì—¬ëŸ¬ ëª…ë ¹ì˜ ì¡°í•©)"""
    def __init__(self, commands):
        super().__init__()
        self.commands = commands
        self.original_content = None
    
    def execute(self, document):
        if not self.executed:
            self.original_content = document.content
            for cmd in self.commands:
                cmd.execute(document)
            self.executed = True
    
    def undo(self, document):
        if self.executed and self.original_content:
            document.content = self.original_content
            self.executed = False

class AdvancedUndoRedoManager(UndoRedoManager):
    """ê³ ê¸‰ ì‹¤í–‰ ì·¨ì†Œ/ë‹¤ì‹œ ì‹¤í–‰ ê´€ë¦¬ì"""
    
    def __init__(self, document):
        super().__init__(document)
        self.macro_mode = False
        self.current_macro = []
    
    def start_macro(self):
        """ë§¤í¬ë¡œ ëª¨ë“œ ì‹œì‘"""
        self.macro_mode = True
        self.current_macro = []
        print("ë§¤í¬ë¡œ ëª¨ë“œ ì‹œì‘")
    
    def end_macro(self):
        """ë§¤í¬ë¡œ ëª¨ë“œ ì¢…ë£Œ"""
        if self.macro_mode and self.current_macro:
            macro_command = MacroCommand(self.current_macro.copy())
            self.execute_command(macro_command)
        
        self.macro_mode = False
        self.current_macro = []
        print("ë§¤í¬ë¡œ ëª¨ë“œ ì¢…ë£Œ")
    
    def execute_command(self, command):
        """ëª…ë ¹ ì‹¤í–‰ (ë§¤í¬ë¡œ ëª¨ë“œ ì§€ì›)"""
        if self.macro_mode:
            self.current_macro.append(command)
        else:
            super().execute_command(command)

# í…ŒìŠ¤íŠ¸
print("\n=== ê³ ê¸‰ ì‹¤í–‰ ì·¨ì†Œ ì‹œìŠ¤í…œ í…ŒìŠ¤íŠ¸ ===")
advanced_doc = Document()
advanced_manager = AdvancedUndoRedoManager(advanced_doc)

# ë§¤í¬ë¡œ ëª¨ë“œë¡œ ì—¬ëŸ¬ ëª…ë ¹ ì‹¤í–‰
advanced_manager.start_macro()

cmd1 = MicroCommand("H", 0)
cmd2 = MicroCommand("e", 1)
cmd3 = MicroCommand("l", 2)
cmd4 = MicroCommand("l", 3)
cmd5 = MicroCommand("o", 4)

for cmd in [cmd1, cmd2, cmd3, cmd4, cmd5]:
    advanced_manager.execute_command(cmd)

advanced_manager.end_macro()

print(f"ë§¤í¬ë¡œ ì‹¤í–‰ í›„: '{advanced_doc.get_content()}'")
print(f"íˆìŠ¤í† ë¦¬: {advanced_manager.get_history_info()}")

# ë§¤í¬ë¡œ ì „ì²´ ì‹¤í–‰ ì·¨ì†Œ
advanced_manager.undo()
print(f"ë§¤í¬ë¡œ ì‹¤í–‰ ì·¨ì†Œ í›„: '{advanced_doc.get_content()}'")
```

## 3. ì›¹ ì„œë²„ ë¯¸ë“¤ì›¨ì–´ ìŠ¤íƒ

ì›¹ í”„ë ˆì„ì›Œí¬ì—ì„œ ë¯¸ë“¤ì›¨ì–´ëŠ” ìš”ì²­ê³¼ ì‘ë‹µì„ ì²˜ë¦¬í•˜ëŠ” ì¤‘ê°„ ë‹¨ê³„ë¡œ, ìŠ¤íƒ êµ¬ì¡°ë¡œ ê´€ë¦¬ë©ë‹ˆë‹¤.

### 3-1 ê¸°ë³¸ ë¯¸ë“¤ì›¨ì–´ ìŠ¤íƒ êµ¬í˜„

```python
from functools import wraps
import time
import json

class Middleware:
    """ë¯¸ë“¤ì›¨ì–´ ê¸°ë³¸ í´ë˜ìŠ¤"""
    def __init__(self):
        self.next_middleware = None
    
    def set_next(self, middleware):
        """ë‹¤ìŒ ë¯¸ë“¤ì›¨ì–´ ì„¤ì •"""
        self.next_middleware = middleware
        return middleware
    
    def process_request(self, request):
        """ìš”ì²­ ì²˜ë¦¬"""
        pass
    
    def process_response(self, response):
        """ì‘ë‹µ ì²˜ë¦¬"""
        pass
    
    def handle(self, request):
        """ë¯¸ë“¤ì›¨ì–´ ì²´ì¸ ì‹¤í–‰"""
        # ìš”ì²­ ì²˜ë¦¬
        self.process_request(request)
        
        # ë‹¤ìŒ ë¯¸ë“¤ì›¨ì–´ ì‹¤í–‰
        if self.next_middleware:
            response = self.next_middleware.handle(request)
        else:
            # ë§ˆì§€ë§‰ ë¯¸ë“¤ì›¨ì–´ì¸ ê²½ìš° ê¸°ë³¸ ì‘ë‹µ ìƒì„±
            response = {
                'status': 200,
                'headers': {},
                'body': 'OK'
            }
        
        # ì‘ë‹µ ì²˜ë¦¬
        self.process_response(response)
        return response

class LoggingMiddleware(Middleware):
    """ë¡œê¹… ë¯¸ë“¤ì›¨ì–´"""
    def __init__(self):
        super().__init__()
        self.logs = []
    
    def process_request(self, request):
        request['start_time'] = time.time()
        log_entry = f"[{time.strftime('%H:%M:%S')}] {request['method']} {request['path']}"
        self.logs.append(log_entry)
        print(f"ìš”ì²­ ë¡œê·¸: {log_entry}")
    
    def process_response(self, response):
        if 'start_time' in response.get('request', {}):
            duration = time.time() - response['request']['start_time']
            log_entry = f"ì‘ë‹µ ì‹œê°„: {duration:.3f}ì´ˆ"
            self.logs.append(log_entry)
            print(log_entry)

class AuthenticationMiddleware(Middleware):
    """ì¸ì¦ ë¯¸ë“¤ì›¨ì–´"""
    def __init__(self):
        super().__init__()
        self.valid_tokens = {'user123', 'admin456', 'guest789'}
    
    def process_request(self, request):
        token = request.get('headers', {}).get('Authorization', '')
        
        if not token:
            raise Exception("ì¸ì¦ í† í°ì´ í•„ìš”í•©ë‹ˆë‹¤")
        
        if token not in self.valid_tokens:
            raise Exception("ìœ íš¨í•˜ì§€ ì•Šì€ ì¸ì¦ í† í°")
        
        print(f"ì¸ì¦ ì„±ê³µ: {token}")

class CORSMiddleware(Middleware):
    """CORS ë¯¸ë“¤ì›¨ì–´"""
    def __init__(self):
        super().__init__()
        self.allowed_origins = ['http://localhost:3000', 'https://example.com']
    
    def process_request(self, request):
        origin = request.get('headers', {}).get('Origin', '')
        if origin and origin not in self.allowed_origins:
            raise Exception(f"í—ˆìš©ë˜ì§€ ì•Šì€ Origin: {origin}")
    
    def process_response(self, response):
        response['headers']['Access-Control-Allow-Origin'] = '*'
        response['headers']['Access-Control-Allow-Methods'] = 'GET, POST, PUT, DELETE'
        response['headers']['Access-Control-Allow-Headers'] = 'Content-Type, Authorization'

class RateLimitMiddleware(Middleware):
    """ì†ë„ ì œí•œ ë¯¸ë“¤ì›¨ì–´"""
    def __init__(self, max_requests=10, time_window=60):
        super().__init__()
        self.max_requests = max_requests
        self.time_window = time_window
        self.requests = {}  # IPë³„ ìš”ì²­ ê¸°ë¡
    
    def process_request(self, request):
        client_ip = request.get('client_ip', 'unknown')
        current_time = time.time()
        
        # ì˜¤ë˜ëœ ìš”ì²­ ê¸°ë¡ ì •ë¦¬
        if client_ip in self.requests:
            self.requests[client_ip] = [
                req_time for req_time in self.requests[client_ip]
                if current_time - req_time < self.time_window
            ]
        else:
            self.requests[client_ip] = []
        
        # ìš”ì²­ ìˆ˜ í™•ì¸
        if len(self.requests[client_ip]) >= self.max_requests:
            raise Exception(f"ì†ë„ ì œí•œ ì´ˆê³¼: {client_ip}")
        
        # í˜„ì¬ ìš”ì²­ ê¸°ë¡
        self.requests[client_ip].append(current_time)
        print(f"ì†ë„ ì œí•œ í™•ì¸: {client_ip} ({len(self.requests[client_ip])}/{self.max_requests})")

class WebServer:
    """ì›¹ ì„œë²„ í´ë˜ìŠ¤"""
    def __init__(self):
        self.middleware_stack = None
    
    def add_middleware(self, middleware):
        """ë¯¸ë“¤ì›¨ì–´ ì¶”ê°€"""
        if self.middleware_stack is None:
            self.middleware_stack = middleware
        else:
            self.middleware_stack.set_next(middleware)
    
    def handle_request(self, request):
        """ìš”ì²­ ì²˜ë¦¬"""
        try:
            if self.middleware_stack:
                response = self.middleware_stack.handle(request)
            else:
                response = {'status': 200, 'headers': {}, 'body': 'OK'}
            
            print(f"ì‘ë‹µ: {response['status']}")
            return response
        
        except Exception as e:
            error_response = {
                'status': 400,
                'headers': {'Content-Type': 'application/json'},
                'body': json.dumps({'error': str(e)})
            }
            print(f"ì˜¤ë¥˜ ì‘ë‹µ: {error_response}")
            return error_response

# í…ŒìŠ¤íŠ¸
print("=== ì›¹ ì„œë²„ ë¯¸ë“¤ì›¨ì–´ ìŠ¤íƒ í…ŒìŠ¤íŠ¸ ===")
server = WebServer()

# ë¯¸ë“¤ì›¨ì–´ ìŠ¤íƒ êµ¬ì„± (ìˆœì„œ ì¤‘ìš”)
server.add_middleware(LoggingMiddleware())
server.add_middleware(CORSMiddleware())
server.add_middleware(RateLimitMiddleware(max_requests=5, time_window=10))
server.add_middleware(AuthenticationMiddleware())

# í…ŒìŠ¤íŠ¸ ìš”ì²­
test_requests = [
    {
        'method': 'GET',
        'path': '/api/users',
        'headers': {'Authorization': 'user123', 'Origin': 'http://localhost:3000'},
        'client_ip': '192.168.1.1'
    },
    {
        'method': 'POST',
        'path': '/api/posts',
        'headers': {'Authorization': 'admin456', 'Origin': 'http://localhost:3000'},
        'client_ip': '192.168.1.1'
    }
]

for request in test_requests:
    print(f"\n--- ìš”ì²­ ì²˜ë¦¬: {request['method']} {request['path']} ---")
    response = server.handle_request(request)
    print(f"ìµœì¢… ì‘ë‹µ: {response['status']} - {response['body']}")
```

### 3-2 Express.js ìŠ¤íƒ€ì¼ ë¯¸ë“¤ì›¨ì–´ ì‹œìŠ¤í…œ

```python
class ExpressStyleMiddleware:
    """Express.js ìŠ¤íƒ€ì¼ ë¯¸ë“¤ì›¨ì–´ ì‹œìŠ¤í…œ"""
    
    def __init__(self):
        self.middlewares = []
        self.error_handlers = []
    
    def use(self, middleware):
        """ë¯¸ë“¤ì›¨ì–´ ë“±ë¡"""
        self.middlewares.append(middleware)
        return self
    
    def use_error_handler(self, error_handler):
        """ì—ëŸ¬ í•¸ë“¤ëŸ¬ ë“±ë¡"""
        self.error_handlers.append(error_handler)
        return self
    
    def _execute_middleware(self, middleware, request, response, next):
        """ë¯¸ë“¤ì›¨ì–´ ì‹¤í–‰"""
        try:
            if isinstance(middleware, dict) and 'path' in middleware:
                # ê²½ë¡œë³„ ë¯¸ë“¤ì›¨ì–´
                if request['path'].startswith(middleware['path']):
                    middleware['handler'](request, response, next)
                else:
                    next()
            else:
                # ì¼ë°˜ ë¯¸ë“¤ì›¨ì–´
                middleware(request, response, next)
        except Exception as e:
            next(e)
    
    def handle_request(self, request):
        """ìš”ì²­ ì²˜ë¦¬"""
        response = {
            'status': 200,
            'headers': {},
            'body': '',
            'locals': {}
        }
        
        middleware_index = 0
        
        def next(error=None):
            nonlocal middleware_index
            
            if error:
                # ì—ëŸ¬ ì²˜ë¦¬
                if middleware_index < len(self.error_handlers):
                    error_handler = self.error_handlers[middleware_index - len(self.middlewares)]
                    error_handler(error, request, response, next)
                else:
                    response['status'] = 500
                    response['body'] = f'Internal Server Error: {error}'
                return
            
            if middleware_index < len(self.middlewares):
                middleware = self.middlewares[middleware_index]
                middleware_index += 1
                self._execute_middleware(middleware, request, response, next)
            else:
                # ëª¨ë“  ë¯¸ë“¤ì›¨ì–´ ì²˜ë¦¬ ì™„ë£Œ
                if response['body'] == '':
                    response['body'] = 'OK'
        
        next()
        return response

# Express.js ìŠ¤íƒ€ì¼ í…ŒìŠ¤íŠ¸
print("\n=== Express.js ìŠ¤íƒ€ì¼ ë¯¸ë“¤ì›¨ì–´ í…ŒìŠ¤íŠ¸ ===")

def logger_middleware(req, res, next):
    print(f"Logger: {req['method']} {req['path']}")
    next()

def auth_middleware(req, res, next):
    if req.get('headers', {}).get('Authorization'):
        print("ì¸ì¦ í™•ì¸ë¨")
        next()
    else:
        next("ì¸ì¦ í•„ìš”")

def api_middleware(req, res, next):
    if req['path'].startswith('/api'):
        res['body'] = f"API Response for {req['path']}"
        print(f"API ì²˜ë¦¬: {req['path']}")
    next()

def error_handler(error, req, res, next):
    print(f"ì—ëŸ¬ ì²˜ë¦¬: {error}")
    res['status'] = 401
    res['body'] = f"Error: {error}"

# Express ìŠ¤íƒ€ì¼ ì„œë²„ êµ¬ì„±
express_server = ExpressStyleMiddleware()
express_server.use(logger_middleware)
express_server.use(auth_middleware)
express_server.use(api_middleware)
express_server.use_error_handler(error_handler)

# í…ŒìŠ¤íŠ¸ ìš”ì²­
test_request = {
    'method': 'GET',
    'path': '/api/users',
    'headers': {'Authorization': 'Bearer token123'}
}

response = express_server.handle_request(test_request)
print(f"Express ìŠ¤íƒ€ì¼ ì‘ë‹µ: {response}")
```

## 4. ê³„ì‚°ê¸° ì• í”Œë¦¬ì¼€ì´ì…˜

ìŠ¤íƒì„ ì´ìš©í•œ ìˆ˜ì‹ ê³„ì‚°ê¸° êµ¬í˜„ì…ë‹ˆë‹¤.

### 4-1 ê¸°ë³¸ ê³„ì‚°ê¸° (í›„ìœ„ í‘œê¸°ë²•)

```python
class Calculator:
    """ìŠ¤íƒ ê¸°ë°˜ ê³„ì‚°ê¸°"""
    
    def __init__(self):
        self.operators = {
            '+': lambda x, y: x + y,
            '-': lambda x, y: x - y,
            '*': lambda x, y: x * y,
            '/': lambda x, y: x / y if y != 0 else float('inf'),
            '^': lambda x, y: x ** y
        }
    
    def infix_to_postfix(self, expression):
        """ì¤‘ìœ„ í‘œê¸°ë²•ì„ í›„ìœ„ í‘œê¸°ë²•ìœ¼ë¡œ ë³€í™˜"""
        precedence = {'^': 4, '*': 3, '/': 3, '+': 2, '-': 2}
        stack = []
        output = []
        
        i = 0
        while i < len(expression):
            char = expression[i]
            
            if char.isdigit() or char == '.':
                # ìˆ«ì íŒŒì‹±
                num = ""
                while i < len(expression) and (expression[i].isdigit() or expression[i] == '.'):
                    num += expression[i]
                    i += 1
                output.append(num)
                continue
            
            elif char == '(':
                stack.append(char)
            
            elif char == ')':
                while stack and stack[-1] != '(':
                    output.append(stack.pop())
                stack.pop()
            
            elif char in precedence:
                while (stack and stack[-1] != '(' and 
                       precedence[stack[-1]] >= precedence[char]):
                    output.append(stack.pop())
                stack.append(char)
            
            i += 1
        
        while stack:
            output.append(stack.pop())
        
        return output
    
    def evaluate_postfix(self, postfix):
        """í›„ìœ„ í‘œê¸°ë²• ê³„ì‚°"""
        stack = []
        
        for token in postfix:
            if token in self.operators:
                if len(stack) < 2:
                    raise ValueError("í”¼ì—°ì‚°ì ë¶€ì¡±")
                
                b = float(stack.pop())
                a = float(stack.pop())
                result = self.operators[token](a, b)
                stack.append(result)
            else:
                stack.append(float(token))
        
        if len(stack) != 1:
            raise ValueError("ì˜ëª»ëœ ìˆ˜ì‹")
        
        return stack[0]
    
    def calculate(self, expression):
        """ìˆ˜ì‹ ê³„ì‚° (ì¤‘ìœ„ í‘œê¸°ë²• ì…ë ¥)"""
        try:
            # ê³µë°± ì œê±°
            expression = expression.replace(" ", "")
            
            # ê´„í˜¸ ê²€ì‚¬
            if not self._is_valid_expression(expression):
                raise ValueError("ì˜ëª»ëœ ìˆ˜ì‹")
            
            # í›„ìœ„ í‘œê¸°ë²•ìœ¼ë¡œ ë³€í™˜
            postfix = self.infix_to_postfix(expression)
            print(f"í›„ìœ„ í‘œê¸°ë²•: {' '.join(postfix)}")
            
            # ê³„ì‚°
            result = self.evaluate_postfix(postfix)
            return result
        
        except Exception as e:
            raise ValueError(f"ê³„ì‚° ì˜¤ë¥˜: {e}")
    
    def _is_valid_expression(self, expression):
        """ìˆ˜ì‹ ìœ íš¨ì„± ê²€ì‚¬"""
        stack = []
        for char in expression:
            if char == '(':
                stack.append(char)
            elif char == ')':
                if not stack:
                    return False
                stack.pop()
        return len(stack) == 0

# í…ŒìŠ¤íŠ¸
print("=== ê³„ì‚°ê¸° ì• í”Œë¦¬ì¼€ì´ì…˜ í…ŒìŠ¤íŠ¸ ===")
calc = Calculator()

test_expressions = [
    "3 + 4 * 2",
    "(3 + 4) * 2",
    "2 ^ 3",
    "10 / (2 + 3)",
    "3 * (4 + 2) - 1"
]

for expr in test_expressions:
    try:
        result = calc.calculate(expr)
        print(f"{expr} = {result}")
    except Exception as e:
        print(f"{expr} -> ì˜¤ë¥˜: {e}")
```

### 4-2 ê³ ê¸‰ ê³„ì‚°ê¸° (ê¸°ëŠ¥ í™•ì¥)

```python
import math

class AdvancedCalculator(Calculator):
    """ê³ ê¸‰ ê³„ì‚°ê¸° (ì‚¼ê°í•¨ìˆ˜, ë¡œê·¸, ìƒìˆ˜ ì§€ì›)"""
    
    def __init__(self):
        super().__init__()
        
        # ì¶”ê°€ ì—°ì‚°ì
        self.operators.update({
            'sin': lambda x: math.sin(math.radians(x)),
            'cos': lambda x: math.cos(math.radians(x)),
            'tan': lambda x: math.tan(math.radians(x)),
            'log': lambda x: math.log10(x),
            'ln': lambda x: math.log(x),
            'sqrt': lambda x: math.sqrt(x),
            'abs': lambda x: abs(x)
        })
        
        # ìƒìˆ˜
        self.constants = {
            'pi': math.pi,
            'e': math.e
        }
    
    def tokenize(self, expression):
        """ìˆ˜ì‹ì„ í† í°ìœ¼ë¡œ ë¶„ë¦¬"""
        tokens = []
        i = 0
        
        while i < len(expression):
            char = expression[i]
            
            if char.isdigit() or char == '.':
                # ìˆ«ì íŒŒì‹±
                num = ""
                while i < len(expression) and (expression[i].isdigit() or expression[i] == '.'):
                    num += expression[i]
                    i += 1
                tokens.append(('number', num))
                continue
            
            elif char.isalpha():
                # í•¨ìˆ˜ëª…ì´ë‚˜ ìƒìˆ˜ íŒŒì‹±
                word = ""
                while i < len(expression) and expression[i].isalpha():
                    word += expression[i]
                    i += 1
                
                if word in self.constants:
                    tokens.append(('constant', word))
                elif word in self.operators:
                    tokens.append(('function', word))
                else:
                    raise ValueError(f"ì•Œ ìˆ˜ ì—†ëŠ” ì‹ë³„ì: {word}")
                continue
            
            elif char in '+-*/^()':
                tokens.append(('operator', char))
            
            elif char == ' ':
                pass  # ê³µë°± ë¬´ì‹œ
            
            else:
                raise ValueError(f"ì•Œ ìˆ˜ ì—†ëŠ” ë¬¸ì: {char}")
            
            i += 1
        
        return tokens
    
    def advanced_infix_to_postfix(self, expression):
        """ê³ ê¸‰ ì¤‘ìœ„ í‘œê¸°ë²•ì„ í›„ìœ„ í‘œê¸°ë²•ìœ¼ë¡œ ë³€í™˜"""
        tokens = self.tokenize(expression)
        precedence = {'^': 4, '*': 3, '/': 3, '+': 2, '-': 2}
        stack = []
        output = []
        
        for token_type, token_value in tokens:
            if token_type == 'number':
                output.append(token_value)
            
            elif token_type == 'constant':
                output.append(str(self.constants[token_value]))
            
            elif token_type == 'function':
                stack.append(token_value)
            
            elif token_value == '(':
                stack.append(token_value)
            
            elif token_value == ')':
                while stack and stack[-1] != '(':
                    output.append(stack.pop())
                stack.pop()  # '(' ì œê±°
                
                # í•¨ìˆ˜ê°€ ìˆìœ¼ë©´ ì¶”ê°€
                if stack and stack[-1] in self.operators:
                    output.append(stack.pop())
            
            elif token_value in precedence:
                while (stack and stack[-1] != '(' and 
                       stack[-1] in precedence and
                       precedence[stack[-1]] >= precedence[token_value]):
                    output.append(stack.pop())
                stack.append(token_value)
        
        while stack:
            output.append(stack.pop())
        
        return output
    
    def advanced_evaluate_postfix(self, postfix):
        """ê³ ê¸‰ í›„ìœ„ í‘œê¸°ë²• ê³„ì‚°"""
        stack = []
        
        for token in postfix:
            if token in self.operators:
                if token in ['sin', 'cos', 'tan', 'log', 'ln', 'sqrt', 'abs']:
                    # ë‹¨í•­ ì—°ì‚°ì
                    if not stack:
                        raise ValueError("í”¼ì—°ì‚°ì ë¶€ì¡±")
                    a = float(stack.pop())
                    result = self.operators[token](a)
                    stack.append(result)
                else:
                    # ì´í•­ ì—°ì‚°ì
                    if len(stack) < 2:
                        raise ValueError("í”¼ì—°ì‚°ì ë¶€ì¡±")
                    b = float(stack.pop())
                    a = float(stack.pop())
                    result = self.operators[token](a, b)
                    stack.append(result)
            else:
                stack.append(float(token))
        
        if len(stack) != 1:
            raise ValueError("ì˜ëª»ëœ ìˆ˜ì‹")
        
        return stack[0]
    
    def advanced_calculate(self, expression):
        """ê³ ê¸‰ ìˆ˜ì‹ ê³„ì‚°"""
        try:
            expression = expression.replace(" ", "")
            
            if not self._is_valid_expression(expression):
                raise ValueError("ì˜ëª»ëœ ìˆ˜ì‹")
            
            postfix = self.advanced_infix_to_postfix(expression)
            print(f"í›„ìœ„ í‘œê¸°ë²•: {' '.join(postfix)}")
            
            result = self.advanced_evaluate_postfix(postfix)
            return result
        
        except Exception as e:
            raise ValueError(f"ê³„ì‚° ì˜¤ë¥˜: {e}")

# í…ŒìŠ¤íŠ¸
print("\n=== ê³ ê¸‰ ê³„ì‚°ê¸° í…ŒìŠ¤íŠ¸ ===")
advanced_calc = AdvancedCalculator()

advanced_expressions = [
    "sin(30) + cos(60)",
    "sqrt(16) + log(100)",
    "pi * 2",
    "abs(-5) + ln(e)",
    "sin(90) + cos(0)"
]

for expr in advanced_expressions:
    try:
        result = advanced_calc.advanced_calculate(expr)
        print(f"{expr} = {result:.6f}")
    except Exception as e:
        print(f"{expr} -> ì˜¤ë¥˜: {e}")
```

## ì •ë¦¬

ì´ë²ˆ í¬ìŠ¤íŠ¸ì—ì„œëŠ” ìŠ¤íƒì˜ ì‹¤ë¬´ í™œìš© ì‚¬ë¡€ë“¤ì„ ì‚´í´ë³´ì•˜ìŠµë‹ˆë‹¤.

**ì‹¤ë¬´ í™œìš© ì •ë¦¬**
1. **ë¸Œë¼ìš°ì € íˆìŠ¤í† ë¦¬**: ë’¤ë¡œê°€ê¸°/ì•ìœ¼ë¡œê°€ê¸° ê¸°ëŠ¥ì˜ ìŠ¤íƒ ê¸°ë°˜ êµ¬í˜„
2. **ì‹¤í–‰ ì·¨ì†Œ/ë‹¤ì‹œ ì‹¤í–‰**: í…ìŠ¤íŠ¸ í¸ì§‘ê¸°ì™€ ê·¸ë˜í”½ í¸ì§‘ê¸°ì˜ í•µì‹¬ ê¸°ëŠ¥
3. **ì›¹ ì„œë²„ ë¯¸ë“¤ì›¨ì–´**: Express.js, Flask ë“± ì›¹ í”„ë ˆì„ì›Œí¬ì˜ ìš”ì²­ ì²˜ë¦¬ íŒŒì´í”„ë¼ì¸
4. **ê³„ì‚°ê¸° ì• í”Œë¦¬ì¼€ì´ì…˜**: ìˆ˜ì‹ íŒŒì‹±ê³¼ ê³„ì‚°ì—ì„œ ìŠ¤íƒì˜ í™œìš©
5. **ë©”ëª¨ë¦¬ ê´€ë¦¬**: í”„ë¡œê·¸ë¨ ì‹¤í–‰ ì‹œ í˜¸ì¶œ ìŠ¤íƒê³¼ ë©”ëª¨ë¦¬ ìŠ¤íƒì˜ ì—­í• 

**ìŠ¤íƒ ì‹¤ë¬´ í™œìš©ì˜ í•µì‹¬ ì›ì¹™**
- **ìƒíƒœ ê´€ë¦¬**: ì´ì „ ìƒíƒœë¥¼ ê¸°ì–µí•˜ê³  ë³µì›í•˜ëŠ” ê¸°ëŠ¥
- **íŒŒì´í”„ë¼ì¸ ì²˜ë¦¬**: ìˆœì°¨ì ìœ¼ë¡œ ì²˜ë¦¬ë˜ì–´ì•¼ í•˜ëŠ” ì‘ì—…ë“¤ì˜ ì²´ì¸
- **ì—­ìˆœ ì²˜ë¦¬**: LIFO íŠ¹ì„±ì„ í™œìš©í•œ ì—­ë°©í–¥ ì²˜ë¦¬
- **ë©”ëª¨ë¦¬ íš¨ìœ¨ì„±**: ì œí•œëœ ë©”ëª¨ë¦¬ í™˜ê²½ì—ì„œì˜ íš¨ìœ¨ì ì¸ ë°ì´í„° ê´€ë¦¬
- **ì‚¬ìš©ì ê²½í—˜**: ì§ê´€ì ì´ê³  ì˜ˆì¸¡ ê°€ëŠ¥í•œ ë™ì‘ ì œê³µ

**ì‹¤ë¬´ì—ì„œì˜ ìŠ¤íƒ í™œìš© íŒ¨í„´**
- **íˆìŠ¤í† ë¦¬ ê´€ë¦¬**: ë¸Œë¼ìš°ì €, í¸ì§‘ê¸°, ê²Œì„ ë“±ì—ì„œì˜ ë˜ëŒë¦¬ê¸° ê¸°ëŠ¥
- **ì¤‘ê°„ ì²˜ë¦¬**: ì›¹ ì„œë²„ì˜ ë¯¸ë“¤ì›¨ì–´, ì»´íŒŒì¼ëŸ¬ì˜ íŒŒì‹± ê³¼ì •
- **ê³„ì‚° ì—”ì§„**: ìˆ˜ì‹ ê³„ì‚°ê¸°, ì¸í„°í”„ë¦¬í„°, ê°€ìƒ ë¨¸ì‹ 
- **ë©”ëª¨ë¦¬ ê´€ë¦¬**: í•¨ìˆ˜ í˜¸ì¶œ, ì§€ì—­ ë³€ìˆ˜, ì‹¤í–‰ ì»¨í…ìŠ¤íŠ¸

ìŠ¤íƒì€ ë‹¨ìˆœí•œ ìë£Œêµ¬ì¡°ì´ì§€ë§Œ, ì‹¤ì œ ì†Œí”„íŠ¸ì›¨ì–´ ê°œë°œì—ì„œ ë§¤ìš° ì¤‘ìš”í•œ ì—­í• ì„ í•©ë‹ˆë‹¤. ì´ëŸ¬í•œ ì‹¤ë¬´ í™œìš© ì‚¬ë¡€ë“¤ì„ ì´í•´í•˜ë©´ ë”ìš± íš¨ê³¼ì ì¸ ì‹œìŠ¤í…œ ì„¤ê³„ì™€ êµ¬í˜„ì´ ê°€ëŠ¥í•´ì§‘ë‹ˆë‹¤.

# ğŸ“š ë ˆí¼ëŸ°ìŠ¤
- [Express.js Middleware - Official Documentation](https://expressjs.com/en/guide/using-middleware.html)
- [Browser History API - MDN Web Docs](https://developer.mozilla.org/en-US/docs/Web/API/History_API)
- [Command Pattern - Wikipedia](https://en.wikipedia.org/wiki/Command_pattern)
- [Call Stack - MDN Web Docs](https://developer.mozilla.org/en-US/docs/Glossary/Call_stack)

---
*ì´ í¬ìŠ¤íŠ¸ëŠ” ìë£Œêµ¬ì¡° í•™ìŠµ ê³¼ì •ì„ ì •ë¦¬í•œ ë‚´ìš©ì…ë‹ˆë‹¤.*
