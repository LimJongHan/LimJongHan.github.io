---
layout: post
title: "[ìë£Œêµ¬ì¡°] í(Queue) - í™œìš© - 2"
date: 2025-10-05 21:00:00 +0900
categories: [ìë£Œêµ¬ì¡°, í]
tags: [ìë£Œêµ¬ì¡°, í, Queue, ìš°ì„ ìˆœìœ„í, í™, ì´ì¤‘í, ìŠ¤ë ˆë“œí’€, ê³ ê¸‰ì•Œê³ ë¦¬ì¦˜]
author: LimJongHan
toc: true
---

# ğŸ“– ê´€ë ¨ëœ ë‚´ í¬ìŠ¤íŒ…
- [[ìë£Œêµ¬ì¡°] ìë£Œêµ¬ì¡°ì™€ ì•Œê³ ë¦¬ì¦˜ ê°œìš”]({% post_url 2025-10-02-[ìë£Œêµ¬ì¡°] ìë£Œêµ¬ì¡°ì™€ ì•Œê³ ë¦¬ì¦˜ ê°œìš” %})
- [[ìë£Œêµ¬ì¡°] ë°°ì—´(Array) - ê¸°ë³¸ ì˜ˆì œ]({% post_url 2025-10-03-[ìë£Œêµ¬ì¡°] ë°°ì—´(Array) - ê¸°ë³¸ ì˜ˆì œ %})
- [[ìë£Œêµ¬ì¡°] ë°°ì—´(Array) - í™œìš© - 1]({% post_url 2025-10-03-[ìë£Œêµ¬ì¡°] ë°°ì—´(Array) - í™œìš© - 1 %})
- [[ìë£Œêµ¬ì¡°] ë°°ì—´(Array) - í™œìš© - 2]({% post_url 2025-10-03-[ìë£Œêµ¬ì¡°] ë°°ì—´(Array) - í™œìš© - 2 %})
- [[ìë£Œêµ¬ì¡°] ë°°ì—´(Array) - í™œìš© - 3]({% post_url 2025-10-03-[ìë£Œêµ¬ì¡°] ë°°ì—´(Array) - í™œìš© - 3 %})
- [[ìë£Œêµ¬ì¡°] ì—°ê²°ë¦¬ìŠ¤íŠ¸(Linked List) - ê¸°ë³¸ ì˜ˆì œ]({% post_url 2025-10-04-[ìë£Œêµ¬ì¡°] ì—°ê²°ë¦¬ìŠ¤íŠ¸(Linked List) - ê¸°ë³¸ ì˜ˆì œ %})
- [[ìë£Œêµ¬ì¡°] ì—°ê²°ë¦¬ìŠ¤íŠ¸(Linked List) - í™œìš© - 1]({% post_url 2025-10-04-[ìë£Œêµ¬ì¡°] ì—°ê²°ë¦¬ìŠ¤íŠ¸(Linked List) - í™œìš© - 1 %})
- [[ìë£Œêµ¬ì¡°] ì—°ê²°ë¦¬ìŠ¤íŠ¸(Linked List) - í™œìš© - 2]({% post_url 2025-10-04-[ìë£Œêµ¬ì¡°] ì—°ê²°ë¦¬ìŠ¤íŠ¸(Linked List) - í™œìš© - 2 %})
- [[ìë£Œêµ¬ì¡°] ì—°ê²°ë¦¬ìŠ¤íŠ¸(Linked List) - í™œìš© - 3]({% post_url 2025-10-04-[ìë£Œêµ¬ì¡°] ì—°ê²°ë¦¬ìŠ¤íŠ¸(Linked List) - í™œìš© - 3 %})
- [[ìë£Œêµ¬ì¡°] ìŠ¤íƒ(Stack) - ê¸°ë³¸ ì˜ˆì œ]({% post_url 2025-10-04-[ìë£Œêµ¬ì¡°] ìŠ¤íƒ(Stack) - ê¸°ë³¸ ì˜ˆì œ %})
- [[ìë£Œêµ¬ì¡°] ìŠ¤íƒ(Stack) - í™œìš© - 1]({% post_url 2025-10-04-[ìë£Œêµ¬ì¡°] ìŠ¤íƒ(Stack) - í™œìš© - 1 %})
- [[ìë£Œêµ¬ì¡°] ìŠ¤íƒ(Stack) - í™œìš© - 2]({% post_url 2025-10-04-[ìë£Œêµ¬ì¡°] ìŠ¤íƒ(Stack) - í™œìš© - 2 %})
- [[ìë£Œêµ¬ì¡°] ìŠ¤íƒ(Stack) - í™œìš© - 3]({% post_url 2025-10-04-[ìë£Œêµ¬ì¡°] ìŠ¤íƒ(Stack) - í™œìš© - 3 %})
- [[ìë£Œêµ¬ì¡°] í(Queue) - ê¸°ë³¸ ì˜ˆì œ]({% post_url 2025-10-05-[ìë£Œêµ¬ì¡°] í(Queue) - ê¸°ë³¸ ì˜ˆì œ %})
- [[ìë£Œêµ¬ì¡°] í(Queue) - í™œìš© - 1]({% post_url 2025-10-05-[ìë£Œêµ¬ì¡°] í(Queue) - í™œìš© - 1 %})
- [[ìë£Œêµ¬ì¡°] í(Queue) - í™œìš© - 3]({% post_url 2025-10-05-[ìë£Œêµ¬ì¡°] í(Queue) - í™œìš© - 3 %})

# ğŸ“ ë‚´ìš©

## ê°œìš”

íì˜ ê³ ê¸‰ í™œìš©ì—ì„œëŠ” ìš°ì„ ìˆœìœ„ í, ì´ì¤‘ í(Deque), ìŠ¤ë ˆë“œ í’€, ê·¸ë¦¬ê³  íë¥¼ ì´ìš©í•œ ê³ ê¸‰ ì•Œê³ ë¦¬ì¦˜ ìµœì í™” ê¸°ë²•ë“¤ì„ ë‹¤ë£¹ë‹ˆë‹¤. ì´ëŸ¬í•œ ê³ ê¸‰ ê¸°ë²•ë“¤ì€ ì‹¤ì œ ì‹œìŠ¤í…œ ê°œë°œê³¼ ë³µì¡í•œ ì•Œê³ ë¦¬ì¦˜ ë¬¸ì œ í•´ê²°ì—ì„œ ë§¤ìš° ì¤‘ìš”í•œ ì—­í• ì„ í•©ë‹ˆë‹¤.

**ë‹¤ë£° ê³ ê¸‰ í™œìš©ë“¤:**
- **ìš°ì„ ìˆœìœ„ í (Priority Queue)**: í™ ê¸°ë°˜ êµ¬í˜„ê³¼ ì‘ìš©
- **ì´ì¤‘ í (Deque)**: ì–‘ë°©í–¥ íì˜ ê³ ê¸‰ í™œìš©
- **ìŠ¤ë ˆë“œ í’€ (Thread Pool)**: ë™ì‹œì„± í”„ë¡œê·¸ë˜ë°ì—ì„œì˜ í í™œìš©
- **ì•Œê³ ë¦¬ì¦˜ ìµœì í™”**: BFS ìµœì í™”ì™€ ê³ ê¸‰ ê¸°ë²•ë“¤
- **ê³ ê¸‰ ë¬¸ì œ í•´ê²°**: ë³µì¡í•œ ì•Œê³ ë¦¬ì¦˜ì—ì„œì˜ í í™œìš©

## 1. ìš°ì„ ìˆœìœ„ í (Priority Queue)

ìš°ì„ ìˆœìœ„ íëŠ” ê° ì›ì†Œê°€ ìš°ì„ ìˆœìœ„ë¥¼ ê°€ì§€ë©°, ìš°ì„ ìˆœìœ„ê°€ ë†’ì€ ì›ì†Œê°€ ë¨¼ì € ì²˜ë¦¬ë˜ëŠ” ìë£Œêµ¬ì¡°ì…ë‹ˆë‹¤. ì¼ë°˜ì ìœ¼ë¡œ í™(Heap)ì„ ì´ìš©í•˜ì—¬ êµ¬í˜„í•©ë‹ˆë‹¤.

### 1-1 í™ ê¸°ë°˜ ìš°ì„ ìˆœìœ„ í êµ¬í˜„

```python
import heapq
from typing import List, Any, Tuple

class PriorityQueue:
    """
    ìš°ì„ ìˆœìœ„ í êµ¬í˜„ (ìµœì†Œ í™ ê¸°ë°˜)
    """
    def __init__(self):
        self._heap = []
        self._index = 0  # ë™ì¼í•œ ìš°ì„ ìˆœìœ„ì—ì„œ FIFO ìˆœì„œ ë³´ì¥
    
    def __len__(self):
        """íì˜ í¬ê¸° ë°˜í™˜"""
        return len(self._heap)
    
    def __str__(self):
        """íë¥¼ ë¬¸ìì—´ë¡œ í‘œí˜„"""
        items = [(priority, item) for priority, index, item in self._heap]
        return f"PriorityQueue({items})"
    
    def is_empty(self):
        """íê°€ ë¹„ì–´ìˆëŠ”ì§€ í™•ì¸ O(1)"""
        return len(self._heap) == 0
    
    def enqueue(self, item, priority=0):
        """
        ìš°ì„ ìˆœìœ„ íì— ì›ì†Œ ì¶”ê°€ O(log n)
        Args:
            item: ì¶”ê°€í•  ì›ì†Œ
            priority: ìš°ì„ ìˆœìœ„ (ë‚®ì€ ê°’ì´ ë†’ì€ ìš°ì„ ìˆœìœ„)
        """
        # heapqëŠ” ìµœì†Œ í™ì´ë¯€ë¡œ ìš°ì„ ìˆœìœ„ë¥¼ ìŒìˆ˜ë¡œ ë§Œë“¤ì–´ ìµœëŒ€ í™ íš¨ê³¼
        heapq.heappush(self._heap, (priority, self._index, item))
        self._index += 1
    
    def dequeue(self):
        """
        ê°€ì¥ ë†’ì€ ìš°ì„ ìˆœìœ„ ì›ì†Œ ì œê±° ë° ë°˜í™˜ O(log n)
        Returns:
            tuple: (ìš°ì„ ìˆœìœ„, ì›ì†Œ)
        """
        if self.is_empty():
            raise IndexError("Priority queue is empty")
        
        priority, index, item = heapq.heappop(self._heap)
        return priority, item
    
    def peek(self):
        """
        ê°€ì¥ ë†’ì€ ìš°ì„ ìˆœìœ„ ì›ì†Œ í™•ì¸ (ì œê±°í•˜ì§€ ì•ŠìŒ) O(1)
        Returns:
            tuple: (ìš°ì„ ìˆœìœ„, ì›ì†Œ)
        """
        if self.is_empty():
            raise IndexError("Priority queue is empty")
        
        priority, index, item = self._heap[0]
        return priority, item
    
    def update_priority(self, old_item, new_priority):
        """
        íŠ¹ì • ì›ì†Œì˜ ìš°ì„ ìˆœìœ„ ì—…ë°ì´íŠ¸ O(n log n)
        Args:
            old_item: ìš°ì„ ìˆœìœ„ë¥¼ ë³€ê²½í•  ì›ì†Œ
            new_priority: ìƒˆë¡œìš´ ìš°ì„ ìˆœìœ„
        """
        # ê¸°ì¡´ ì›ì†Œ ì°¾ê¸° ë° ì œê±°
        for i, (priority, index, item) in enumerate(self._heap):
            if item == old_item:
                self._heap[i] = self._heap[-1]
                self._heap.pop()
                heapq.heapify(self._heap)
                break
        
        # ìƒˆë¡œìš´ ìš°ì„ ìˆœìœ„ë¡œ ì¶”ê°€
        self.enqueue(old_item, new_priority)

# í…ŒìŠ¤íŠ¸
pq = PriorityQueue()

print("=== ìš°ì„ ìˆœìœ„ í í…ŒìŠ¤íŠ¸ ===")

# ì›ì†Œ ì¶”ê°€ (ìš°ì„ ìˆœìœ„ê°€ ë‚®ì„ìˆ˜ë¡ ë†’ì€ ìš°ì„ ìˆœìœ„)
pq.enqueue("ë†’ì€ ìš°ì„ ìˆœìœ„", 1)
pq.enqueue("ì¤‘ê°„ ìš°ì„ ìˆœìœ„", 3)
pq.enqueue("ê°€ì¥ ë†’ì€ ìš°ì„ ìˆœìœ„", 0)
pq.enqueue("ë‚®ì€ ìš°ì„ ìˆœìœ„", 5)

print(f"í ìƒíƒœ: {pq}")
print(f"í¬ê¸°: {len(pq)}")

# ìš°ì„ ìˆœìœ„ ìˆœìœ¼ë¡œ ì œê±°
print("\nìš°ì„ ìˆœìœ„ ìˆœìœ¼ë¡œ ì œê±°:")
while not pq.is_empty():
    priority, item = pq.dequeue()
    print(f"ìš°ì„ ìˆœìœ„ {priority}: {item}")
```

### 1-2 Dijkstra ì•Œê³ ë¦¬ì¦˜ì—ì„œì˜ ìš°ì„ ìˆœìœ„ í í™œìš©

```python
from collections import defaultdict
import heapq

class Graph:
    """ê°€ì¤‘ì¹˜ ê·¸ë˜í”„ êµ¬í˜„"""
    def __init__(self):
        self.graph = defaultdict(list)
    
    def add_edge(self, u, v, weight):
        """ê°€ì¤‘ì¹˜ ê°„ì„  ì¶”ê°€"""
        self.graph[u].append((v, weight))
        self.graph[v].append((u, weight))  # ë¬´ë°©í–¥ ê·¸ë˜í”„
    
    def dijkstra(self, start):
        """
        Dijkstra ì•Œê³ ë¦¬ì¦˜ìœ¼ë¡œ ìµœë‹¨ ê²½ë¡œ ê³„ì‚°
        Args:
            start: ì‹œì‘ ì •ì 
        Returns:
            dict: ê° ì •ì ê¹Œì§€ì˜ ìµœë‹¨ ê±°ë¦¬
        """
        # ê±°ë¦¬ ì´ˆê¸°í™” (ë¬´í•œëŒ€ë¡œ ì„¤ì •)
        distances = {vertex: float('inf') for vertex in self.graph}
        distances[start] = 0
        
        # ìš°ì„ ìˆœìœ„ í (ê±°ë¦¬, ì •ì )
        pq = [(0, start)]
        visited = set()
        
        print(f"Dijkstra ì•Œê³ ë¦¬ì¦˜ ì‹œì‘: ì‹œì‘ì  {start}")
        
        while pq:
            current_distance, current_vertex = heapq.heappop(pq)
            
            if current_vertex in visited:
                continue
            
            visited.add(current_vertex)
            print(f"ë°©ë¬¸: {current_vertex}, ê±°ë¦¬: {current_distance}")
            
            # ì¸ì ‘í•œ ì •ì ë“¤ í™•ì¸
            for neighbor, weight in self.graph[current_vertex]:
                if neighbor not in visited:
                    distance = current_distance + weight
                    
                    # ë” ì§§ì€ ê²½ë¡œ ë°œê²¬ ì‹œ ì—…ë°ì´íŠ¸
                    if distance < distances[neighbor]:
                        distances[neighbor] = distance
                        heapq.heappush(pq, (distance, neighbor))
                        print(f"  {neighbor} ê±°ë¦¬ ì—…ë°ì´íŠ¸: {distance}")
        
        return distances
    
    def dijkstra_with_path(self, start, target):
        """
        Dijkstra ì•Œê³ ë¦¬ì¦˜ìœ¼ë¡œ ìµœë‹¨ ê²½ë¡œì™€ ê²½ë¡œ ë°˜í™˜
        """
        distances = {vertex: float('inf') for vertex in self.graph}
        distances[start] = 0
        previous = {}
        
        pq = [(0, start)]
        visited = set()
        
        while pq:
            current_distance, current_vertex = heapq.heappop(pq)
            
            if current_vertex in visited:
                continue
            
            visited.add(current_vertex)
            
            if current_vertex == target:
                break
            
            for neighbor, weight in self.graph[current_vertex]:
                if neighbor not in visited:
                    distance = current_distance + weight
                    
                    if distance < distances[neighbor]:
                        distances[neighbor] = distance
                        previous[neighbor] = current_vertex
                        heapq.heappush(pq, (distance, neighbor))
        
        # ê²½ë¡œ ì¬êµ¬ì„±
        path = []
        current = target
        while current is not None:
            path.append(current)
            current = previous.get(current)
        
        path.reverse()
        
        return distances[target] if distances[target] != float('inf') else None, path

# í…ŒìŠ¤íŠ¸
graph = Graph()
graph.add_edge('A', 'B', 4)
graph.add_edge('A', 'C', 2)
graph.add_edge('B', 'C', 1)
graph.add_edge('B', 'D', 5)
graph.add_edge('C', 'D', 8)
graph.add_edge('C', 'E', 10)
graph.add_edge('D', 'E', 2)

print("=== Dijkstra ì•Œê³ ë¦¬ì¦˜ í…ŒìŠ¤íŠ¸ ===")
print("ê·¸ë˜í”„:")
for vertex, edges in graph.graph.items():
    print(f"{vertex}: {edges}")

print("\nìµœë‹¨ ê±°ë¦¬ ê³„ì‚° (Aì—ì„œ ì‹œì‘):")
distances = graph.dijkstra('A')
for vertex, distance in distances.items():
    if distance != float('inf'):
        print(f"A -> {vertex}: {distance}")

print(f"\nìµœë‹¨ ê²½ë¡œ (A -> E):")
distance, path = graph.dijkstra_with_path('A', 'E')
print(f"ê±°ë¦¬: {distance}, ê²½ë¡œ: {' -> '.join(path)}")
```

### 1-3 A* ì•Œê³ ë¦¬ì¦˜ì—ì„œì˜ ìš°ì„ ìˆœìœ„ í

```python
import heapq
from typing import List, Tuple, Optional

class AStarNode:
    """A* ì•Œê³ ë¦¬ì¦˜ìš© ë…¸ë“œ"""
    def __init__(self, position, g_cost=0, h_cost=0, parent=None):
        self.position = position
        self.g_cost = g_cost  # ì‹œì‘ì ë¶€í„°ì˜ ì‹¤ì œ ë¹„ìš©
        self.h_cost = h_cost  # íœ´ë¦¬ìŠ¤í‹± ë¹„ìš© (ëª©í‘œê¹Œì§€ì˜ ì¶”ì •)
        self.parent = parent
    
    @property
    def f_cost(self):
        """ì´ ë¹„ìš© (g + h)"""
        return self.g_cost + self.h_cost
    
    def __lt__(self, other):
        """ìš°ì„ ìˆœìœ„ íë¥¼ ìœ„í•œ ë¹„êµ ì—°ì‚°ì"""
        return self.f_cost < other.f_cost

class AStarPathfinder:
    """A* ê²½ë¡œ íƒìƒ‰ ì•Œê³ ë¦¬ì¦˜"""
    
    def __init__(self, grid):
        """
        Args:
            grid: 2D ê·¸ë¦¬ë“œ (0: í†µê³¼ ê°€ëŠ¥, 1: ì¥ì• ë¬¼)
        """
        self.grid = grid
        self.rows = len(grid)
        self.cols = len(grid[0]) if self.rows > 0 else 0
    
    def heuristic(self, pos1, pos2):
        """ë§¨í•˜íƒ„ ê±°ë¦¬ íœ´ë¦¬ìŠ¤í‹±"""
        return abs(pos1[0] - pos2[0]) + abs(pos1[1] - pos2[1])
    
    def get_neighbors(self, position):
        """ì¸ì ‘í•œ ìœ„ì¹˜ë“¤ ë°˜í™˜"""
        row, col = position
        neighbors = []
        
        # ìƒí•˜ì¢Œìš° ì´ë™
        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]
        
        for dr, dc in directions:
            new_row, new_col = row + dr, col + dc
            
            if (0 <= new_row < self.rows and 
                0 <= new_col < self.cols and 
                self.grid[new_row][new_col] == 0):
                neighbors.append((new_row, new_col))
        
        return neighbors
    
    def find_path(self, start, goal):
        """
        A* ì•Œê³ ë¦¬ì¦˜ìœ¼ë¡œ ìµœë‹¨ ê²½ë¡œ íƒìƒ‰
        Args:
            start: ì‹œì‘ ìœ„ì¹˜ (row, col)
            goal: ëª©í‘œ ìœ„ì¹˜ (row, col)
        Returns:
            list: ê²½ë¡œ (ìœ„ì¹˜ë“¤ì˜ ë¦¬ìŠ¤íŠ¸)
        """
        open_set = []  # ìš°ì„ ìˆœìœ„ í
        closed_set = set()
        
        start_node = AStarNode(start, 0, self.heuristic(start, goal))
        heapq.heappush(open_set, start_node)
        
        print(f"A* ê²½ë¡œ íƒìƒ‰ ì‹œì‘: {start} -> {goal}")
        
        while open_set:
            current = heapq.heappop(open_set)
            
            if current.position in closed_set:
                continue
            
            closed_set.add(current.position)
            
            if current.position == goal:
                # ê²½ë¡œ ì¬êµ¬ì„±
                path = []
                while current:
                    path.append(current.position)
                    current = current.parent
                path.reverse()
                
                print(f"ê²½ë¡œ íƒìƒ‰ ì™„ë£Œ: ê¸¸ì´ {len(path)}")
                return path
            
            # ì¸ì ‘í•œ ë…¸ë“œë“¤ í™•ì¸
            for neighbor_pos in self.get_neighbors(current.position):
                if neighbor_pos in closed_set:
                    continue
                
                g_cost = current.g_cost + 1  # ì´ë™ ë¹„ìš© (1ë¡œ ê°€ì •)
                h_cost = self.heuristic(neighbor_pos, goal)
                
                # ê¸°ì¡´ì— ë” ì¢‹ì€ ê²½ë¡œê°€ ìˆëŠ”ì§€ í™•ì¸
                existing_node = None
                for node in open_set:
                    if node.position == neighbor_pos:
                        existing_node = node
                        break
                
                if existing_node is None or g_cost < existing_node.g_cost:
                    neighbor_node = AStarNode(neighbor_pos, g_cost, h_cost, current)
                    heapq.heappush(open_set, neighbor_node)
        
        return None  # ê²½ë¡œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŒ

# í…ŒìŠ¤íŠ¸
grid = [
    [0, 0, 0, 0, 1, 0, 0, 0],
    [0, 1, 1, 0, 1, 0, 1, 0],
    [0, 0, 0, 0, 0, 0, 1, 0],
    [0, 1, 0, 1, 1, 0, 1, 0],
    [0, 0, 0, 0, 0, 0, 0, 0],
]

print("=== A* ì•Œê³ ë¦¬ì¦˜ í…ŒìŠ¤íŠ¸ ===")
print("ê·¸ë¦¬ë“œ (0: í†µê³¼ ê°€ëŠ¥, 1: ì¥ì• ë¬¼):")
for row in grid:
    print(row)

pathfinder = AStarPathfinder(grid)
start = (0, 0)
goal = (4, 7)

path = pathfinder.find_path(start, goal)

if path:
    print(f"\nê²½ë¡œ ë°œê²¬: {path}")
    
    # ê²½ë¡œ ì‹œê°í™”
    print("\nê²½ë¡œ ì‹œê°í™”:")
    for i, row in enumerate(grid):
        line = ""
        for j, cell in enumerate(row):
            if (i, j) == start:
                line += "S "
            elif (i, j) == goal:
                line += "G "
            elif (i, j) in path:
                line += "* "
            elif cell == 1:
                line += "â–ˆ "
            else:
                line += "  "
        print(line)
else:
    print("ê²½ë¡œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
```

## 2. ì´ì¤‘ í (Deque) ê³ ê¸‰ í™œìš©

ì´ì¤‘ íëŠ” ì–‘ìª½ ëì—ì„œ ì‚½ì…ê³¼ ì‚­ì œê°€ ëª¨ë‘ ê°€ëŠ¥í•œ ìë£Œêµ¬ì¡°ì…ë‹ˆë‹¤.

### 2-1 ìŠ¬ë¼ì´ë”© ìœˆë„ìš° ìµœì í™”

```python
from collections import deque

class SlidingWindowOptimizer:
    """ìŠ¬ë¼ì´ë”© ìœˆë„ìš° ìµœì í™” í´ë˜ìŠ¤"""
    
    def max_sliding_window(self, nums, k):
        """
        ìŠ¬ë¼ì´ë”© ìœˆë„ìš° ìµœëŒ“ê°’ (ë± ìµœì í™”)
        """
        if not nums or k <= 0:
            return []
        
        result = []
        dq = deque()  # ì¸ë±ìŠ¤ë¥¼ ì €ì¥
        
        for i in range(len(nums)):
            # ìœˆë„ìš° ë²”ìœ„ë¥¼ ë²—ì–´ë‚œ ì¸ë±ìŠ¤ ì œê±°
            while dq and dq[0] <= i - k:
                dq.popleft()
            
            # í˜„ì¬ ì›ì†Œë³´ë‹¤ ì‘ì€ ì›ì†Œë“¤ì˜ ì¸ë±ìŠ¤ ì œê±°
            while dq and nums[dq[-1]] <= nums[i]:
                dq.pop()
            
            dq.append(i)
            
            # ìœˆë„ìš°ê°€ ì™„ì„±ëœ ê²½ìš° ìµœëŒ“ê°’ ì¶”ê°€
            if i >= k - 1:
                result.append(nums[dq[0]])
        
        return result
    
    def min_sliding_window(self, nums, k):
        """
        ìŠ¬ë¼ì´ë”© ìœˆë„ìš° ìµœì†Ÿê°’
        """
        if not nums or k <= 0:
            return []
        
        result = []
        dq = deque()
        
        for i in range(len(nums)):
            while dq and dq[0] <= i - k:
                dq.popleft()
            
            while dq and nums[dq[-1]] >= nums[i]:
                dq.pop()
            
            dq.append(i)
            
            if i >= k - 1:
                result.append(nums[dq[0]])
        
        return result

# í…ŒìŠ¤íŠ¸
optimizer = SlidingWindowOptimizer()

nums = [1, 3, -1, -3, 5, 3, 6, 7]
k = 3

print("=== ìŠ¬ë¼ì´ë”© ìœˆë„ìš° ìµœì í™” ===")
print(f"ë°°ì—´: {nums}, ìœˆë„ìš° í¬ê¸°: {k}")

max_values = optimizer.max_sliding_window(nums, k)
min_values = optimizer.min_sliding_window(nums, k)

print(f"ìµœëŒ“ê°’ë“¤: {max_values}")
print(f"ìµœì†Ÿê°’ë“¤: {min_values}")
```

### 2-2 íšŒì „ ë°°ì—´ ë¬¸ì œ

```python
from collections import deque

class RotatingArray:
    """íšŒì „ ë°°ì—´ í´ë˜ìŠ¤"""
    
    def __init__(self, nums):
        self.deque = deque(nums)
    
    def rotate_right(self, k):
        """
        ì˜¤ë¥¸ìª½ìœ¼ë¡œ kë§Œí¼ íšŒì „
        """
        k = k % len(self.deque)
        for _ in range(k):
            self.deque.appendleft(self.deque.pop())
    
    def rotate_left(self, k):
        """
        ì™¼ìª½ìœ¼ë¡œ kë§Œí¼ íšŒì „
        """
        k = k % len(self.deque)
        for _ in range(k):
            self.deque.append(self.deque.popleft())
    
    def get_array(self):
        """í˜„ì¬ ë°°ì—´ ìƒíƒœ ë°˜í™˜"""
        return list(self.deque)
    
    def find_rotation_point(self, target):
        """
        íšŒì „ëœ ì •ë ¬ ë°°ì—´ì—ì„œ íšŒì „ì  ì°¾ê¸°
        """
        left, right = 0, len(self.deque) - 1
        
        while left < right:
            mid = (left + right) // 2
            
            if self.deque[mid] > self.deque[right]:
                left = mid + 1
            else:
                right = mid
        
        return left

# í…ŒìŠ¤íŠ¸
print("=== íšŒì „ ë°°ì—´ í…ŒìŠ¤íŠ¸ ===")
arr = RotatingArray([1, 2, 3, 4, 5, 6, 7])
print(f"ì´ˆê¸° ë°°ì—´: {arr.get_array()}")

arr.rotate_right(3)
print(f"ì˜¤ë¥¸ìª½ 3íšŒì „: {arr.get_array()}")

arr.rotate_left(2)
print(f"ì™¼ìª½ 2íšŒì „: {arr.get_array()}")
```

## 3. ìŠ¤ë ˆë“œ í’€ (Thread Pool)

ë™ì‹œì„± í”„ë¡œê·¸ë˜ë°ì—ì„œ íë¥¼ í™œìš©í•œ ìŠ¤ë ˆë“œ í’€ êµ¬í˜„ì…ë‹ˆë‹¤.

```python
import threading
import time
import queue
from concurrent.futures import ThreadPoolExecutor
import random

class SimpleThreadPool:
    """ê°„ë‹¨í•œ ìŠ¤ë ˆë“œ í’€ êµ¬í˜„"""
    
    def __init__(self, num_workers=4):
        self.num_workers = num_workers
        self.task_queue = queue.Queue()
        self.result_queue = queue.Queue()
        self.workers = []
        self.shutdown = False
        
        # ì›Œì»¤ ìŠ¤ë ˆë“œë“¤ ì‹œì‘
        for i in range(num_workers):
            worker = threading.Thread(target=self._worker, args=(i,))
            worker.daemon = True
            worker.start()
            self.workers.append(worker)
    
    def _worker(self, worker_id):
        """ì›Œì»¤ ìŠ¤ë ˆë“œ í•¨ìˆ˜"""
        print(f"ì›Œì»¤ {worker_id} ì‹œì‘")
        
        while not self.shutdown:
            try:
                # ì‘ì—… ëŒ€ê¸° (íƒ€ì„ì•„ì›ƒ ì„¤ì •)
                task = self.task_queue.get(timeout=1)
                
                if task is None:  # ì¢…ë£Œ ì‹ í˜¸
                    break
                
                func, args, task_id = task
                print(f"ì›Œì»¤ {worker_id}: ì‘ì—… {task_id} ì‹œì‘")
                
                # ì‘ì—… ì‹¤í–‰
                result = func(*args)
                
                # ê²°ê³¼ ì €ì¥
                self.result_queue.put((task_id, result))
                print(f"ì›Œì»¤ {worker_id}: ì‘ì—… {task_id} ì™„ë£Œ")
                
                self.task_queue.task_done()
                
            except queue.Empty:
                continue
            except Exception as e:
                print(f"ì›Œì»¤ {worker_id}: ì˜¤ë¥˜ ë°œìƒ - {e}")
                self.task_queue.task_done()
        
        print(f"ì›Œì»¤ {worker_id} ì¢…ë£Œ")
    
    def submit(self, func, *args, task_id=None):
        """ì‘ì—… ì œì¶œ"""
        if task_id is None:
            task_id = f"task_{int(time.time() * 1000)}"
        
        self.task_queue.put((func, args, task_id))
        return task_id
    
    def get_result(self, timeout=None):
        """ê²°ê³¼ ê°€ì ¸ì˜¤ê¸°"""
        return self.result_queue.get(timeout=timeout)
    
    def shutdown_pool(self):
        """ìŠ¤ë ˆë“œ í’€ ì¢…ë£Œ"""
        self.shutdown = True
        
        # ëª¨ë“  ì›Œì»¤ì—ê²Œ ì¢…ë£Œ ì‹ í˜¸ ì „ì†¡
        for _ in range(self.num_workers):
            self.task_queue.put(None)
        
        # ëª¨ë“  ì›Œì»¤ ìŠ¤ë ˆë“œ ì¢…ë£Œ ëŒ€ê¸°
        for worker in self.workers:
            worker.join()

# í…ŒìŠ¤íŠ¸ í•¨ìˆ˜ë“¤
def cpu_intensive_task(n):
    """CPU ì§‘ì•½ì  ì‘ì—…"""
    result = 0
    for i in range(n):
        result += i ** 2
    return result

def io_intensive_task(duration):
    """I/O ì§‘ì•½ì  ì‘ì—… (ì‹œë®¬ë ˆì´ì…˜)"""
    time.sleep(duration)
    return f"I/O ì‘ì—… ì™„ë£Œ ({duration}ì´ˆ)"

def random_task(task_id):
    """ëœë¤ ì‘ì—…"""
    duration = random.uniform(0.5, 2.0)
    time.sleep(duration)
    return f"ì‘ì—… {task_id} ì™„ë£Œ ({duration:.2f}ì´ˆ)"

# í…ŒìŠ¤íŠ¸
print("=== ìŠ¤ë ˆë“œ í’€ í…ŒìŠ¤íŠ¸ ===")

# ê°„ë‹¨í•œ ìŠ¤ë ˆë“œ í’€ í…ŒìŠ¤íŠ¸
pool = SimpleThreadPool(num_workers=3)

# ì‘ì—…ë“¤ ì œì¶œ
task_ids = []
for i in range(5):
    task_id = pool.submit(random_task, f"task_{i}")
    task_ids.append(task_id)

# ê²°ê³¼ ìˆ˜ì§‘
print("\nê²°ê³¼ ìˆ˜ì§‘:")
for _ in range(5):
    task_id, result = pool.get_result()
    print(f"ê²°ê³¼: {result}")

# ìŠ¤ë ˆë“œ í’€ ì¢…ë£Œ
pool.shutdown_pool()

# Python ë‚´ì¥ ThreadPoolExecutor ì‚¬ìš©
print("\n=== ThreadPoolExecutor í…ŒìŠ¤íŠ¸ ===")

def process_data(data):
    """ë°ì´í„° ì²˜ë¦¬ í•¨ìˆ˜"""
    time.sleep(0.5)
    return f"ì²˜ë¦¬ë¨: {data}"

with ThreadPoolExecutor(max_workers=4) as executor:
    # ì‘ì—…ë“¤ ì œì¶œ
    futures = []
    for i in range(8):
        future = executor.submit(process_data, f"data_{i}")
        futures.append(future)
    
    # ê²°ê³¼ ìˆ˜ì§‘
    results = []
    for future in futures:
        result = future.result()
        results.append(result)
    
    print("ì²˜ë¦¬ ê²°ê³¼:")
    for result in results:
        print(result)
```

## 4. ê³ ê¸‰ BFS ìµœì í™”

### 4-1 ë‹¤ì¤‘ ì‹œì‘ì  BFS

```python
from collections import deque
from typing import List, Tuple

class MultiSourceBFS:
    """ë‹¤ì¤‘ ì‹œì‘ì  BFS"""
    
    def __init__(self, grid):
        self.grid = grid
        self.rows = len(grid)
        self.cols = len(grid[0]) if self.rows > 0 else 0
    
    def multi_source_bfs(self, sources):
        """
        ì—¬ëŸ¬ ì‹œì‘ì ì—ì„œ ë™ì‹œì— BFS ì‹¤í–‰
        Args:
            sources: ì‹œì‘ì ë“¤ì˜ ë¦¬ìŠ¤íŠ¸ [(row, col), ...]
        Returns:
            dict: ê° ìœ„ì¹˜ê¹Œì§€ì˜ ìµœë‹¨ ê±°ë¦¬
        """
        distances = {}
        queue = deque()
        
        # ëª¨ë“  ì‹œì‘ì ì„ íì— ì¶”ê°€
        for source in sources:
            queue.append((source, 0))
            distances[source] = 0
        
        # BFS ì‹¤í–‰
        while queue:
            (row, col), distance = queue.popleft()
            
            # ì¸ì ‘í•œ ìœ„ì¹˜ë“¤ í™•ì¸
            directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]
            
            for dr, dc in directions:
                new_row, new_col = row + dr, col + dc
                
                if (0 <= new_row < self.rows and 
                    0 <= new_col < self.cols and 
                    (new_row, new_col) not in distances and
                    self.grid[new_row][new_col] != 1):  # ì¥ì• ë¬¼ì´ ì•„ë‹Œ ê²½ìš°
                    
                    new_distance = distance + 1
                    distances[(new_row, new_col)] = new_distance
                    queue.append(((new_row, new_col), new_distance))
        
        return distances
    
    def find_nearest_source(self, target, sources):
        """
        ëª©í‘œ ìœ„ì¹˜ì—ì„œ ê°€ì¥ ê°€ê¹Œìš´ ì‹œì‘ì  ì°¾ê¸°
        """
        distances = self.multi_source_bfs(sources)
        
        if target in distances:
            return distances[target], target
        
        return float('inf'), None

# í…ŒìŠ¤íŠ¸
grid = [
    [0, 0, 1, 0, 0],
    [0, 0, 1, 0, 0],
    [0, 0, 0, 0, 0],
    [0, 0, 1, 0, 0],
    [0, 0, 0, 0, 0],
]

print("=== ë‹¤ì¤‘ ì‹œì‘ì  BFS í…ŒìŠ¤íŠ¸ ===")
print("ê·¸ë¦¬ë“œ (0: í†µê³¼ ê°€ëŠ¥, 1: ì¥ì• ë¬¼):")
for row in grid:
    print(row)

sources = [(0, 0), (4, 4), (2, 2)]
target = (1, 4)

bfs = MultiSourceBFS(grid)
distances = bfs.multi_source_bfs(sources)

print(f"\nì‹œì‘ì ë“¤: {sources}")
print(f"ëª©í‘œì : {target}")

print("\nê° ìœ„ì¹˜ê¹Œì§€ì˜ ìµœë‹¨ ê±°ë¦¬:")
for (row, col), distance in sorted(distances.items()):
    print(f"({row}, {col}): {distance}")

nearest_distance, nearest_source = bfs.find_nearest_source(target, sources)
print(f"\nëª©í‘œì  {target}ì—ì„œ ê°€ì¥ ê°€ê¹Œìš´ ì‹œì‘ì : {nearest_source} (ê±°ë¦¬: {nearest_distance})")
```

### 4-2 0-1 BFS (ê°€ì¤‘ì¹˜ê°€ 0 ë˜ëŠ” 1ì¸ ê·¸ë˜í”„)

```python
from collections import deque

class ZeroOneBFS:
    """0-1 BFS (ê°€ì¤‘ì¹˜ê°€ 0 ë˜ëŠ” 1ì¸ ê·¸ë˜í”„ìš©)"""
    
    def __init__(self, graph):
        """
        Args:
            graph: ì¸ì ‘ ë¦¬ìŠ¤íŠ¸ {vertex: [(neighbor, weight), ...]}
        """
        self.graph = graph
    
    def shortest_path(self, start, target):
        """
        0-1 BFSë¡œ ìµœë‹¨ ê²½ë¡œ ì°¾ê¸°
        """
        distances = {vertex: float('inf') for vertex in self.graph}
        distances[start] = 0
        
        # ë± ì‚¬ìš© (ì•ìª½: ê°€ì¤‘ì¹˜ 0, ë’¤ìª½: ê°€ì¤‘ì¹˜ 1)
        queue = deque([start])
        
        while queue:
            current = queue.popleft()
            
            if current == target:
                break
            
            for neighbor, weight in self.graph.get(current, []):
                new_distance = distances[current] + weight
                
                if new_distance < distances[neighbor]:
                    distances[neighbor] = new_distance
                    
                    if weight == 0:
                        # ê°€ì¤‘ì¹˜ 0: íì˜ ì•ìª½ì— ì¶”ê°€
                        queue.appendleft(neighbor)
                    else:
                        # ê°€ì¤‘ì¹˜ 1: íì˜ ë’¤ìª½ì— ì¶”ê°€
                        queue.append(neighbor)
        
        return distances[target] if distances[target] != float('inf') else -1

# í…ŒìŠ¤íŠ¸
graph = {
    'A': [('B', 1), ('C', 0)],
    'B': [('A', 1), ('D', 1)],
    'C': [('A', 0), ('D', 0)],
    'D': [('B', 1), ('C', 0), ('E', 1)],
    'E': [('D', 1)]
}

print("=== 0-1 BFS í…ŒìŠ¤íŠ¸ ===")
print("ê·¸ë˜í”„:")
for vertex, edges in graph.items():
    print(f"{vertex}: {edges}")

bfs_01 = ZeroOneBFS(graph)
start, target = 'A', 'E'

distance = bfs_01.shortest_path(start, target)
print(f"\nìµœë‹¨ ê±°ë¦¬ ({start} -> {target}): {distance}")
```

## ì •ë¦¬

ì´ë²ˆ í¬ìŠ¤íŠ¸ì—ì„œëŠ” íì˜ ê³ ê¸‰ í™œìš©ê³¼ ì•Œê³ ë¦¬ì¦˜ ìµœì í™” ê¸°ë²•ë“¤ì„ ì‚´í´ë³´ì•˜ìŠµë‹ˆë‹¤.

**ê³ ê¸‰ í™œìš© ì •ë¦¬**
1. **ìš°ì„ ìˆœìœ„ í**: í™ ê¸°ë°˜ êµ¬í˜„, Dijkstra, A* ì•Œê³ ë¦¬ì¦˜ì—ì„œì˜ í™œìš©
2. **ì´ì¤‘ í**: ìŠ¬ë¼ì´ë”© ìœˆë„ìš° ìµœì í™”, íšŒì „ ë°°ì—´ ë¬¸ì œ
3. **ìŠ¤ë ˆë“œ í’€**: ë™ì‹œì„± í”„ë¡œê·¸ë˜ë°ì—ì„œì˜ í í™œìš©
4. **ê³ ê¸‰ BFS**: ë‹¤ì¤‘ ì‹œì‘ì  BFS, 0-1 BFS ë“± ìµœì í™” ê¸°ë²•
5. **ì•Œê³ ë¦¬ì¦˜ ìµœì í™”**: ë³µì¡í•œ ë¬¸ì œì—ì„œì˜ íš¨ìœ¨ì ì¸ í í™œìš©

**í ê³ ê¸‰ í™œìš©ì˜ í•µì‹¬ ì›ì¹™**
- **ìš°ì„ ìˆœìœ„ ì²˜ë¦¬**: ìš°ì„ ìˆœìœ„ íë¡œ ì¤‘ìš”í•œ ì‘ì—…ì„ ë¨¼ì € ì²˜ë¦¬
- **ì–‘ë°©í–¥ ì²˜ë¦¬**: ë±ì„ ì´ìš©í•œ ì–‘ë°©í–¥ ë°ì´í„° ì²˜ë¦¬
- **ë™ì‹œì„± ê´€ë¦¬**: ìŠ¤ë ˆë“œ í’€ë¡œ ë³‘ë ¬ ì‘ì—… ê´€ë¦¬
- **ìµœì í™”**: íŠ¹ìˆ˜í•œ ìƒí™©ì—ì„œì˜ BFS ìµœì í™” ê¸°ë²•
- **ë³µí•© ìë£Œêµ¬ì¡°**: íì™€ ë‹¤ë¥¸ ìë£Œêµ¬ì¡°ì˜ ì¡°í•© í™œìš©

**ì‹¤ë¬´ì—ì„œì˜ ê³ ê¸‰ í í™œìš©**
- **ìš´ì˜ì²´ì œ**: í”„ë¡œì„¸ìŠ¤ ìŠ¤ì¼€ì¤„ë§, ìš°ì„ ìˆœìœ„ ê¸°ë°˜ ì‘ì—… ì²˜ë¦¬
- **ë„¤íŠ¸ì›Œí¬**: íŒ¨í‚· ì²˜ë¦¬, ë¼ìš°íŒ… ì•Œê³ ë¦¬ì¦˜
- **ê²Œì„ ê°œë°œ**: A* ê²½ë¡œ íƒìƒ‰, AI ì˜ì‚¬ê²°ì •
- **ì‹œìŠ¤í…œ ì„¤ê³„**: ìŠ¤ë ˆë“œ í’€, ì‘ì—… í, ì´ë²¤íŠ¸ ì²˜ë¦¬

**ë‹¤ìŒ í•™ìŠµ ê³„íš**
ë‹¤ìŒ í¬ìŠ¤íŠ¸ì—ì„œëŠ” íì˜ ì‹¤ë¬´ í™œìš©ê³¼ ì‹¤ì œ í”„ë¡œì íŠ¸ì—ì„œì˜ ì ìš© ì‚¬ë¡€ë¥¼ ì•Œì•„ë³´ê² ìŠµë‹ˆë‹¤:
- [[í•™ìŠµ] [ìë£Œêµ¬ì¡°] í(Queue) í™œìš© - 3. ì‹¤ë¬´ í™œìš©]({% post_url 2025-10-05-[ìë£Œêµ¬ì¡°] í(Queue) - í™œìš© - 3 %}) - ë©”ì‹œì§€ í, ì‘ì—… í, ì´ë²¤íŠ¸ ì‹œìŠ¤í…œ, ìºì‹± ë“±

# ğŸ“š ë ˆí¼ëŸ°ìŠ¤
- [Priority Queue - Wikipedia](https://en.wikipedia.org/wiki/Priority_queue)
- [Dijkstra's Algorithm - Wikipedia](https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm)
- [A* Search Algorithm - Wikipedia](https://en.wikipedia.org/wiki/A*_search_algorithm)
- [Thread Pool Pattern - Wikipedia](https://en.wikipedia.org/wiki/Thread_pool_pattern)

---
*ì´ í¬ìŠ¤íŠ¸ëŠ” ìë£Œêµ¬ì¡° í•™ìŠµ ê³¼ì •ì„ ì •ë¦¬í•œ ë‚´ìš©ì…ë‹ˆë‹¤.*
