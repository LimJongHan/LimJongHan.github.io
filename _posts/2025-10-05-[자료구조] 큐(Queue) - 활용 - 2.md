---
layout: post
title: "[자료구조] 큐(Queue) - 활용 - 2"
date: 2025-10-05 21:00:00 +0900
categories: [자료구조, 큐]
tags: [자료구조, 큐, Queue, 우선순위큐, 힙, 이중큐, 스레드풀, 고급알고리즘]
author: LimJongHan
toc: true
---

# 📖 관련된 내 포스팅
- [[자료구조] 자료구조와 알고리즘 개요]({% post_url 2025-10-02-[자료구조] 자료구조와 알고리즘 개요 %})
- [[자료구조] 배열(Array) - 기본 예제]({% post_url 2025-10-03-[자료구조] 배열(Array) - 기본 예제 %})
- [[자료구조] 배열(Array) - 활용 - 1]({% post_url 2025-10-03-[자료구조] 배열(Array) - 활용 - 1 %})
- [[자료구조] 배열(Array) - 활용 - 2]({% post_url 2025-10-03-[자료구조] 배열(Array) - 활용 - 2 %})
- [[자료구조] 배열(Array) - 활용 - 3]({% post_url 2025-10-03-[자료구조] 배열(Array) - 활용 - 3 %})
- [[자료구조] 연결리스트(Linked List) - 기본 예제]({% post_url 2025-10-04-[자료구조] 연결리스트(Linked List) - 기본 예제 %})
- [[자료구조] 연결리스트(Linked List) - 활용 - 1]({% post_url 2025-10-04-[자료구조] 연결리스트(Linked List) - 활용 - 1 %})
- [[자료구조] 연결리스트(Linked List) - 활용 - 2]({% post_url 2025-10-04-[자료구조] 연결리스트(Linked List) - 활용 - 2 %})
- [[자료구조] 연결리스트(Linked List) - 활용 - 3]({% post_url 2025-10-04-[자료구조] 연결리스트(Linked List) - 활용 - 3 %})
- [[자료구조] 스택(Stack) - 기본 예제]({% post_url 2025-10-04-[자료구조] 스택(Stack) - 기본 예제 %})
- [[자료구조] 스택(Stack) - 활용 - 1]({% post_url 2025-10-04-[자료구조] 스택(Stack) - 활용 - 1 %})
- [[자료구조] 스택(Stack) - 활용 - 2]({% post_url 2025-10-04-[자료구조] 스택(Stack) - 활용 - 2 %})
- [[자료구조] 스택(Stack) - 활용 - 3]({% post_url 2025-10-04-[자료구조] 스택(Stack) - 활용 - 3 %})
- [[자료구조] 큐(Queue) - 기본 예제]({% post_url 2025-10-05-[자료구조] 큐(Queue) - 기본 예제 %})
- [[자료구조] 큐(Queue) - 활용 - 1]({% post_url 2025-10-05-[자료구조] 큐(Queue) - 활용 - 1 %})
- [[자료구조] 큐(Queue) - 활용 - 3]({% post_url 2025-10-05-[자료구조] 큐(Queue) - 활용 - 3 %})

# 📝 내용

## 개요

큐의 고급 활용에서는 우선순위 큐, 이중 큐(Deque), 스레드 풀, 그리고 큐를 이용한 고급 알고리즘 최적화 기법들을 다룹니다. 이러한 고급 기법들은 실제 시스템 개발과 복잡한 알고리즘 문제 해결에서 매우 중요한 역할을 합니다.

**다룰 고급 활용들:**
- **우선순위 큐 (Priority Queue)**: 힙 기반 구현과 응용
- **이중 큐 (Deque)**: 양방향 큐의 고급 활용
- **스레드 풀 (Thread Pool)**: 동시성 프로그래밍에서의 큐 활용
- **알고리즘 최적화**: BFS 최적화와 고급 기법들
- **고급 문제 해결**: 복잡한 알고리즘에서의 큐 활용

## 1. 우선순위 큐 (Priority Queue)

우선순위 큐는 각 원소가 우선순위를 가지며, 우선순위가 높은 원소가 먼저 처리되는 자료구조입니다. 일반적으로 힙(Heap)을 이용하여 구현합니다.

### 1-1 힙 기반 우선순위 큐 구현

```python
import heapq
from typing import List, Any, Tuple

class PriorityQueue:
    """
    우선순위 큐 구현 (최소 힙 기반)
    """
    def __init__(self):
        self._heap = []
        self._index = 0  # 동일한 우선순위에서 FIFO 순서 보장
    
    def __len__(self):
        """큐의 크기 반환"""
        return len(self._heap)
    
    def __str__(self):
        """큐를 문자열로 표현"""
        items = [(priority, item) for priority, index, item in self._heap]
        return f"PriorityQueue({items})"
    
    def is_empty(self):
        """큐가 비어있는지 확인 O(1)"""
        return len(self._heap) == 0
    
    def enqueue(self, item, priority=0):
        """
        우선순위 큐에 원소 추가 O(log n)
        Args:
            item: 추가할 원소
            priority: 우선순위 (낮은 값이 높은 우선순위)
        """
        # heapq는 최소 힙이므로 우선순위를 음수로 만들어 최대 힙 효과
        heapq.heappush(self._heap, (priority, self._index, item))
        self._index += 1
    
    def dequeue(self):
        """
        가장 높은 우선순위 원소 제거 및 반환 O(log n)
        Returns:
            tuple: (우선순위, 원소)
        """
        if self.is_empty():
            raise IndexError("Priority queue is empty")
        
        priority, index, item = heapq.heappop(self._heap)
        return priority, item
    
    def peek(self):
        """
        가장 높은 우선순위 원소 확인 (제거하지 않음) O(1)
        Returns:
            tuple: (우선순위, 원소)
        """
        if self.is_empty():
            raise IndexError("Priority queue is empty")
        
        priority, index, item = self._heap[0]
        return priority, item
    
    def update_priority(self, old_item, new_priority):
        """
        특정 원소의 우선순위 업데이트 O(n log n)
        Args:
            old_item: 우선순위를 변경할 원소
            new_priority: 새로운 우선순위
        """
        # 기존 원소 찾기 및 제거
        for i, (priority, index, item) in enumerate(self._heap):
            if item == old_item:
                self._heap[i] = self._heap[-1]
                self._heap.pop()
                heapq.heapify(self._heap)
                break
        
        # 새로운 우선순위로 추가
        self.enqueue(old_item, new_priority)

# 테스트
pq = PriorityQueue()

print("=== 우선순위 큐 테스트 ===")

# 원소 추가 (우선순위가 낮을수록 높은 우선순위)
pq.enqueue("높은 우선순위", 1)
pq.enqueue("중간 우선순위", 3)
pq.enqueue("가장 높은 우선순위", 0)
pq.enqueue("낮은 우선순위", 5)

print(f"큐 상태: {pq}")
print(f"크기: {len(pq)}")

# 우선순위 순으로 제거
print("\n우선순위 순으로 제거:")
while not pq.is_empty():
    priority, item = pq.dequeue()
    print(f"우선순위 {priority}: {item}")
```

### 1-2 Dijkstra 알고리즘에서의 우선순위 큐 활용

```python
from collections import defaultdict
import heapq

class Graph:
    """가중치 그래프 구현"""
    def __init__(self):
        self.graph = defaultdict(list)
    
    def add_edge(self, u, v, weight):
        """가중치 간선 추가"""
        self.graph[u].append((v, weight))
        self.graph[v].append((u, weight))  # 무방향 그래프
    
    def dijkstra(self, start):
        """
        Dijkstra 알고리즘으로 최단 경로 계산
        Args:
            start: 시작 정점
        Returns:
            dict: 각 정점까지의 최단 거리
        """
        # 거리 초기화 (무한대로 설정)
        distances = {vertex: float('inf') for vertex in self.graph}
        distances[start] = 0
        
        # 우선순위 큐 (거리, 정점)
        pq = [(0, start)]
        visited = set()
        
        print(f"Dijkstra 알고리즘 시작: 시작점 {start}")
        
        while pq:
            current_distance, current_vertex = heapq.heappop(pq)
            
            if current_vertex in visited:
                continue
            
            visited.add(current_vertex)
            print(f"방문: {current_vertex}, 거리: {current_distance}")
            
            # 인접한 정점들 확인
            for neighbor, weight in self.graph[current_vertex]:
                if neighbor not in visited:
                    distance = current_distance + weight
                    
                    # 더 짧은 경로 발견 시 업데이트
                    if distance < distances[neighbor]:
                        distances[neighbor] = distance
                        heapq.heappush(pq, (distance, neighbor))
                        print(f"  {neighbor} 거리 업데이트: {distance}")
        
        return distances
    
    def dijkstra_with_path(self, start, target):
        """
        Dijkstra 알고리즘으로 최단 경로와 경로 반환
        """
        distances = {vertex: float('inf') for vertex in self.graph}
        distances[start] = 0
        previous = {}
        
        pq = [(0, start)]
        visited = set()
        
        while pq:
            current_distance, current_vertex = heapq.heappop(pq)
            
            if current_vertex in visited:
                continue
            
            visited.add(current_vertex)
            
            if current_vertex == target:
                break
            
            for neighbor, weight in self.graph[current_vertex]:
                if neighbor not in visited:
                    distance = current_distance + weight
                    
                    if distance < distances[neighbor]:
                        distances[neighbor] = distance
                        previous[neighbor] = current_vertex
                        heapq.heappush(pq, (distance, neighbor))
        
        # 경로 재구성
        path = []
        current = target
        while current is not None:
            path.append(current)
            current = previous.get(current)
        
        path.reverse()
        
        return distances[target] if distances[target] != float('inf') else None, path

# 테스트
graph = Graph()
graph.add_edge('A', 'B', 4)
graph.add_edge('A', 'C', 2)
graph.add_edge('B', 'C', 1)
graph.add_edge('B', 'D', 5)
graph.add_edge('C', 'D', 8)
graph.add_edge('C', 'E', 10)
graph.add_edge('D', 'E', 2)

print("=== Dijkstra 알고리즘 테스트 ===")
print("그래프:")
for vertex, edges in graph.graph.items():
    print(f"{vertex}: {edges}")

print("\n최단 거리 계산 (A에서 시작):")
distances = graph.dijkstra('A')
for vertex, distance in distances.items():
    if distance != float('inf'):
        print(f"A -> {vertex}: {distance}")

print(f"\n최단 경로 (A -> E):")
distance, path = graph.dijkstra_with_path('A', 'E')
print(f"거리: {distance}, 경로: {' -> '.join(path)}")
```

### 1-3 A* 알고리즘에서의 우선순위 큐

```python
import heapq
from typing import List, Tuple, Optional

class AStarNode:
    """A* 알고리즘용 노드"""
    def __init__(self, position, g_cost=0, h_cost=0, parent=None):
        self.position = position
        self.g_cost = g_cost  # 시작점부터의 실제 비용
        self.h_cost = h_cost  # 휴리스틱 비용 (목표까지의 추정)
        self.parent = parent
    
    @property
    def f_cost(self):
        """총 비용 (g + h)"""
        return self.g_cost + self.h_cost
    
    def __lt__(self, other):
        """우선순위 큐를 위한 비교 연산자"""
        return self.f_cost < other.f_cost

class AStarPathfinder:
    """A* 경로 탐색 알고리즘"""
    
    def __init__(self, grid):
        """
        Args:
            grid: 2D 그리드 (0: 통과 가능, 1: 장애물)
        """
        self.grid = grid
        self.rows = len(grid)
        self.cols = len(grid[0]) if self.rows > 0 else 0
    
    def heuristic(self, pos1, pos2):
        """맨하탄 거리 휴리스틱"""
        return abs(pos1[0] - pos2[0]) + abs(pos1[1] - pos2[1])
    
    def get_neighbors(self, position):
        """인접한 위치들 반환"""
        row, col = position
        neighbors = []
        
        # 상하좌우 이동
        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]
        
        for dr, dc in directions:
            new_row, new_col = row + dr, col + dc
            
            if (0 <= new_row < self.rows and 
                0 <= new_col < self.cols and 
                self.grid[new_row][new_col] == 0):
                neighbors.append((new_row, new_col))
        
        return neighbors
    
    def find_path(self, start, goal):
        """
        A* 알고리즘으로 최단 경로 탐색
        Args:
            start: 시작 위치 (row, col)
            goal: 목표 위치 (row, col)
        Returns:
            list: 경로 (위치들의 리스트)
        """
        open_set = []  # 우선순위 큐
        closed_set = set()
        
        start_node = AStarNode(start, 0, self.heuristic(start, goal))
        heapq.heappush(open_set, start_node)
        
        print(f"A* 경로 탐색 시작: {start} -> {goal}")
        
        while open_set:
            current = heapq.heappop(open_set)
            
            if current.position in closed_set:
                continue
            
            closed_set.add(current.position)
            
            if current.position == goal:
                # 경로 재구성
                path = []
                while current:
                    path.append(current.position)
                    current = current.parent
                path.reverse()
                
                print(f"경로 탐색 완료: 길이 {len(path)}")
                return path
            
            # 인접한 노드들 확인
            for neighbor_pos in self.get_neighbors(current.position):
                if neighbor_pos in closed_set:
                    continue
                
                g_cost = current.g_cost + 1  # 이동 비용 (1로 가정)
                h_cost = self.heuristic(neighbor_pos, goal)
                
                # 기존에 더 좋은 경로가 있는지 확인
                existing_node = None
                for node in open_set:
                    if node.position == neighbor_pos:
                        existing_node = node
                        break
                
                if existing_node is None or g_cost < existing_node.g_cost:
                    neighbor_node = AStarNode(neighbor_pos, g_cost, h_cost, current)
                    heapq.heappush(open_set, neighbor_node)
        
        return None  # 경로를 찾을 수 없음

# 테스트
grid = [
    [0, 0, 0, 0, 1, 0, 0, 0],
    [0, 1, 1, 0, 1, 0, 1, 0],
    [0, 0, 0, 0, 0, 0, 1, 0],
    [0, 1, 0, 1, 1, 0, 1, 0],
    [0, 0, 0, 0, 0, 0, 0, 0],
]

print("=== A* 알고리즘 테스트 ===")
print("그리드 (0: 통과 가능, 1: 장애물):")
for row in grid:
    print(row)

pathfinder = AStarPathfinder(grid)
start = (0, 0)
goal = (4, 7)

path = pathfinder.find_path(start, goal)

if path:
    print(f"\n경로 발견: {path}")
    
    # 경로 시각화
    print("\n경로 시각화:")
    for i, row in enumerate(grid):
        line = ""
        for j, cell in enumerate(row):
            if (i, j) == start:
                line += "S "
            elif (i, j) == goal:
                line += "G "
            elif (i, j) in path:
                line += "* "
            elif cell == 1:
                line += "█ "
            else:
                line += "  "
        print(line)
else:
    print("경로를 찾을 수 없습니다.")
```

## 2. 이중 큐 (Deque) 고급 활용

이중 큐는 양쪽 끝에서 삽입과 삭제가 모두 가능한 자료구조입니다.

### 2-1 슬라이딩 윈도우 최적화

```python
from collections import deque

class SlidingWindowOptimizer:
    """슬라이딩 윈도우 최적화 클래스"""
    
    def max_sliding_window(self, nums, k):
        """
        슬라이딩 윈도우 최댓값 (덱 최적화)
        """
        if not nums or k <= 0:
            return []
        
        result = []
        dq = deque()  # 인덱스를 저장
        
        for i in range(len(nums)):
            # 윈도우 범위를 벗어난 인덱스 제거
            while dq and dq[0] <= i - k:
                dq.popleft()
            
            # 현재 원소보다 작은 원소들의 인덱스 제거
            while dq and nums[dq[-1]] <= nums[i]:
                dq.pop()
            
            dq.append(i)
            
            # 윈도우가 완성된 경우 최댓값 추가
            if i >= k - 1:
                result.append(nums[dq[0]])
        
        return result
    
    def min_sliding_window(self, nums, k):
        """
        슬라이딩 윈도우 최솟값
        """
        if not nums or k <= 0:
            return []
        
        result = []
        dq = deque()
        
        for i in range(len(nums)):
            while dq and dq[0] <= i - k:
                dq.popleft()
            
            while dq and nums[dq[-1]] >= nums[i]:
                dq.pop()
            
            dq.append(i)
            
            if i >= k - 1:
                result.append(nums[dq[0]])
        
        return result

# 테스트
optimizer = SlidingWindowOptimizer()

nums = [1, 3, -1, -3, 5, 3, 6, 7]
k = 3

print("=== 슬라이딩 윈도우 최적화 ===")
print(f"배열: {nums}, 윈도우 크기: {k}")

max_values = optimizer.max_sliding_window(nums, k)
min_values = optimizer.min_sliding_window(nums, k)

print(f"최댓값들: {max_values}")
print(f"최솟값들: {min_values}")
```

### 2-2 회전 배열 문제

```python
from collections import deque

class RotatingArray:
    """회전 배열 클래스"""
    
    def __init__(self, nums):
        self.deque = deque(nums)
    
    def rotate_right(self, k):
        """
        오른쪽으로 k만큼 회전
        """
        k = k % len(self.deque)
        for _ in range(k):
            self.deque.appendleft(self.deque.pop())
    
    def rotate_left(self, k):
        """
        왼쪽으로 k만큼 회전
        """
        k = k % len(self.deque)
        for _ in range(k):
            self.deque.append(self.deque.popleft())
    
    def get_array(self):
        """현재 배열 상태 반환"""
        return list(self.deque)
    
    def find_rotation_point(self, target):
        """
        회전된 정렬 배열에서 회전점 찾기
        """
        left, right = 0, len(self.deque) - 1
        
        while left < right:
            mid = (left + right) // 2
            
            if self.deque[mid] > self.deque[right]:
                left = mid + 1
            else:
                right = mid
        
        return left

# 테스트
print("=== 회전 배열 테스트 ===")
arr = RotatingArray([1, 2, 3, 4, 5, 6, 7])
print(f"초기 배열: {arr.get_array()}")

arr.rotate_right(3)
print(f"오른쪽 3회전: {arr.get_array()}")

arr.rotate_left(2)
print(f"왼쪽 2회전: {arr.get_array()}")
```

## 3. 스레드 풀 (Thread Pool)

동시성 프로그래밍에서 큐를 활용한 스레드 풀 구현입니다.

```python
import threading
import time
import queue
from concurrent.futures import ThreadPoolExecutor
import random

class SimpleThreadPool:
    """간단한 스레드 풀 구현"""
    
    def __init__(self, num_workers=4):
        self.num_workers = num_workers
        self.task_queue = queue.Queue()
        self.result_queue = queue.Queue()
        self.workers = []
        self.shutdown = False
        
        # 워커 스레드들 시작
        for i in range(num_workers):
            worker = threading.Thread(target=self._worker, args=(i,))
            worker.daemon = True
            worker.start()
            self.workers.append(worker)
    
    def _worker(self, worker_id):
        """워커 스레드 함수"""
        print(f"워커 {worker_id} 시작")
        
        while not self.shutdown:
            try:
                # 작업 대기 (타임아웃 설정)
                task = self.task_queue.get(timeout=1)
                
                if task is None:  # 종료 신호
                    break
                
                func, args, task_id = task
                print(f"워커 {worker_id}: 작업 {task_id} 시작")
                
                # 작업 실행
                result = func(*args)
                
                # 결과 저장
                self.result_queue.put((task_id, result))
                print(f"워커 {worker_id}: 작업 {task_id} 완료")
                
                self.task_queue.task_done()
                
            except queue.Empty:
                continue
            except Exception as e:
                print(f"워커 {worker_id}: 오류 발생 - {e}")
                self.task_queue.task_done()
        
        print(f"워커 {worker_id} 종료")
    
    def submit(self, func, *args, task_id=None):
        """작업 제출"""
        if task_id is None:
            task_id = f"task_{int(time.time() * 1000)}"
        
        self.task_queue.put((func, args, task_id))
        return task_id
    
    def get_result(self, timeout=None):
        """결과 가져오기"""
        return self.result_queue.get(timeout=timeout)
    
    def shutdown_pool(self):
        """스레드 풀 종료"""
        self.shutdown = True
        
        # 모든 워커에게 종료 신호 전송
        for _ in range(self.num_workers):
            self.task_queue.put(None)
        
        # 모든 워커 스레드 종료 대기
        for worker in self.workers:
            worker.join()

# 테스트 함수들
def cpu_intensive_task(n):
    """CPU 집약적 작업"""
    result = 0
    for i in range(n):
        result += i ** 2
    return result

def io_intensive_task(duration):
    """I/O 집약적 작업 (시뮬레이션)"""
    time.sleep(duration)
    return f"I/O 작업 완료 ({duration}초)"

def random_task(task_id):
    """랜덤 작업"""
    duration = random.uniform(0.5, 2.0)
    time.sleep(duration)
    return f"작업 {task_id} 완료 ({duration:.2f}초)"

# 테스트
print("=== 스레드 풀 테스트 ===")

# 간단한 스레드 풀 테스트
pool = SimpleThreadPool(num_workers=3)

# 작업들 제출
task_ids = []
for i in range(5):
    task_id = pool.submit(random_task, f"task_{i}")
    task_ids.append(task_id)

# 결과 수집
print("\n결과 수집:")
for _ in range(5):
    task_id, result = pool.get_result()
    print(f"결과: {result}")

# 스레드 풀 종료
pool.shutdown_pool()

# Python 내장 ThreadPoolExecutor 사용
print("\n=== ThreadPoolExecutor 테스트 ===")

def process_data(data):
    """데이터 처리 함수"""
    time.sleep(0.5)
    return f"처리됨: {data}"

with ThreadPoolExecutor(max_workers=4) as executor:
    # 작업들 제출
    futures = []
    for i in range(8):
        future = executor.submit(process_data, f"data_{i}")
        futures.append(future)
    
    # 결과 수집
    results = []
    for future in futures:
        result = future.result()
        results.append(result)
    
    print("처리 결과:")
    for result in results:
        print(result)
```

## 4. 고급 BFS 최적화

### 4-1 다중 시작점 BFS

```python
from collections import deque
from typing import List, Tuple

class MultiSourceBFS:
    """다중 시작점 BFS"""
    
    def __init__(self, grid):
        self.grid = grid
        self.rows = len(grid)
        self.cols = len(grid[0]) if self.rows > 0 else 0
    
    def multi_source_bfs(self, sources):
        """
        여러 시작점에서 동시에 BFS 실행
        Args:
            sources: 시작점들의 리스트 [(row, col), ...]
        Returns:
            dict: 각 위치까지의 최단 거리
        """
        distances = {}
        queue = deque()
        
        # 모든 시작점을 큐에 추가
        for source in sources:
            queue.append((source, 0))
            distances[source] = 0
        
        # BFS 실행
        while queue:
            (row, col), distance = queue.popleft()
            
            # 인접한 위치들 확인
            directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]
            
            for dr, dc in directions:
                new_row, new_col = row + dr, col + dc
                
                if (0 <= new_row < self.rows and 
                    0 <= new_col < self.cols and 
                    (new_row, new_col) not in distances and
                    self.grid[new_row][new_col] != 1):  # 장애물이 아닌 경우
                    
                    new_distance = distance + 1
                    distances[(new_row, new_col)] = new_distance
                    queue.append(((new_row, new_col), new_distance))
        
        return distances
    
    def find_nearest_source(self, target, sources):
        """
        목표 위치에서 가장 가까운 시작점 찾기
        """
        distances = self.multi_source_bfs(sources)
        
        if target in distances:
            return distances[target], target
        
        return float('inf'), None

# 테스트
grid = [
    [0, 0, 1, 0, 0],
    [0, 0, 1, 0, 0],
    [0, 0, 0, 0, 0],
    [0, 0, 1, 0, 0],
    [0, 0, 0, 0, 0],
]

print("=== 다중 시작점 BFS 테스트 ===")
print("그리드 (0: 통과 가능, 1: 장애물):")
for row in grid:
    print(row)

sources = [(0, 0), (4, 4), (2, 2)]
target = (1, 4)

bfs = MultiSourceBFS(grid)
distances = bfs.multi_source_bfs(sources)

print(f"\n시작점들: {sources}")
print(f"목표점: {target}")

print("\n각 위치까지의 최단 거리:")
for (row, col), distance in sorted(distances.items()):
    print(f"({row}, {col}): {distance}")

nearest_distance, nearest_source = bfs.find_nearest_source(target, sources)
print(f"\n목표점 {target}에서 가장 가까운 시작점: {nearest_source} (거리: {nearest_distance})")
```

### 4-2 0-1 BFS (가중치가 0 또는 1인 그래프)

```python
from collections import deque

class ZeroOneBFS:
    """0-1 BFS (가중치가 0 또는 1인 그래프용)"""
    
    def __init__(self, graph):
        """
        Args:
            graph: 인접 리스트 {vertex: [(neighbor, weight), ...]}
        """
        self.graph = graph
    
    def shortest_path(self, start, target):
        """
        0-1 BFS로 최단 경로 찾기
        """
        distances = {vertex: float('inf') for vertex in self.graph}
        distances[start] = 0
        
        # 덱 사용 (앞쪽: 가중치 0, 뒤쪽: 가중치 1)
        queue = deque([start])
        
        while queue:
            current = queue.popleft()
            
            if current == target:
                break
            
            for neighbor, weight in self.graph.get(current, []):
                new_distance = distances[current] + weight
                
                if new_distance < distances[neighbor]:
                    distances[neighbor] = new_distance
                    
                    if weight == 0:
                        # 가중치 0: 큐의 앞쪽에 추가
                        queue.appendleft(neighbor)
                    else:
                        # 가중치 1: 큐의 뒤쪽에 추가
                        queue.append(neighbor)
        
        return distances[target] if distances[target] != float('inf') else -1

# 테스트
graph = {
    'A': [('B', 1), ('C', 0)],
    'B': [('A', 1), ('D', 1)],
    'C': [('A', 0), ('D', 0)],
    'D': [('B', 1), ('C', 0), ('E', 1)],
    'E': [('D', 1)]
}

print("=== 0-1 BFS 테스트 ===")
print("그래프:")
for vertex, edges in graph.items():
    print(f"{vertex}: {edges}")

bfs_01 = ZeroOneBFS(graph)
start, target = 'A', 'E'

distance = bfs_01.shortest_path(start, target)
print(f"\n최단 거리 ({start} -> {target}): {distance}")
```

## 정리

이번 포스트에서는 큐의 고급 활용과 알고리즘 최적화 기법들을 살펴보았습니다.

**고급 활용 정리**
1. **우선순위 큐**: 힙 기반 구현, Dijkstra, A* 알고리즘에서의 활용
2. **이중 큐**: 슬라이딩 윈도우 최적화, 회전 배열 문제
3. **스레드 풀**: 동시성 프로그래밍에서의 큐 활용
4. **고급 BFS**: 다중 시작점 BFS, 0-1 BFS 등 최적화 기법
5. **알고리즘 최적화**: 복잡한 문제에서의 효율적인 큐 활용

**큐 고급 활용의 핵심 원칙**
- **우선순위 처리**: 우선순위 큐로 중요한 작업을 먼저 처리
- **양방향 처리**: 덱을 이용한 양방향 데이터 처리
- **동시성 관리**: 스레드 풀로 병렬 작업 관리
- **최적화**: 특수한 상황에서의 BFS 최적화 기법
- **복합 자료구조**: 큐와 다른 자료구조의 조합 활용

**실무에서의 고급 큐 활용**
- **운영체제**: 프로세스 스케줄링, 우선순위 기반 작업 처리
- **네트워크**: 패킷 처리, 라우팅 알고리즘
- **게임 개발**: A* 경로 탐색, AI 의사결정
- **시스템 설계**: 스레드 풀, 작업 큐, 이벤트 처리

**다음 학습 계획**
다음 포스트에서는 큐의 실무 활용과 실제 프로젝트에서의 적용 사례를 알아보겠습니다:
- [[학습] [자료구조] 큐(Queue) 활용 - 3. 실무 활용]({% post_url 2025-10-05-[자료구조] 큐(Queue) - 활용 - 3 %}) - 메시지 큐, 작업 큐, 이벤트 시스템, 캐싱 등

# 📚 레퍼런스
- [Priority Queue - Wikipedia](https://en.wikipedia.org/wiki/Priority_queue)
- [Dijkstra's Algorithm - Wikipedia](https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm)
- [A* Search Algorithm - Wikipedia](https://en.wikipedia.org/wiki/A*_search_algorithm)
- [Thread Pool Pattern - Wikipedia](https://en.wikipedia.org/wiki/Thread_pool_pattern)

---
*이 포스트는 자료구조 학습 과정을 정리한 내용입니다.*
