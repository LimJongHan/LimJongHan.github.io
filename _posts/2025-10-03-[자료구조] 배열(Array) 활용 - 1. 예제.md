---
layout: post
title: "[자료구조] 배열(Array) 활용 - 1. 예제"
date: 2025-10-03 01:45:00 +0900
categories: [자료구조, 배열]
tags: [배열, Array, 예제, 문제해결, 알고리즘, 코딩테스트]
author: LimJongHan
toc: true
---

# 📖 관련된 내 포스팅
- [[자료구조] 배열(Array)]({% post_url 2025-10-03-[자료구조] 배열(Array) %})
- [[자료구조] 배열(Array) 활용 - 2. 알고리즘 활용]({% post_url 2025-10-03-[자료구조] 배열(Array) 활용 - 2. 알고리즘 활용 %})
- [[자료구조] 배열(Array) 활용 - 3. 실무 활용]({% post_url 2025-10-03-[자료구조] 배열(Array) 활용 - 3. 실무 활용 %})

# 📝 내용

## 개요

이전 포스트에서 배열의 기본 개념과 구현에 대해 알아보았습니다. 이번 포스트에서는 배열을 활용한 실전 문제 해결 예제들을 다뤄보겠습니다.

**이번 포스트에서 다룰 예제들:**
- 🎯 **가장 큰 두 수 찾기**: 효율적인 알고리즘 설계
- 🔄 **회문(Palindromes) 찾기**: 문자열 처리와 배열 탐색
- 📊 **이진 배열 정렬**: Dutch National Flag 문제
- 🔍 **부분 배열 합 찾기**: 다양한 해결 방법 비교

이러한 예제들은 코딩 테스트나 면접에서 자주 등장하는 문제들로, 배열의 기본 개념을 실제 문제에 적용하는 방법을 학습할 수 있습니다.

## 핵심 내용

### 1. 정수 배열에서 가장 큰 두 수 찾기

**문제**: 정수 배열에서 가장 큰 두 수를 찾아보세요.

#### 1-1 효율적인 해결 방법

```python
def find_two_largest(numbers):
    """
    정수 배열에서 가장 큰 두 수를 찾는 함수
    
    Args:
        numbers (list): 정수 배열
        
    Returns:
        tuple: (가장 큰 수, 두 번째로 큰 수)
    """
    if len(numbers) < 2:
        raise ValueError("배열에는 최소 2개의 원소가 필요합니다")
    
    # 첫 번째와 두 번째 원소로 초기화
    if numbers[0] >= numbers[1]:
        largest = numbers[0]
        second_largest = numbers[1]
    else:
        largest = numbers[1]
        second_largest = numbers[0]
    
    # 나머지 원소들 확인
    for i in range(2, len(numbers)):
        if numbers[i] > largest:
            # 새로운 가장 큰 수 발견
            second_largest = largest
            largest = numbers[i]
        elif numbers[i] > second_largest:
            # 두 번째로 큰 수 갱신
            second_largest = numbers[i]
    
    return largest, second_largest

# 테스트
numbers = [3, 7, 2, 9, 1, 8, 5]
largest, second = find_two_largest(numbers)
print(f"배열: {numbers}")
print(f"가장 큰 수: {largest}, 두 번째로 큰 수: {second}")

# 시간복잡도: O(n), 공간복잡도: O(1)
```

#### 1-2 다른 해결 방법들 비교

```python
# 방법 2: 정렬 사용 (간단하지만 비효율적)
def find_two_largest_sorting(numbers):
    """정렬을 사용한 방법"""
    sorted_numbers = sorted(numbers, reverse=True)
    return sorted_numbers[0], sorted_numbers[1]
# 시간복잡도: O(n log n), 공간복잡도: O(n)

# 방법 3: max() 함수 사용
def find_two_largest_max(numbers):
    """max() 함수를 사용한 방법"""
    largest = max(numbers)
    # 가장 큰 수를 제거하고 두 번째로 큰 수 찾기
    numbers_copy = numbers.copy()
    numbers_copy.remove(largest)
    second_largest = max(numbers_copy)
    return largest, second_largest
# 시간복잡도: O(n), 하지만 원본 배열 수정됨

# 방법 4: 힙 사용 (고급 기법)
import heapq

def find_two_largest_heap(numbers):
    """힙을 사용한 방법"""
    if len(numbers) < 2:
        raise ValueError("배열에는 최소 2개의 원소가 필요합니다")
    
    # 최대 힙으로 변환 (음수 사용)
    max_heap = [-x for x in numbers]
    heapq.heapify(max_heap)
    
    largest = -heapq.heappop(max_heap)
    second_largest = -heapq.heappop(max_heap)
    
    return largest, second_largest
# 시간복잡도: O(n log n), 공간복잡도: O(n)

# 성능 비교 테스트
import time
import random

def performance_comparison():
    """성능 비교 테스트"""
    sizes = [1000, 10000, 100000]
    
    for size in sizes:
        # 테스트 데이터 생성
        test_data = [random.randint(1, 1000) for _ in range(size)]
        
        print(f"\n배열 크기: {size}")
        
        # 방법 1: 효율적인 방법
        start = time.time()
        result1 = find_two_largest(test_data.copy())
        time1 = time.time() - start
        print(f"효율적인 방법: {time1:.6f}초")
        
        # 방법 2: 정렬 방법
        start = time.time()
        result2 = find_two_largest_sorting(test_data.copy())
        time2 = time.time() - start
        print(f"정렬 방법: {time2:.6f}초")
        
        # 방법 3: max() 함수 방법
        start = time.time()
        result3 = find_two_largest_max(test_data.copy())
        time3 = time.time() - start
        print(f"max() 함수 방법: {time3:.6f}초")

# 성능 테스트 실행
if __name__ == "__main__":
    performance_comparison()
```

### 2. 회문(Palindromes) 찾기

**문제**: 주어진 문자열이 회문인지 확인하고, 배열에서 회문들을 찾아보세요.

#### 2-1 회문 확인 함수

```python
def is_palindrome(text):
    """
    주어진 문자열이 회문인지 확인하는 함수
    
    Args:
        text (str): 확인할 문자열
        
    Returns:
        bool: 회문이면 True, 아니면 False
    """
    # 공백과 대소문자 무시
    cleaned = ''.join(text.lower().split())
    
    left = 0
    right = len(cleaned) - 1
    
    while left < right:
        if cleaned[left] != cleaned[right]:
            return False
        left += 1
        right -= 1
    
    return True

def is_palindrome_recursive(text, left=0, right=None):
    """
    재귀를 사용한 회문 확인 함수
    
    Args:
        text (str): 확인할 문자열
        left (int): 시작 인덱스
        right (int): 끝 인덱스
        
    Returns:
        bool: 회문이면 True, 아니면 False
    """
    if right is None:
        right = len(text) - 1
    
    # 공백과 대소문자 무시
    while left < right and not text[left].isalnum():
        left += 1
    while left < right and not text[right].isalnum():
        right -= 1
    
    if left >= right:
        return True
    
    if text[left].lower() != text[right].lower():
        return False
    
    return is_palindrome_recursive(text, left + 1, right - 1)

def is_palindrome_simple(text):
    """
    가장 간단한 회문 확인 방법
    
    Args:
        text (str): 확인할 문자열
        
    Returns:
        bool: 회문이면 True, 아니면 False
    """
    cleaned = ''.join(char.lower() for char in text if char.isalnum())
    return cleaned == cleaned[::-1]
```

#### 2-2 배열에서 회문 찾기

```python
def find_palindromes_in_array(texts):
    """
    배열에서 회문들을 찾는 함수
    
    Args:
        texts (list): 문자열 배열
        
    Returns:
        list: 회문인 문자열들의 리스트
    """
    palindromes = []
    for text in texts:
        if is_palindrome(text):
            palindromes.append(text)
    return palindromes

def find_palindromes_with_index(texts):
    """
    배열에서 회문들을 찾고 인덱스와 함께 반환
    
    Args:
        texts (list): 문자열 배열
        
    Returns:
        list: (인덱스, 문자열) 튜플의 리스트
    """
    palindromes = []
    for i, text in enumerate(texts):
        if is_palindrome(text):
            palindromes.append((i, text))
    return palindromes

def count_palindromes(texts):
    """
    배열에서 회문의 개수를 세는 함수
    
    Args:
        texts (list): 문자열 배열
        
    Returns:
        int: 회문의 개수
    """
    count = 0
    for text in texts:
        if is_palindrome(text):
            count += 1
    return count

# 테스트
test_strings = ["racecar", "hello", "level", "python", "madam", "world", "A man a plan a canal Panama"]
print(f"입력: {test_strings}")

# 회문 찾기
palindromes = find_palindromes_in_array(test_strings)
print(f"회문: {palindromes}")

# 인덱스와 함께 찾기
palindromes_with_index = find_palindromes_with_index(test_strings)
print(f"회문 (인덱스 포함): {palindromes_with_index}")

# 회문 개수 세기
count = count_palindromes(test_strings)
print(f"회문 개수: {count}")

# 시간복잡도: O(n*m) (n은 문자열 개수, m은 평균 문자열 길이)
```

### 3. 0과 1로 구성된 배열 정렬하기 (Dutch National Flag 문제)

**문제**: 0과 1로만 구성된 배열을 정렬해보세요.

#### 3-1 두 포인터 기법 사용

```python
def sort_binary_array(arr):
    """
    0과 1로만 구성된 배열을 정렬하는 함수 (두 포인터 사용)
    
    Args:
        arr (list): 0과 1로만 구성된 배열
        
    Returns:
        list: 정렬된 배열
    """
    left = 0
    right = len(arr) - 1
    
    while left < right:
        # 왼쪽에서 1을 찾음
        while left < right and arr[left] == 0:
            left += 1
        
        # 오른쪽에서 0을 찾음
        while left < right and arr[right] == 1:
            right -= 1
        
        # 1과 0을 교환
        if left < right:
            arr[left], arr[right] = arr[right], arr[left]
            left += 1
            right -= 1
    
    return arr

def sort_binary_array_optimized(arr):
    """
    최적화된 두 포인터 기법
    
    Args:
        arr (list): 0과 1로만 구성된 배열
        
    Returns:
        list: 정렬된 배열
    """
    zero_pos = 0
    
    # 0을 앞쪽으로 이동
    for i in range(len(arr)):
        if arr[i] == 0:
            arr[i], arr[zero_pos] = arr[zero_pos], arr[i]
            zero_pos += 1
    
    return arr
```

#### 3-2 카운팅 기법 사용

```python
def sort_binary_array_counting(arr):
    """
    카운팅 방식으로 0과 1 배열 정렬
    
    Args:
        arr (list): 0과 1로만 구성된 배열
        
    Returns:
        list: 정렬된 배열
    """
    # 0의 개수 세기
    count_zeros = arr.count(0)
    
    # 앞쪽에 0들, 뒤쪽에 1들 배치
    result = [0] * count_zeros + [1] * (len(arr) - count_zeros)
    return result

def sort_binary_array_counting_inplace(arr):
    """
    제자리에서 카운팅 방식으로 정렬
    
    Args:
        arr (list): 0과 1로만 구성된 배열
        
    Returns:
        list: 정렬된 배열
    """
    count_zeros = 0
    
    # 0의 개수 세기
    for num in arr:
        if num == 0:
            count_zeros += 1
    
    # 배열을 0과 1로 채우기
    for i in range(len(arr)):
        if i < count_zeros:
            arr[i] = 0
        else:
            arr[i] = 1
    
    return arr
```

#### 3-3 성능 비교 테스트

```python
import time
import random

def test_binary_sorting_performance():
    """이진 배열 정렬 성능 테스트"""
    sizes = [1000, 10000, 100000]
    
    for size in sizes:
        # 테스트 데이터 생성
        test_data = [random.randint(0, 1) for _ in range(size)]
        
        print(f"\n배열 크기: {size}")
        
        # 방법 1: 두 포인터
        start = time.time()
        result1 = sort_binary_array(test_data.copy())
        time1 = time.time() - start
        print(f"두 포인터: {time1:.6f}초")
        
        # 방법 2: 최적화된 두 포인터
        start = time.time()
        result2 = sort_binary_array_optimized(test_data.copy())
        time2 = time.time() - start
        print(f"최적화된 두 포인터: {time2:.6f}초")
        
        # 방법 3: 카운팅
        start = time.time()
        result3 = sort_binary_array_counting(test_data.copy())
        time3 = time.time() - start
        print(f"카운팅: {time3:.6f}초")
        
        # 방법 4: 제자리 카운팅
        start = time.time()
        result4 = sort_binary_array_counting_inplace(test_data.copy())
        time4 = time.time() - start
        print(f"제자리 카운팅: {time4:.6f}초")

# 테스트 실행
if __name__ == "__main__":
    # 기본 테스트
    binary_array = [1, 0, 1, 0, 1, 0, 0, 1]
    print(f"원본: {binary_array}")
    
    print("두 포인터:", sort_binary_array(binary_array.copy()))
    print("카운팅:", sort_binary_array_counting(binary_array.copy()))
    
    # 성능 테스트
    test_binary_sorting_performance()
```

### 4. 제시된 합을 가진 부분 배열 찾기

**문제**: 주어진 합을 가진 부분 배열을 찾아보세요.

#### 4-1 기본 해결 방법

```python
def find_subarray_with_sum(arr, target_sum):
    """
    주어진 합을 가진 부분 배열을 찾는 함수 (첫 번째만 반환)
    
    Args:
        arr (list): 정수 배열
        target_sum (int): 찾고자 하는 합
        
    Returns:
        tuple: (시작 인덱스, 끝 인덱스) 또는 (-1, -1)
    """
    for i in range(len(arr)):
        current_sum = 0
        for j in range(i, len(arr)):
            current_sum += arr[j]
            if current_sum == target_sum:
                return i, j
            elif current_sum > target_sum:
                break
    return -1, -1

def find_all_subarrays_with_sum(arr, target_sum):
    """
    주어진 합을 가진 모든 부분 배열을 찾는 함수
    
    Args:
        arr (list): 정수 배열
        target_sum (int): 찾고자 하는 합
        
    Returns:
        list: 모든 부분 배열의 (시작, 끝) 인덱스 튜플 리스트
    """
    result = []
    for i in range(len(arr)):
        current_sum = 0
        for j in range(i, len(arr)):
            current_sum += arr[j]
            if current_sum == target_sum:
                result.append((i, j))
            elif current_sum > target_sum:
                break
    return result
```

#### 4-2 슬라이딩 윈도우 최적화 (양수 배열)

```python
def find_subarray_with_sum_optimized(arr, target_sum):
    """
    슬라이딩 윈도우를 사용한 최적화된 버전 (양수 배열에만 적용)
    
    Args:
        arr (list): 양수 배열
        target_sum (int): 찾고자 하는 합
        
    Returns:
        tuple: (시작 인덱스, 끝 인덱스) 또는 (-1, -1)
    """
    left = 0
    current_sum = 0
    
    for right in range(len(arr)):
        current_sum += arr[right]
        
        # 합이 목표보다 크면 왼쪽 포인터 이동
        while current_sum > target_sum and left <= right:
            current_sum -= arr[left]
            left += 1
        
        # 목표 합을 찾았으면 반환
        if current_sum == target_sum:
            return left, right
    
    return -1, -1

def find_subarray_with_sum_hashmap(arr, target_sum):
    """
    해시맵을 사용한 방법 (음수 포함 가능)
    
    Args:
        arr (list): 정수 배열 (음수 포함 가능)
        target_sum (int): 찾고자 하는 합
        
    Returns:
        tuple: (시작 인덱스, 끝 인덱스) 또는 (-1, -1)
    """
    prefix_sum = 0
    sum_map = {0: -1}  # 합이 0인 경우 인덱스 -1
    
    for i, num in enumerate(arr):
        prefix_sum += num
        
        # 현재 합에서 목표 합을 뺀 값이 이전에 있었는지 확인
        if prefix_sum - target_sum in sum_map:
            start_index = sum_map[prefix_sum - target_sum] + 1
            return start_index, i
        
        sum_map[prefix_sum] = i
    
    return -1, -1
```

#### 4-3 성능 비교 테스트

```python
def test_subarray_sum_performance():
    """부분 배열 합 찾기 성능 테스트"""
    sizes = [1000, 5000, 10000]
    
    for size in sizes:
        # 양수 배열 생성
        positive_arr = [random.randint(1, 10) for _ in range(size)]
        target = size * 2  # 적절한 목표값 설정
        
        print(f"\n배열 크기: {size}")
        
        # 방법 1: 기본 방법
        start = time.time()
        result1 = find_subarray_with_sum(positive_arr.copy(), target)
        time1 = time.time() - start
        print(f"기본 방법: {time1:.6f}초")
        
        # 방법 2: 슬라이딩 윈도우
        start = time.time()
        result2 = find_subarray_with_sum_optimized(positive_arr.copy(), target)
        time2 = time.time() - start
        print(f"슬라이딩 윈도우: {time2:.6f}초")
        
        # 방법 3: 해시맵
        start = time.time()
        result3 = find_subarray_with_sum_hashmap(positive_arr.copy(), target)
        time3 = time.time() - start
        print(f"해시맵: {time3:.6f}초")

# 테스트 실행
if __name__ == "__main__":
    # 기본 테스트
    test_array = [1, 4, 20, 3, 10, 5]
    target = 33
    
    print(f"배열: {test_array}")
    print(f"목표 합: {target}")
    
    # 기본 버전
    start, end = find_subarray_with_sum(test_array, target)
    if start != -1:
        print(f"부분 배열: {test_array[start:end+1]} (인덱스 {start}-{end})")
    else:
        print("해당 합을 가진 부분 배열이 없습니다")
    
    # 슬라이딩 윈도우 버전
    start, end = find_subarray_with_sum_optimized(test_array, target)
    if start != -1:
        print(f"슬라이딩 윈도우 결과: {test_array[start:end+1]} (인덱스 {start}-{end})")
    
    # 모든 부분 배열 찾기
    all_subarrays = find_all_subarrays_with_sum([1, 2, 3, 4, 5], 9)
    print(f"합이 9인 모든 부분 배열: {all_subarrays}")
    
    # 성능 테스트
    test_subarray_sum_performance()
```

## 정리

이번 포스트에서는 배열을 활용한 실전 문제 해결 예제들을 다뤘습니다:

**핵심 문제 해결 패턴**
1. **가장 큰 두 수 찾기**: 한 번의 순회로 O(n) 시간에 해결
2. **회문 찾기**: 두 포인터 기법으로 효율적 검사
3. **이진 배열 정렬**: 두 포인터 vs 카운팅 방법 비교
4. **부분 배열 합 찾기**: 기본 O(n²)에서 슬라이딩 윈도우 O(n)로 최적화

**알고리즘 설계 원칙**
- 🎯 **효율성**: 문제 특성에 맞는 최적의 시간복잡도 선택
- 🔄 **다양한 접근**: 같은 문제에 대한 여러 해결 방법 제시
- 📊 **성능 비교**: 각 방법의 장단점과 성능 분석
- 🚀 **최적화**: 불필요한 연산 제거와 알고리즘 개선

**실무 적용 포인트**
- 코딩 테스트와 면접에서 자주 등장하는 문제 패턴
- 배열 처리의 기본적인 알고리즘 설계 능력
- 성능 분석과 최적화 사고력 향상

**다음 학습 계획**
다음 포스트에서는 더 고급 알고리즘 기법들에 대해 알아보겠습니다:
- [[자료구조] 배열(Array) 활용 - 2. 알고리즘 활용]({% post_url 2025-10-03-[자료구조] 배열(Array) 활용 - 2. 알고리즘 활용 %}) - 두 포인터, 슬라이딩 윈도우 등 고급 기법

# 📚 레퍼런스
- [좌충우돌, 파이썬으로 자료구조 구현하기 - 위키독스](https://wikidocs.net/189478)
- [Array Problems - LeetCode](https://leetcode.com/tag/array/)
- [Dutch National Flag Problem - GeeksforGeeks](https://www.geeksforgeeks.org/sort-an-array-of-0s-1s-and-2s/)

---
*이 포스트는 자료구조 학습 과정을 정리한 내용입니다.*
