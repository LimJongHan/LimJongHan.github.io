---
layout: post
title: "[학습] [자료구조] 배열(Array) 활용 - 2. 알고리즘 활용"
date: 2025-10-03 01:50:00 +0900
categories: [학습, 자료구조]
tags: [배열, Array, 알고리즘, 두포인터, 슬라이딩윈도우, 해시맵, 최적화]
author: LimJongHan
toc: true
---

# 📖 관련된 내 포스팅
- [[학습] [자료구조] 배열(Array)]({% post_url 2025-10-03-배열(Array) %})
- [[학습] [자료구조] 배열(Array) 활용 - 1. 예제]({% post_url 2025-10-03-배열(Array)-활용-1-예제 %})
- [[학습] [자료구조] 배열(Array) 활용 - 3. 실무 활용]({% post_url 2025-10-03-배열(Array)-활용-3-실무-활용 %})

# 📝 내용

## 개요

이전 포스트에서 배열을 활용한 기본 문제 해결 예제들을 다뤘습니다. 이번 포스트에서는 배열 문제를 해결하는 핵심 알고리즘 기법들에 대해 자세히 알아보겠습니다.

**이번 포스트에서 다룰 알고리즘 기법들:**
- 🎯 **두 포인터 기법**: 양 끝에서 시작하여 조건에 따라 포인터 이동
- 🔄 **슬라이딩 윈도우**: 고정 크기 윈도우를 이동시키며 최적화
- 🗂️ **해시맵 활용**: 키-값 쌍을 이용한 효율적인 검색
- ⚡ **최적화 기법**: 시간복잡도와 공간복잡도 개선 방법

이러한 기법들은 배열 관련 문제를 효율적으로 해결하는 핵심 도구들입니다.

## 핵심 내용

### 1. 두 포인터 기법 (Two Pointers Technique)

**두 포인터 기법**은 배열의 양 끝에서 시작하여 조건에 따라 포인터를 이동시키는 알고리즘 기법입니다.

#### 1-1 기본 개념과 패턴

```python
def two_pointers_basic_pattern(arr):
    """
    두 포인터 기법의 기본 패턴
    
    Args:
        arr (list): 정렬된 배열
        
    Returns:
        bool: 조건을 만족하는 쌍이 있는지 여부
    """
    left = 0
    right = len(arr) - 1
    
    while left < right:
        # 현재 상태 확인
        current_sum = arr[left] + arr[right]
        
        if current_sum == target:
            return True
        elif current_sum < target:
            left += 1  # 합이 작으면 왼쪽 포인터 이동
        else:
            right -= 1  # 합이 크면 오른쪽 포인터 이동
    
    return False
```

#### 1-2 정렬된 배열에서 두 수의 합 찾기

```python
def two_sum_sorted(arr, target):
    """
    정렬된 배열에서 두 수의 합이 target이 되는 인덱스 찾기
    
    Args:
        arr (list): 정렬된 정수 배열
        target (int): 목표 합
        
    Returns:
        tuple: (인덱스1, 인덱스2) 또는 (-1, -1)
    """
    left = 0
    right = len(arr) - 1
    
    while left < right:
        current_sum = arr[left] + arr[right]
        
        if current_sum == target:
            return left, right
        elif current_sum < target:
            left += 1
        else:
            right -= 1
    
    return -1, -1

def two_sum_sorted_all_pairs(arr, target):
    """
    정렬된 배열에서 두 수의 합이 target이 되는 모든 쌍 찾기
    
    Args:
        arr (list): 정렬된 정수 배열
        target (int): 목표 합
        
    Returns:
        list: 모든 쌍의 (인덱스1, 인덱스2) 튜플 리스트
    """
    left = 0
    right = len(arr) - 1
    pairs = []
    
    while left < right:
        current_sum = arr[left] + arr[right]
        
        if current_sum == target:
            pairs.append((left, right))
            # 중복 값 처리
            while left < right and arr[left] == arr[left + 1]:
                left += 1
            while left < right and arr[right] == arr[right - 1]:
                right -= 1
            left += 1
            right -= 1
        elif current_sum < target:
            left += 1
        else:
            right -= 1
    
    return pairs

# 테스트
sorted_arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]
target = 10

print(f"배열: {sorted_arr}")
print(f"목표 합: {target}")

# 첫 번째 쌍 찾기
index1, index2 = two_sum_sorted(sorted_arr, target)
if index1 != -1:
    print(f"첫 번째 쌍: 인덱스 {index1}, {index2} (값: {sorted_arr[index1]}, {sorted_arr[index2]})")

# 모든 쌍 찾기
all_pairs = two_sum_sorted_all_pairs(sorted_arr, target)
print(f"모든 쌍: {all_pairs}")
```

#### 1-3 중복 제거하기

```python
def remove_duplicates_sorted(arr):
    """
    정렬된 배열에서 중복 제거하기
    
    Args:
        arr (list): 정렬된 배열
        
    Returns:
        int: 중복 제거 후 배열의 길이
    """
    if not arr:
        return 0
    
    slow = 0
    for fast in range(1, len(arr)):
        if arr[fast] != arr[slow]:
            slow += 1
            arr[slow] = arr[fast]
    
    return slow + 1

def remove_duplicates_at_most_two(arr):
    """
    정렬된 배열에서 최대 2개까지만 중복 허용
    
    Args:
        arr (list): 정렬된 배열
        
    Returns:
        int: 수정 후 배열의 길이
    """
    if len(arr) <= 2:
        return len(arr)
    
    slow = 2
    for fast in range(2, len(arr)):
        if arr[fast] != arr[slow - 2]:
            arr[slow] = arr[fast]
            slow += 1
    
    return slow

# 테스트
test_arr1 = [1, 1, 2, 2, 2, 3, 4, 4, 5]
print(f"원본: {test_arr1}")
new_length = remove_duplicates_sorted(test_arr1.copy())
print(f"중복 제거 후: {test_arr1[:new_length]}")

test_arr2 = [1, 1, 1, 2, 2, 3]
print(f"원본: {test_arr2}")
new_length = remove_duplicates_at_most_two(test_arr2.copy())
print(f"최대 2개 중복 허용: {test_arr2[:new_length]}")
```

### 2. 슬라이딩 윈도우 기법 (Sliding Window Technique)

**슬라이딩 윈도우**는 고정된 크기의 윈도우를 배열 위에서 이동시키며 문제를 해결하는 기법입니다.

#### 2-1 고정 크기 윈도우

```python
def max_sum_subarray_fixed_window(arr, k):
    """
    크기가 k인 부분 배열의 최대 합 찾기
    
    Args:
        arr (list): 정수 배열
        k (int): 부분 배열의 크기
        
    Returns:
        int: 최대 합
    """
    if len(arr) < k:
        return -1
    
    # 첫 번째 윈도우의 합
    window_sum = sum(arr[:k])
    max_sum = window_sum
    
    # 윈도우를 한 칸씩 이동
    for i in range(k, len(arr)):
        window_sum = window_sum - arr[i - k] + arr[i]
        max_sum = max(max_sum, window_sum)
    
    return max_sum

def max_sum_subarray_fixed_window_with_index(arr, k):
    """
    크기가 k인 부분 배열의 최대 합과 인덱스 찾기
    
    Args:
        arr (list): 정수 배열
        k (int): 부분 배열의 크기
        
    Returns:
        tuple: (최대 합, 시작 인덱스)
    """
    if len(arr) < k:
        return -1, -1
    
    # 첫 번째 윈도우의 합
    window_sum = sum(arr[:k])
    max_sum = window_sum
    max_index = 0
    
    # 윈도우를 한 칸씩 이동
    for i in range(k, len(arr)):
        window_sum = window_sum - arr[i - k] + arr[i]
        if window_sum > max_sum:
            max_sum = window_sum
            max_index = i - k + 1
    
    return max_sum, max_index

# 테스트
arr = [1, 4, 2, 10, 23, 3, 1, 0, 20]
k = 4

print(f"배열: {arr}")
print(f"윈도우 크기: {k}")

max_sum = max_sum_subarray_fixed_window(arr, k)
print(f"최대 합: {max_sum}")

max_sum, start_index = max_sum_subarray_fixed_window_with_index(arr, k)
print(f"최대 합: {max_sum}, 시작 인덱스: {start_index}")
print(f"해당 부분 배열: {arr[start_index:start_index + k]}")
```

#### 2-2 가변 크기 윈도우

```python
def longest_substring_without_repeating(s):
    """
    중복 문자가 없는 가장 긴 부분 문자열의 길이 찾기
    
    Args:
        s (str): 문자열
        
    Returns:
        int: 가장 긴 부분 문자열의 길이
    """
    char_set = set()
    left = 0
    max_length = 0
    
    for right in range(len(s)):
        # 중복 문자가 있으면 왼쪽 포인터 이동
        while s[right] in char_set:
            char_set.remove(s[left])
            left += 1
        
        char_set.add(s[right])
        max_length = max(max_length, right - left + 1)
    
    return max_length

def longest_substring_without_repeating_detailed(s):
    """
    중복 문자가 없는 가장 긴 부분 문자열의 상세 정보
    
    Args:
        s (str): 문자열
        
    Returns:
        dict: 길이, 시작 인덱스, 부분 문자열 정보
    """
    char_set = set()
    left = 0
    max_length = 0
    max_start = 0
    
    for right in range(len(s)):
        # 중복 문자가 있으면 왼쪽 포인터 이동
        while s[right] in char_set:
            char_set.remove(s[left])
            left += 1
        
        char_set.add(s[right])
        
        if right - left + 1 > max_length:
            max_length = right - left + 1
            max_start = left
    
    return {
        'length': max_length,
        'start_index': max_start,
        'substring': s[max_start:max_start + max_length]
    }

def min_window_substring(s, t):
    """
    문자열 s에서 문자열 t의 모든 문자를 포함하는 최소 윈도우 찾기
    
    Args:
        s (str): 원본 문자열
        t (str): 찾고자 하는 문자들의 집합
        
    Returns:
        str: 최소 윈도우 문자열
    """
    if not s or not t or len(s) < len(t):
        return ""
    
    # t의 문자 개수 카운트
    t_count = {}
    for char in t:
        t_count[char] = t_count.get(char, 0) + 1
    
    left = 0
    min_len = float('inf')
    min_start = 0
    matched = 0
    
    for right in range(len(s)):
        # 오른쪽 문자 처리
        if s[right] in t_count:
            t_count[s[right]] -= 1
            if t_count[s[right]] >= 0:
                matched += 1
        
        # 모든 문자가 매치되면 왼쪽 포인터 이동
        while matched == len(t):
            if right - left + 1 < min_len:
                min_len = right - left + 1
                min_start = left
            
            if s[left] in t_count:
                t_count[s[left]] += 1
                if t_count[s[left]] > 0:
                    matched -= 1
            
            left += 1
    
    return s[min_start:min_start + min_len] if min_len != float('inf') else ""

# 테스트
test_string = "abcabcbb"
print(f"문자열: {test_string}")
max_length = longest_substring_without_repeating(test_string)
print(f"중복 없는 가장 긴 부분 문자열 길이: {max_length}")

detailed_info = longest_substring_without_repeating_detailed(test_string)
print(f"상세 정보: {detailed_info}")

# 최소 윈도우 테스트
s = "ADOBECODEBANC"
t = "ABC"
min_window = min_window_substring(s, t)
print(f"원본: {s}")
print(f"찾는 문자: {t}")
print(f"최소 윈도우: {min_window}")
```

### 3. 해시맵을 활용한 최적화

해시맵을 사용하면 배열 문제의 시간복잡도를 크게 개선할 수 있습니다.

#### 3-1 부분 배열 합 문제

```python
def subarray_sum_hashmap(arr, target):
    """
    해시맵을 사용한 부분 배열 합 찾기 (음수 포함 가능)
    
    Args:
        arr (list): 정수 배열 (음수 포함 가능)
        target (int): 찾고자 하는 합
        
    Returns:
        tuple: (시작 인덱스, 끝 인덱스) 또는 (-1, -1)
    """
    prefix_sum = 0
    sum_map = {0: -1}  # 합이 0인 경우 인덱스 -1
    
    for i, num in enumerate(arr):
        prefix_sum += num
        
        # 현재 합에서 목표 합을 뺀 값이 이전에 있었는지 확인
        if prefix_sum - target in sum_map:
            start_index = sum_map[prefix_sum - target] + 1
            return start_index, i
        
        sum_map[prefix_sum] = i
    
    return -1, -1

def subarray_sum_hashmap_all(arr, target):
    """
    해시맵을 사용한 모든 부분 배열 합 찾기
    
    Args:
        arr (list): 정수 배열
        target (int): 찾고자 하는 합
        
    Returns:
        list: 모든 부분 배열의 (시작, 끝) 인덱스 튜플 리스트
    """
    prefix_sum = 0
    sum_map = {0: [-1]}  # 합이 0인 경우 인덱스 리스트
    result = []
    
    for i, num in enumerate(arr):
        prefix_sum += num
        
        # 현재 합에서 목표 합을 뺀 값이 이전에 있었는지 확인
        if prefix_sum - target in sum_map:
            for start_index in sum_map[prefix_sum - target]:
                result.append((start_index + 1, i))
        
        # 현재 prefix_sum을 맵에 추가
        if prefix_sum not in sum_map:
            sum_map[prefix_sum] = []
        sum_map[prefix_sum].append(i)
    
    return result

# 테스트
test_arr = [1, -1, 0, 1, -1, 0]
target = 0

print(f"배열: {test_arr}")
print(f"목표 합: {target}")

# 첫 번째 부분 배열 찾기
start, end = subarray_sum_hashmap(test_arr, target)
if start != -1:
    print(f"첫 번째 부분 배열: {test_arr[start:end+1]} (인덱스 {start}-{end})")

# 모든 부분 배열 찾기
all_subarrays = subarray_sum_hashmap_all(test_arr, target)
print(f"모든 부분 배열: {all_subarrays}")
for start, end in all_subarrays:
    print(f"  {test_arr[start:end+1]} (인덱스 {start}-{end})")
```

#### 3-2 두 수의 합 문제 (해시맵 버전)

```python
def two_sum_hashmap(nums, target):
    """
    해시맵을 사용한 두 수의 합 찾기 (정렬되지 않은 배열)
    
    Args:
        nums (list): 정수 배열
        target (int): 목표 합
        
    Returns:
        tuple: (인덱스1, 인덱스2) 또는 (-1, -1)
    """
    num_map = {}
    
    for i, num in enumerate(nums):
        complement = target - num
        
        if complement in num_map:
            return num_map[complement], i
        
        num_map[num] = i
    
    return -1, -1

def two_sum_hashmap_all(nums, target):
    """
    해시맵을 사용한 모든 두 수의 합 찾기
    
    Args:
        nums (list): 정수 배열
        target (int): 목표 합
        
    Returns:
        list: 모든 쌍의 (인덱스1, 인덱스2) 튜플 리스트
    """
    num_map = {}
    pairs = []
    
    for i, num in enumerate(nums):
        complement = target - num
        
        if complement in num_map:
            for prev_index in num_map[complement]:
                pairs.append((prev_index, i))
        
        if num not in num_map:
            num_map[num] = []
        num_map[num].append(i)
    
    return pairs

# 테스트
nums = [2, 7, 11, 15, 3, 6, 1, 8]
target = 9

print(f"배열: {nums}")
print(f"목표 합: {target}")

# 첫 번째 쌍 찾기
index1, index2 = two_sum_hashmap(nums, target)
if index1 != -1:
    print(f"첫 번째 쌍: 인덱스 {index1}, {index2} (값: {nums[index1]}, {nums[index2]})")

# 모든 쌍 찾기
all_pairs = two_sum_hashmap_all(nums, target)
print(f"모든 쌍: {all_pairs}")
for i, j in all_pairs:
    print(f"  {nums[i]} + {nums[j]} = {nums[i] + nums[j]}")
```

### 4. 알고리즘 기법 성능 비교

```python
import time
import random

def performance_comparison():
    """알고리즘 기법들의 성능 비교"""
    sizes = [1000, 5000, 10000]
    
    for size in sizes:
        # 테스트 데이터 생성
        arr = [random.randint(1, 100) for _ in range(size)]
        target = size * 25  # 적절한 목표값
        
        print(f"\n배열 크기: {size}")
        
        # 1. 기본 방법 (이중 반복문)
        start = time.time()
        result1 = find_subarray_with_sum_basic(arr.copy(), target)
        time1 = time.time() - start
        print(f"기본 방법: {time1:.6f}초")
        
        # 2. 슬라이딩 윈도우 (양수 배열)
        start = time.time()
        result2 = find_subarray_with_sum_optimized(arr.copy(), target)
        time2 = time.time() - start
        print(f"슬라이딩 윈도우: {time2:.6f}초")
        
        # 3. 해시맵 방법
        start = time.time()
        result3 = subarray_sum_hashmap(arr.copy(), target)
        time3 = time.time() - start
        print(f"해시맵: {time3:.6f}초")
        
        # 성능 비율 계산
        if time1 > 0:
            print(f"성능 개선: 슬라이딩 윈도우 {time1/time2:.1f}배, 해시맵 {time1/time3:.1f}배")

def find_subarray_with_sum_basic(arr, target):
    """기본 이중 반복문 방법"""
    for i in range(len(arr)):
        current_sum = 0
        for j in range(i, len(arr)):
            current_sum += arr[j]
            if current_sum == target:
                return i, j
            elif current_sum > target:
                break
    return -1, -1

def find_subarray_with_sum_optimized(arr, target):
    """슬라이딩 윈도우 방법"""
    left = 0
    current_sum = 0
    
    for right in range(len(arr)):
        current_sum += arr[right]
        
        while current_sum > target and left <= right:
            current_sum -= arr[left]
            left += 1
        
        if current_sum == target:
            return left, right
    
    return -1, -1

# 성능 테스트 실행
if __name__ == "__main__":
    performance_comparison()
```

## 정리

이번 포스트에서는 배열 문제 해결을 위한 핵심 알고리즘 기법들을 다뤘습니다:

**핵심 알고리즘 기법**
1. **두 포인터 기법**: 정렬된 배열에서 효율적인 검색과 중복 제거
2. **슬라이딩 윈도우**: 고정/가변 크기 윈도우로 최적화된 부분 배열 처리
3. **해시맵 활용**: 키-값 쌍을 이용한 O(1) 검색으로 시간복잡도 개선

**성능 최적화 포인트**
- 🎯 **시간복잡도**: O(n²) → O(n) 또는 O(n log n) → O(n)으로 개선
- 💾 **공간복잡도**: 해시맵 사용 시 공간과 시간의 트레이드오프 고려
- 🔄 **알고리즘 선택**: 문제 특성에 맞는 최적의 기법 선택

**실무 적용 가이드**
- **두 포인터**: 정렬된 데이터, 대칭성 있는 문제
- **슬라이딩 윈도우**: 연속된 부분 배열, 고정/가변 크기 윈도우 문제
- **해시맵**: 빠른 검색이 필요한 경우, 부분 배열 합 문제

**다음 학습 계획**
다음 포스트에서는 이러한 알고리즘 기법들을 실제 프로젝트에 적용하는 방법을 알아보겠습니다:
- [[학습] [자료구조] 배열(Array) 활용 - 3. 실무 활용]({% post_url 2025-10-03-배열(Array)-활용-3-실무-활용 %}) - 웹 개발, 데이터 분석에서의 배열 활용

# 📚 레퍼런스
- [Two Pointers Technique - GeeksforGeeks](https://www.geeksforgeeks.org/two-pointers-technique/)
- [Sliding Window Technique - GeeksforGeeks](https://www.geeksforgeeks.org/window-sliding-technique/)
- [Hash Map Problems - LeetCode](https://leetcode.com/tag/hash-table/)

---
*이 포스트는 자료구조 학습 과정을 정리한 내용입니다.*
