---
layout: post
title: "[ìë£Œêµ¬ì¡°] í(Queue) - í™œìš© - 3"
date: 2025-01-08 21:15:00 +0900
categories: [ìë£Œêµ¬ì¡°, í]
tags: [ìë£Œêµ¬ì¡°, í, Queue, ë©”ì‹œì§€í, ì‘ì—…í, ì´ë²¤íŠ¸ì‹œìŠ¤í…œ, ìºì‹±, ì‹¤ë¬´]
author: LimJongHan
toc: true
---

# ğŸ“– ê´€ë ¨ëœ ë‚´ í¬ìŠ¤íŒ…
- [[ìë£Œêµ¬ì¡°] ìë£Œêµ¬ì¡°ì™€ ì•Œê³ ë¦¬ì¦˜ ê°œìš”]({% post_url 2025-10-02-[ìë£Œêµ¬ì¡°] ìë£Œêµ¬ì¡°ì™€ ì•Œê³ ë¦¬ì¦˜ ê°œìš” %})
- [[ìë£Œêµ¬ì¡°] ë°°ì—´(Array) - ê¸°ë³¸ ì˜ˆì œ]({% post_url 2025-10-03-[ìë£Œêµ¬ì¡°] ë°°ì—´(Array) - ê¸°ë³¸ ì˜ˆì œ %})
- [[ìë£Œêµ¬ì¡°] ë°°ì—´(Array) - í™œìš© - 1]({% post_url 2025-10-03-[ìë£Œêµ¬ì¡°] ë°°ì—´(Array) - í™œìš© - 1 %})
- [[ìë£Œêµ¬ì¡°] ë°°ì—´(Array) - í™œìš© - 2]({% post_url 2025-10-03-[ìë£Œêµ¬ì¡°] ë°°ì—´(Array) - í™œìš© - 2 %})
- [[ìë£Œêµ¬ì¡°] ë°°ì—´(Array) - í™œìš© - 3]({% post_url 2025-10-03-[ìë£Œêµ¬ì¡°] ë°°ì—´(Array) - í™œìš© - 3 %})
- [[ìë£Œêµ¬ì¡°] ì—°ê²°ë¦¬ìŠ¤íŠ¸(Linked List) - ê¸°ë³¸ ì˜ˆì œ]({% post_url 2025-10-04-[ìë£Œêµ¬ì¡°] ì—°ê²°ë¦¬ìŠ¤íŠ¸(Linked List) - ê¸°ë³¸ ì˜ˆì œ %})
- [[ìë£Œêµ¬ì¡°] ì—°ê²°ë¦¬ìŠ¤íŠ¸(Linked List) - í™œìš© - 1]({% post_url 2025-10-04-[ìë£Œêµ¬ì¡°] ì—°ê²°ë¦¬ìŠ¤íŠ¸(Linked List) - í™œìš© - 1 %})
- [[ìë£Œêµ¬ì¡°] ì—°ê²°ë¦¬ìŠ¤íŠ¸(Linked List) - í™œìš© - 2]({% post_url 2025-10-04-[ìë£Œêµ¬ì¡°] ì—°ê²°ë¦¬ìŠ¤íŠ¸(Linked List) - í™œìš© - 2 %})
- [[ìë£Œêµ¬ì¡°] ì—°ê²°ë¦¬ìŠ¤íŠ¸(Linked List) - í™œìš© - 3]({% post_url 2025-10-04-[ìë£Œêµ¬ì¡°] ì—°ê²°ë¦¬ìŠ¤íŠ¸(Linked List) - í™œìš© - 3 %})
- [[ìë£Œêµ¬ì¡°] ìŠ¤íƒ(Stack) - ê¸°ë³¸ ì˜ˆì œ]({% post_url 2025-10-04-[ìë£Œêµ¬ì¡°] ìŠ¤íƒ(Stack) - ê¸°ë³¸ ì˜ˆì œ %})
- [[ìë£Œêµ¬ì¡°] ìŠ¤íƒ(Stack) - í™œìš© - 1]({% post_url 2025-10-04-[ìë£Œêµ¬ì¡°] ìŠ¤íƒ(Stack) - í™œìš© - 1 %})
- [[ìë£Œêµ¬ì¡°] ìŠ¤íƒ(Stack) - í™œìš© - 2]({% post_url 2025-10-04-[ìë£Œêµ¬ì¡°] ìŠ¤íƒ(Stack) - í™œìš© - 2 %})
- [[ìë£Œêµ¬ì¡°] ìŠ¤íƒ(Stack) - í™œìš© - 3]({% post_url 2025-10-04-[ìë£Œêµ¬ì¡°] ìŠ¤íƒ(Stack) - í™œìš© - 3 %})
- [[ìë£Œêµ¬ì¡°] í(Queue) - ê¸°ë³¸ ì˜ˆì œ]({% post_url 2025-10-05-[ìë£Œêµ¬ì¡°] í(Queue) - ê¸°ë³¸ ì˜ˆì œ %})
- [[ìë£Œêµ¬ì¡°] í(Queue) - í™œìš© - 1]({% post_url 2025-10-05-[ìë£Œêµ¬ì¡°] í(Queue) - í™œìš© - 1 %})
- [[ìë£Œêµ¬ì¡°] í(Queue) - í™œìš© - 2]({% post_url 2025-10-05-[ìë£Œêµ¬ì¡°] í(Queue) - í™œìš© - 2 %})

# ğŸ“ ë‚´ìš©

## ê°œìš”

íëŠ” ì´ë¡ ì ì¸ ìë£Œêµ¬ì¡°ë¥¼ ë„˜ì–´ì„œ ì‹¤ì œ ì†Œí”„íŠ¸ì›¨ì–´ ê°œë°œê³¼ ì‹œìŠ¤í…œ ì„¤ê³„ì—ì„œ ë§¤ìš° ì¤‘ìš”í•œ ì—­í• ì„ í•©ë‹ˆë‹¤. ì´ë²ˆ í¬ìŠ¤íŠ¸ì—ì„œëŠ” íê°€ ì‹¤ì œ í”„ë¡œì íŠ¸ì™€ ì‹œìŠ¤í…œì—ì„œ ì–´ë–»ê²Œ í™œìš©ë˜ëŠ”ì§€ ì‚´í´ë³´ê² ìŠµë‹ˆë‹¤. ë©”ì‹œì§€ í, ì‘ì—… í, ì´ë²¤íŠ¸ ì‹œìŠ¤í…œ, ìºì‹± ì‹œìŠ¤í…œ ë“± ì‹¤ë¬´ì—ì„œ ìì£¼ ì ‘í•˜ëŠ” ì‹œìŠ¤í…œë“¤ì˜ ë‚´ë¶€ ë™ì‘ ì›ë¦¬ë¥¼ ì´í•´í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

**ë‹¤ë£° ì‹¤ë¬´ í™œìš© ì‚¬ë¡€ë“¤:**
- **ë©”ì‹œì§€ í ì‹œìŠ¤í…œ**: ë¹„ë™ê¸° í†µì‹ ê³¼ ì‹œìŠ¤í…œ ê°„ ë°ì´í„° ì „ë‹¬
- **ì‘ì—… í (Job Queue)**: ë°±ê·¸ë¼ìš´ë“œ ì‘ì—… ì²˜ë¦¬ì™€ ìŠ¤ì¼€ì¤„ë§
- **ì´ë²¤íŠ¸ ì‹œìŠ¤í…œ**: ê²Œì„, ì›¹ ì• í”Œë¦¬ì¼€ì´ì…˜ì—ì„œì˜ ì´ë²¤íŠ¸ ì²˜ë¦¬
- **ìºì‹± ì‹œìŠ¤í…œ**: LRU ìºì‹œì™€ í ê¸°ë°˜ ìºì‹œ ê´€ë¦¬
- **API ìš”ì²­ ê´€ë¦¬**: ì†ë„ ì œí•œê³¼ ìš”ì²­ ìˆœì„œ ë³´ì¥

## 1. ë©”ì‹œì§€ í ì‹œìŠ¤í…œ

ë©”ì‹œì§€ íëŠ” ì‹œìŠ¤í…œ ê°„ ë¹„ë™ê¸° í†µì‹ ì„ ìœ„í•œ í•µì‹¬ êµ¬ì„± ìš”ì†Œì…ë‹ˆë‹¤.

### 1-1 ê¸°ë³¸ ë©”ì‹œì§€ í êµ¬í˜„

```python
import threading
import time
import json
from datetime import datetime
from typing import Any, Dict, Optional
from collections import deque

class Message:
    """ë©”ì‹œì§€ í´ë˜ìŠ¤"""
    def __init__(self, content: Any, message_type: str = "default", priority: int = 0):
        self.content = content
        self.message_type = message_type
        self.priority = priority
        self.timestamp = datetime.now()
        self.message_id = f"msg_{int(time.time() * 1000)}"
    
    def __str__(self):
        return f"Message(id={self.message_id}, type={self.message_type}, priority={self.priority})"

class MessageQueue:
    """ë©”ì‹œì§€ í êµ¬í˜„"""
    
    def __init__(self, max_size: Optional[int] = None):
        self.max_size = max_size
        self.queues = {
            'high': deque(),      # ë†’ì€ ìš°ì„ ìˆœìœ„
            'normal': deque(),    # ì¼ë°˜ ìš°ì„ ìˆœìœ„
            'low': deque()        # ë‚®ì€ ìš°ì„ ìˆœìœ„
        }
        self.subscribers = {}     # êµ¬ë…ìë“¤
        self.lock = threading.Lock()
        self.message_count = 0
    
    def publish(self, message: Message, topic: str = "default"):
        """ë©”ì‹œì§€ ë°œí–‰"""
        with self.lock:
            if self.max_size and self._total_size() >= self.max_size:
                # íê°€ ê°€ë“ ì°¬ ê²½ìš° ë‚®ì€ ìš°ì„ ìˆœìœ„ ë©”ì‹œì§€ ì œê±°
                self._remove_lowest_priority()
            
            # ìš°ì„ ìˆœìœ„ì— ë”°ë¼ ì ì ˆí•œ íì— ì¶”ê°€
            if message.priority >= 2:
                queue_name = 'high'
            elif message.priority >= 1:
                queue_name = 'normal'
            else:
                queue_name = 'low'
            
            self.queues[queue_name].append((message, topic))
            self.message_count += 1
            
            print(f"ë©”ì‹œì§€ ë°œí–‰: {message} -> {topic}")
    
    def subscribe(self, topic: str, callback):
        """í† í”½ êµ¬ë…"""
        if topic not in self.subscribers:
            self.subscribers[topic] = []
        self.subscribers[topic].append(callback)
        print(f"í† í”½ '{topic}' êµ¬ë… ë“±ë¡")
    
    def consume(self, topic: str = None) -> Optional[tuple]:
        """ë©”ì‹œì§€ ì†Œë¹„ (ìš°ì„ ìˆœìœ„ ìˆœì„œ)"""
        with self.lock:
            # ìš°ì„ ìˆœìœ„ ìˆœì„œë¡œ ë©”ì‹œì§€ í™•ì¸
            for queue_name in ['high', 'normal', 'low']:
                queue = self.queues[queue_name]
                if queue:
                    message, message_topic = queue.popleft()
                    
                    # í† í”½ í•„í„°ë§
                    if topic is None or message_topic == topic:
                        print(f"ë©”ì‹œì§€ ì†Œë¹„: {message} <- {message_topic}")
                        return message, message_topic
            
            return None
    
    def _total_size(self):
        """ì „ì²´ í í¬ê¸°"""
        return sum(len(queue) for queue in self.queues.values())
    
    def _remove_lowest_priority(self):
        """ê°€ì¥ ë‚®ì€ ìš°ì„ ìˆœìœ„ ë©”ì‹œì§€ ì œê±°"""
        if self.queues['low']:
            self.queues['low'].pop()
        elif self.queues['normal']:
            self.queues['normal'].pop()
    
    def get_stats(self):
        """í í†µê³„ ì •ë³´"""
        return {
            'total_messages': self.message_count,
            'queue_sizes': {
                'high': len(self.queues['high']),
                'normal': len(self.queues['normal']),
                'low': len(self.queues['low'])
            },
            'subscribers': len(self.subscribers)
        }

# í…ŒìŠ¤íŠ¸
mq = MessageQueue(max_size=10)

# êµ¬ë…ì ë“±ë¡
def email_handler(message, topic):
    print(f"ğŸ“§ ì´ë©”ì¼ ë°œì†¡: {message.content}")

def sms_handler(message, topic):
    print(f"ğŸ“± SMS ë°œì†¡: {message.content}")

mq.subscribe("notification", email_handler)
mq.subscribe("notification", sms_handler)

# ë©”ì‹œì§€ ë°œí–‰
messages = [
    Message("íšŒì›ê°€ì… ì™„ë£Œ", "notification", priority=2),
    Message("ì£¼ë¬¸ í™•ì¸", "notification", priority=1),
    Message("ê´‘ê³  ë©”ì‹œì§€", "marketing", priority=0),
    Message("ì¤‘ìš” ì•Œë¦¼", "alert", priority=3),
]

for msg in messages:
    mq.publish(msg, "notification")

print(f"\ní ìƒíƒœ: {mq.get_stats()}")

# ë©”ì‹œì§€ ì†Œë¹„
print("\në©”ì‹œì§€ ì†Œë¹„:")
while True:
    result = mq.consume()
    if result is None:
        break
    message, topic = result
    # êµ¬ë…ìë“¤ì—ê²Œ ë©”ì‹œì§€ ì „ë‹¬
    if topic in mq.subscribers:
        for callback in mq.subscribers[topic]:
            callback(message, topic)
```

### 1-2 Redis ìŠ¤íƒ€ì¼ ë©”ì‹œì§€ í

```python
import time
from typing import Dict, List, Any

class RedisStyleQueue:
    """Redis ìŠ¤íƒ€ì¼ì˜ ë©”ì‹œì§€ í"""
    
    def __init__(self):
        self.queues = {}           # ì¼ë°˜ í
        self.blocking_queues = {}  # ë¸”ë¡œí‚¹ í
        self.expired_keys = {}     # ë§Œë£Œëœ í‚¤ë“¤
    
    def lpush(self, queue_name: str, *values):
        """ë¦¬ìŠ¤íŠ¸ ì™¼ìª½ì— ê°’ ì¶”ê°€"""
        if queue_name not in self.queues:
            self.queues[queue_name] = []
        
        for value in values:
            self.queues[queue_name].insert(0, value)
        
        print(f"LPUSH {queue_name}: {values}")
    
    def rpush(self, queue_name: str, *values):
        """ë¦¬ìŠ¤íŠ¸ ì˜¤ë¥¸ìª½ì— ê°’ ì¶”ê°€"""
        if queue_name not in self.queues:
            self.queues[queue_name] = []
        
        self.queues[queue_name].extend(values)
        print(f"RPUSH {queue_name}: {values}")
    
    def lpop(self, queue_name: str) -> Any:
        """ë¦¬ìŠ¤íŠ¸ ì™¼ìª½ì—ì„œ ê°’ ì œê±°"""
        if queue_name not in self.queues or not self.queues[queue_name]:
            return None
        
        value = self.queues[queue_name].pop(0)
        print(f"LPOP {queue_name}: {value}")
        return value
    
    def rpop(self, queue_name: str) -> Any:
        """ë¦¬ìŠ¤íŠ¸ ì˜¤ë¥¸ìª½ì—ì„œ ê°’ ì œê±°"""
        if queue_name not in self.queues or not self.queues[queue_name]:
            return None
        
        value = self.queues[queue_name].pop()
        print(f"RPOP {queue_name}: {value}")
        return value
    
    def blpop(self, queue_names: List[str], timeout: int = 0) -> tuple:
        """ë¸”ë¡œí‚¹ ì™¼ìª½ íŒ"""
        start_time = time.time()
        
        while True:
            for queue_name in queue_names:
                value = self.lpop(queue_name)
                if value is not None:
                    return (queue_name, value)
            
            # íƒ€ì„ì•„ì›ƒ í™•ì¸
            if timeout > 0 and (time.time() - start_time) >= timeout:
                return None
            
            time.sleep(0.1)  # ì§§ì€ ëŒ€ê¸°
    
    def llen(self, queue_name: str) -> int:
        """ë¦¬ìŠ¤íŠ¸ ê¸¸ì´ ë°˜í™˜"""
        return len(self.queues.get(queue_name, []))
    
    def lrange(self, queue_name: str, start: int, end: int) -> List[Any]:
        """ë¦¬ìŠ¤íŠ¸ ë²”ìœ„ ë°˜í™˜"""
        if queue_name not in self.queues:
            return []
        
        queue = self.queues[queue_name]
        return queue[start:end+1 if end >= 0 else len(queue)+end+1]

# í…ŒìŠ¤íŠ¸
redis_queue = RedisStyleQueue()

print("=== Redis ìŠ¤íƒ€ì¼ í í…ŒìŠ¤íŠ¸ ===")

# ì‘ì—… í ì‹œë®¬ë ˆì´ì…˜
redis_queue.rpush("tasks", "ì‘ì—…1", "ì‘ì—…2", "ì‘ì—…3")
redis_queue.rpush("high_priority", "ê¸´ê¸‰ì‘ì—…1", "ê¸´ê¸‰ì‘ì—…2")

print(f"ì‘ì—… í ê¸¸ì´: {redis_queue.llen('tasks')}")
print(f"ìš°ì„ ìˆœìœ„ í ê¸¸ì´: {redis_queue.llen('high_priority')}")

# ì‘ì—… ì²˜ë¦¬
print("\nì‘ì—… ì²˜ë¦¬:")
while True:
    # ìš°ì„ ìˆœìœ„ íì—ì„œ ë¨¼ì € í™•ì¸
    result = redis_queue.blpop(["high_priority", "tasks"], timeout=1)
    if result is None:
        break
    
    queue_name, task = result
    print(f"ì²˜ë¦¬ ì¤‘: {task} (í: {queue_name})")
```

## 2. ì‘ì—… í (Job Queue) ì‹œìŠ¤í…œ

ë°±ê·¸ë¼ìš´ë“œ ì‘ì—…ì„ ì²˜ë¦¬í•˜ê¸° ìœ„í•œ í ì‹œìŠ¤í…œì…ë‹ˆë‹¤.

### 2-1 ê¸°ë³¸ ì‘ì—… í êµ¬í˜„

```python
import threading
import time
import uuid
from enum import Enum
from typing import Callable, Any, Dict, Optional
from collections import deque
from datetime import datetime

class JobStatus(Enum):
    PENDING = "pending"
    RUNNING = "running"
    COMPLETED = "completed"
    FAILED = "failed"
    CANCELLED = "cancelled"

class Job:
    """ì‘ì—… í´ë˜ìŠ¤"""
    def __init__(self, func: Callable, *args, **kwargs):
        self.job_id = str(uuid.uuid4())
        self.func = func
        self.args = args
        self.kwargs = kwargs
        self.status = JobStatus.PENDING
        self.result = None
        self.error = None
        self.created_at = datetime.now()
        self.started_at = None
        self.completed_at = None
        self.priority = 0  # ë†’ì„ìˆ˜ë¡ ìš°ì„ ìˆœìœ„ ë†’ìŒ
    
    def __str__(self):
        return f"Job({self.job_id}, {self.status.value})"

class JobQueue:
    """ì‘ì—… í ì‹œìŠ¤í…œ"""
    
    def __init__(self, max_workers: int = 4):
        self.max_workers = max_workers
        self.job_queue = deque()
        self.running_jobs = {}
        self.completed_jobs = {}
        self.workers = []
        self.shutdown = False
        self.lock = threading.Lock()
        
        # ì›Œì»¤ ìŠ¤ë ˆë“œë“¤ ì‹œì‘
        for i in range(max_workers):
            worker = threading.Thread(target=self._worker, args=(i,))
            worker.daemon = True
            worker.start()
            self.workers.append(worker)
    
    def _worker(self, worker_id: int):
        """ì›Œì»¤ ìŠ¤ë ˆë“œ"""
        print(f"ì›Œì»¤ {worker_id} ì‹œì‘")
        
        while not self.shutdown:
            job = self._get_next_job()
            
            if job is None:
                time.sleep(0.1)
                continue
            
            self._execute_job(job, worker_id)
        
        print(f"ì›Œì»¤ {worker_id} ì¢…ë£Œ")
    
    def _get_next_job(self) -> Optional[Job]:
        """ë‹¤ìŒ ì‘ì—… ê°€ì ¸ì˜¤ê¸° (ìš°ì„ ìˆœìœ„ ìˆœì„œ)"""
        with self.lock:
            if not self.job_queue:
                return None
            
            # ìš°ì„ ìˆœìœ„ê°€ ë†’ì€ ì‘ì—… ì°¾ê¸°
            highest_priority = max(job.priority for job in self.job_queue)
            for i, job in enumerate(self.job_queue):
                if job.priority == highest_priority:
                    return self.job_queue.pop(i)
            
            return None
    
    def _execute_job(self, job: Job, worker_id: int):
        """ì‘ì—… ì‹¤í–‰"""
        job.status = JobStatus.RUNNING
        job.started_at = datetime.now()
        
        with self.lock:
            self.running_jobs[job.job_id] = job
        
        print(f"ì›Œì»¤ {worker_id}: ì‘ì—… ì‹œì‘ {job}")
        
        try:
            # ì‘ì—… ì‹¤í–‰
            job.result = job.func(*job.args, **job.kwargs)
            job.status = JobStatus.COMPLETED
            print(f"ì›Œì»¤ {worker_id}: ì‘ì—… ì™„ë£Œ {job}")
            
        except Exception as e:
            job.status = JobStatus.FAILED
            job.error = str(e)
            print(f"ì›Œì»¤ {worker_id}: ì‘ì—… ì‹¤íŒ¨ {job} - {e}")
        
        finally:
            job.completed_at = datetime.now()
            
            with self.lock:
                if job.job_id in self.running_jobs:
                    del self.running_jobs[job.job_id]
                self.completed_jobs[job.job_id] = job
    
    def add_job(self, func: Callable, *args, priority: int = 0, **kwargs) -> str:
        """ì‘ì—… ì¶”ê°€"""
        job = Job(func, *args, **kwargs)
        job.priority = priority
        
        with self.lock:
            self.job_queue.append(job)
        
        print(f"ì‘ì—… ì¶”ê°€: {job}")
        return job.job_id
    
    def get_job_status(self, job_id: str) -> Optional[Dict]:
        """ì‘ì—… ìƒíƒœ ì¡°íšŒ"""
        with self.lock:
            if job_id in self.running_jobs:
                job = self.running_jobs[job_id]
            elif job_id in self.completed_jobs:
                job = self.completed_jobs[job_id]
            else:
                return None
            
            return {
                'job_id': job.job_id,
                'status': job.status.value,
                'result': job.result,
                'error': job.error,
                'created_at': job.created_at,
                'started_at': job.started_at,
                'completed_at': job.completed_at
            }
    
    def cancel_job(self, job_id: str) -> bool:
        """ì‘ì—… ì·¨ì†Œ"""
        with self.lock:
            # ëŒ€ê¸° ì¤‘ì¸ ì‘ì—…ì—ì„œ ì œê±°
            for i, job in enumerate(self.job_queue):
                if job.job_id == job_id:
                    job = self.job_queue.pop(i)
                    job.status = JobStatus.CANCELLED
                    return True
            
            # ì‹¤í–‰ ì¤‘ì¸ ì‘ì—…ì€ ì·¨ì†Œí•  ìˆ˜ ì—†ìŒ
            if job_id in self.running_jobs:
                return False
            
            return False
    
    def get_stats(self) -> Dict:
        """í í†µê³„"""
        with self.lock:
            return {
                'pending_jobs': len(self.job_queue),
                'running_jobs': len(self.running_jobs),
                'completed_jobs': len(self.completed_jobs),
                'total_workers': self.max_workers
            }
    
    def shutdown_queue(self):
        """í ì¢…ë£Œ"""
        self.shutdown = True
        for worker in self.workers:
            worker.join()

# í…ŒìŠ¤íŠ¸ í•¨ìˆ˜ë“¤
def cpu_task(n: int):
    """CPU ì§‘ì•½ì  ì‘ì—…"""
    result = 0
    for i in range(n):
        result += i ** 2
    return result

def io_task(duration: float):
    """I/O ì§‘ì•½ì  ì‘ì—…"""
    time.sleep(duration)
    return f"I/O ì‘ì—… ì™„ë£Œ ({duration}ì´ˆ)"

def error_task():
    """ì˜¤ë¥˜ ë°œìƒ ì‘ì—…"""
    raise ValueError("ì˜ë„ì ì¸ ì˜¤ë¥˜")

# í…ŒìŠ¤íŠ¸
print("=== ì‘ì—… í í…ŒìŠ¤íŠ¸ ===")

job_queue = JobQueue(max_workers=2)

# ë‹¤ì–‘í•œ ì‘ì—…ë“¤ ì¶”ê°€
job_ids = []

# ì¼ë°˜ ì‘ì—…ë“¤
job_ids.append(job_queue.add_job(cpu_task, 100000, priority=1))
job_ids.append(job_queue.add_job(io_task, 1.0, priority=0))
job_ids.append(job_queue.add_job(cpu_task, 50000, priority=2))

# ì˜¤ë¥˜ ë°œìƒ ì‘ì—…
job_ids.append(job_queue.add_job(error_task, priority=1))

# ìš°ì„ ìˆœìœ„ ë†’ì€ ì‘ì—…
job_ids.append(job_queue.add_job(io_task, 0.5, priority=3))

print(f"ì‘ì—… IDë“¤: {job_ids}")
print(f"ì´ˆê¸° ìƒíƒœ: {job_queue.get_stats()}")

# ì‘ì—… ìƒíƒœ í™•ì¸
time.sleep(2)
print("\nì‘ì—… ìƒíƒœ í™•ì¸:")
for job_id in job_ids:
    status = job_queue.get_job_status(job_id)
    if status:
        print(f"{job_id}: {status['status']}")

print(f"\nìµœì¢… ìƒíƒœ: {job_queue.get_stats()}")

# ì‘ì—… í ì¢…ë£Œ
job_queue.shutdown_queue()
```

## 3. ì´ë²¤íŠ¸ ì‹œìŠ¤í…œ

ê²Œì„ì´ë‚˜ ì›¹ ì• í”Œë¦¬ì¼€ì´ì…˜ì—ì„œ ì‚¬ìš©ë˜ëŠ” ì´ë²¤íŠ¸ ì²˜ë¦¬ ì‹œìŠ¤í…œì…ë‹ˆë‹¤.

### 3-1 ê²Œì„ ì´ë²¤íŠ¸ ì‹œìŠ¤í…œ

```python
import time
from typing import Dict, List, Callable, Any
from collections import defaultdict
from enum import Enum

class EventType(Enum):
    PLAYER_MOVE = "player_move"
    PLAYER_ATTACK = "player_attack"
    ENEMY_SPAWN = "enemy_spawn"
    ITEM_PICKUP = "item_pickup"
    GAME_OVER = "game_over"

class GameEvent:
    """ê²Œì„ ì´ë²¤íŠ¸ í´ë˜ìŠ¤"""
    def __init__(self, event_type: EventType, data: Dict[str, Any] = None):
        self.event_type = event_type
        self.data = data or {}
        self.timestamp = time.time()
        self.event_id = f"event_{int(time.time() * 1000)}"
    
    def __str__(self):
        return f"GameEvent({self.event_type.value}, {self.data})"

class GameEventSystem:
    """ê²Œì„ ì´ë²¤íŠ¸ ì‹œìŠ¤í…œ"""
    
    def __init__(self):
        self.event_queue = []
        self.event_handlers = defaultdict(list)
        self.event_history = []
        self.max_history = 1000
    
    def subscribe(self, event_type: EventType, handler: Callable):
        """ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ ë“±ë¡"""
        self.event_handlers[event_type].append(handler)
        print(f"ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ ë“±ë¡: {event_type.value}")
    
    def unsubscribe(self, event_type: EventType, handler: Callable):
        """ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ ì œê±°"""
        if handler in self.event_handlers[event_type]:
            self.event_handlers[event_type].remove(handler)
            print(f"ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ ì œê±°: {event_type.value}")
    
    def publish(self, event: GameEvent):
        """ì´ë²¤íŠ¸ ë°œí–‰ (íì— ì¶”ê°€)"""
        self.event_queue.append(event)
        print(f"ì´ë²¤íŠ¸ ë°œí–‰: {event}")
    
    def publish_immediate(self, event: GameEvent):
        """ì´ë²¤íŠ¸ ì¦‰ì‹œ ì²˜ë¦¬"""
        self._process_event(event)
    
    def process_events(self):
        """íì— ìˆëŠ” ì´ë²¤íŠ¸ë“¤ ì²˜ë¦¬"""
        while self.event_queue:
            event = self.event_queue.pop(0)
            self._process_event(event)
    
    def _process_event(self, event: GameEvent):
        """ì´ë²¤íŠ¸ ì²˜ë¦¬"""
        # ì´ë²¤íŠ¸ íˆìŠ¤í† ë¦¬ì— ì¶”ê°€
        self.event_history.append(event)
        if len(self.event_history) > self.max_history:
            self.event_history.pop(0)
        
        # í•´ë‹¹ ì´ë²¤íŠ¸ íƒ€ì…ì˜ í•¸ë“¤ëŸ¬ë“¤ ì‹¤í–‰
        handlers = self.event_handlers.get(event.event_type, [])
        for handler in handlers:
            try:
                handler(event)
            except Exception as e:
                print(f"ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ ì˜¤ë¥˜: {e}")
    
    def get_event_stats(self) -> Dict:
        """ì´ë²¤íŠ¸ í†µê³„"""
        event_counts = defaultdict(int)
        for event in self.event_history:
            event_counts[event.event_type.value] += 1
        
        return {
            'total_events': len(self.event_history),
            'pending_events': len(self.event_queue),
            'event_counts': dict(event_counts)
        }

# ê²Œì„ ì‹œë®¬ë ˆì´ì…˜
class Game:
    """ê°„ë‹¨í•œ ê²Œì„ í´ë˜ìŠ¤"""
    
    def __init__(self):
        self.event_system = GameEventSystem()
        self.player_pos = (0, 0)
        self.player_health = 100
        self.enemies = []
        self.score = 0
        
        # ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ ë“±ë¡
        self._register_handlers()
    
    def _register_handlers(self):
        """ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ ë“±ë¡"""
        self.event_system.subscribe(EventType.PLAYER_MOVE, self._on_player_move)
        self.event_system.subscribe(EventType.PLAYER_ATTACK, self._on_player_attack)
        self.event_system.subscribe(EventType.ENEMY_SPAWN, self._on_enemy_spawn)
        self.event_system.subscribe(EventType.ITEM_PICKUP, self._on_item_pickup)
        self.event_system.subscribe(EventType.GAME_OVER, self._on_game_over)
    
    def _on_player_move(self, event: GameEvent):
        """í”Œë ˆì´ì–´ ì´ë™ ì²˜ë¦¬"""
        direction = event.data.get('direction')
        if direction == 'up':
            self.player_pos = (self.player_pos[0], self.player_pos[1] + 1)
        elif direction == 'down':
            self.player_pos = (self.player_pos[0], self.player_pos[1] - 1)
        elif direction == 'left':
            self.player_pos = (self.player_pos[0] - 1, self.player_pos[1])
        elif direction == 'right':
            self.player_pos = (self.player_pos[0] + 1, self.player_pos[1])
        
        print(f"í”Œë ˆì´ì–´ ì´ë™: {self.player_pos}")
    
    def _on_player_attack(self, event: GameEvent):
        """í”Œë ˆì´ì–´ ê³µê²© ì²˜ë¦¬"""
        target = event.data.get('target')
        damage = event.data.get('damage', 10)
        
        print(f"í”Œë ˆì´ì–´ ê³µê²©: {target}ì—ê²Œ {damage} ë°ë¯¸ì§€")
        self.score += 10
    
    def _on_enemy_spawn(self, event: GameEvent):
        """ì  ìƒì„± ì²˜ë¦¬"""
        enemy_type = event.data.get('type', 'goblin')
        position = event.data.get('position', (0, 0))
        
        enemy = {'type': enemy_type, 'position': position, 'health': 50}
        self.enemies.append(enemy)
        print(f"ì  ìƒì„±: {enemy_type} at {position}")
    
    def _on_item_pickup(self, event: GameEvent):
        """ì•„ì´í…œ íšë“ ì²˜ë¦¬"""
        item_type = event.data.get('type', 'potion')
        value = event.data.get('value', 1)
        
        print(f"ì•„ì´í…œ íšë“: {item_type} (+{value})")
        self.score += value * 5
    
    def _on_game_over(self, event: GameEvent):
        """ê²Œì„ ì˜¤ë²„ ì²˜ë¦¬"""
        reason = event.data.get('reason', 'unknown')
        print(f"ê²Œì„ ì˜¤ë²„: {reason}")
        print(f"ìµœì¢… ì ìˆ˜: {self.score}")
    
    def move_player(self, direction: str):
        """í”Œë ˆì´ì–´ ì´ë™"""
        event = GameEvent(EventType.PLAYER_MOVE, {'direction': direction})
        self.event_system.publish(event)
    
    def attack(self, target: str, damage: int = 10):
        """í”Œë ˆì´ì–´ ê³µê²©"""
        event = GameEvent(EventType.PLAYER_ATTACK, {'target': target, 'damage': damage})
        self.event_system.publish(event)
    
    def spawn_enemy(self, enemy_type: str, position: tuple):
        """ì  ìƒì„±"""
        event = GameEvent(EventType.ENEMY_SPAWN, {'type': enemy_type, 'position': position})
        self.event_system.publish(event)
    
    def pickup_item(self, item_type: str, value: int = 1):
        """ì•„ì´í…œ íšë“"""
        event = GameEvent(EventType.ITEM_PICKUP, {'type': item_type, 'value': value})
        self.event_system.publish(event)
    
    def game_over(self, reason: str):
        """ê²Œì„ ì˜¤ë²„"""
        event = GameEvent(EventType.GAME_OVER, {'reason': reason})
        self.event_system.publish(event)
    
    def update(self):
        """ê²Œì„ ì—…ë°ì´íŠ¸ (ì´ë²¤íŠ¸ ì²˜ë¦¬)"""
        self.event_system.process_events()

# í…ŒìŠ¤íŠ¸
print("=== ê²Œì„ ì´ë²¤íŠ¸ ì‹œìŠ¤í…œ í…ŒìŠ¤íŠ¸ ===")

game = Game()

# ê²Œì„ ì‹œë®¬ë ˆì´ì…˜
game.move_player('right')
game.move_player('up')
game.attack('goblin', 15)
game.spawn_enemy('orc', (5, 5))
game.pickup_item('health_potion', 2)
game.move_player('left')

# ì´ë²¤íŠ¸ ì²˜ë¦¬
game.update()

print(f"\nê²Œì„ ìƒíƒœ:")
print(f"í”Œë ˆì´ì–´ ìœ„ì¹˜: {game.player_pos}")
print(f"í”Œë ˆì´ì–´ ì²´ë ¥: {game.player_health}")
print(f"ì  ìˆ˜: {len(game.enemies)}")
print(f"ì ìˆ˜: {game.score}")

print(f"\nì´ë²¤íŠ¸ í†µê³„: {game.event_system.get_event_stats()}")
```

## ì •ë¦¬

ì´ë²ˆ í¬ìŠ¤íŠ¸ì—ì„œëŠ” íì˜ ì‹¤ë¬´ í™œìš© ì‚¬ë¡€ë“¤ì„ ì‚´í´ë³´ì•˜ìŠµë‹ˆë‹¤.

**ì‹¤ë¬´ í™œìš© ì •ë¦¬**
1. **ë©”ì‹œì§€ í ì‹œìŠ¤í…œ**: ë¹„ë™ê¸° í†µì‹ ê³¼ ì‹œìŠ¤í…œ ê°„ ë°ì´í„° ì „ë‹¬
2. **ì‘ì—… í (Job Queue)**: ë°±ê·¸ë¼ìš´ë“œ ì‘ì—… ì²˜ë¦¬ì™€ ìŠ¤ì¼€ì¤„ë§
3. **ì´ë²¤íŠ¸ ì‹œìŠ¤í…œ**: ê²Œì„, ì›¹ ì• í”Œë¦¬ì¼€ì´ì…˜ì—ì„œì˜ ì´ë²¤íŠ¸ ì²˜ë¦¬
4. **ìºì‹± ì‹œìŠ¤í…œ**: LRU ìºì‹œì™€ í ê¸°ë°˜ ìºì‹œ ê´€ë¦¬
5. **API ìš”ì²­ ê´€ë¦¬**: ì†ë„ ì œí•œê³¼ ìš”ì²­ ìˆœì„œ ë³´ì¥

**í ì‹¤ë¬´ í™œìš©ì˜ í•µì‹¬ ì›ì¹™**
- **ë¹„ë™ê¸° ì²˜ë¦¬**: ì‹œê°„ì´ ì˜¤ë˜ ê±¸ë¦¬ëŠ” ì‘ì—…ì„ ë°±ê·¸ë¼ìš´ë“œì—ì„œ ì²˜ë¦¬
- **ìˆœì„œ ë³´ì¥**: ì¤‘ìš”í•œ ì‘ì—…ì˜ ì²˜ë¦¬ ìˆœì„œë¥¼ ë³´ì¥
- **ë¶€í•˜ ë¶„ì‚°**: ì‘ì—…ì„ ì—¬ëŸ¬ ì›Œì»¤ì—ê²Œ ë¶„ì‚°í•˜ì—¬ ì²˜ë¦¬
- **ì¥ì•  ë³µêµ¬**: íë¥¼ ì´ìš©í•œ ì‹œìŠ¤í…œì˜ ì•ˆì •ì„± í–¥ìƒ
- **í™•ì¥ì„±**: ì‹œìŠ¤í…œì˜ í™•ì¥ ê°€ëŠ¥í•œ ì•„í‚¤í…ì²˜ êµ¬ì¶•

**ì‹¤ë¬´ì—ì„œì˜ í í™œìš© íŒ¨í„´**
- **ë§ˆì´í¬ë¡œì„œë¹„ìŠ¤**: ì„œë¹„ìŠ¤ ê°„ í†µì‹ ê³¼ ë©”ì‹œì§€ ì „ë‹¬
- **ë°°ì¹˜ ì²˜ë¦¬**: ëŒ€ëŸ‰ ë°ì´í„°ì˜ ìˆœì°¨ì  ì²˜ë¦¬
- **ì´ë²¤íŠ¸ ê¸°ë°˜ ì•„í‚¤í…ì²˜**: ëŠìŠ¨í•œ ê²°í•©ì˜ ì‹œìŠ¤í…œ ì„¤ê³„
- **ì‹¤ì‹œê°„ ì‹œìŠ¤í…œ**: ê²Œì„, ì±„íŒ…, ì‹¤ì‹œê°„ ì•Œë¦¼ ë“±
- **ë°ì´í„° íŒŒì´í”„ë¼ì¸**: ETL í”„ë¡œì„¸ìŠ¤ì™€ ë°ì´í„° íë¦„ ê´€ë¦¬

íëŠ” ë‹¨ìˆœí•œ ìë£Œêµ¬ì¡°ì´ì§€ë§Œ, ì‹¤ì œ ì†Œí”„íŠ¸ì›¨ì–´ ê°œë°œê³¼ ì‹œìŠ¤í…œ ì„¤ê³„ì—ì„œ ë§¤ìš° ì¤‘ìš”í•œ ì—­í• ì„ í•©ë‹ˆë‹¤. ì´ëŸ¬í•œ ì‹¤ë¬´ í™œìš© ì‚¬ë¡€ë“¤ì„ ì´í•´í•˜ë©´ ë”ìš± íš¨ê³¼ì ì¸ ì‹œìŠ¤í…œ ì„¤ê³„ì™€ êµ¬í˜„ì´ ê°€ëŠ¥í•´ì§‘ë‹ˆë‹¤.

# ğŸ“š ë ˆí¼ëŸ°ìŠ¤
- [Message Queue - Wikipedia](https://en.wikipedia.org/wiki/Message_queue)
- [Job Queue Pattern - Wikipedia](https://en.wikipedia.org/wiki/Job_queue)
- [Event-Driven Architecture - Wikipedia](https://en.wikipedia.org/wiki/Event-driven_architecture)
- [Redis Commands - LPUSH, RPUSH, LPOP, RPOP](https://redis.io/commands/)

---
*ì´ í¬ìŠ¤íŠ¸ëŠ” ìë£Œêµ¬ì¡° í•™ìŠµ ê³¼ì •ì„ ì •ë¦¬í•œ ë‚´ìš©ì…ë‹ˆë‹¤.*
