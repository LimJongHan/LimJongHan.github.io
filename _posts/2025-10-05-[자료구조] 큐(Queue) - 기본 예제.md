---
layout: post
title: "[자료구조] 큐(Queue) - 기본 예제"
date: 2025-01-08 20:30:00 +0900
categories: [자료구조, 큐]
tags: [자료구조, 큐, Queue, FIFO, Python, 배열, 연결리스트, 시간복잡도]
author: LimJongHan
toc: true
---

# 📖 관련된 내 포스팅
- [[자료구조] 자료구조와 알고리즘 개요]({% post_url 2025-10-02-[자료구조] 자료구조와 알고리즘 개요 %})
- [[자료구조] 배열(Array) - 기본 예제]({% post_url 2025-10-03-[자료구조] 배열(Array) - 기본 예제 %})
- [[자료구조] 배열(Array) - 활용 - 1]({% post_url 2025-10-03-[자료구조] 배열(Array) - 활용 - 1 %})
- [[자료구조] 배열(Array) - 활용 - 2]({% post_url 2025-10-03-[자료구조] 배열(Array) - 활용 - 2 %})
- [[자료구조] 배열(Array) - 활용 - 3]({% post_url 2025-10-03-[자료구조] 배열(Array) - 활용 - 3 %})
- [[자료구조] 연결리스트(Linked List) - 기본 예제]({% post_url 2025-10-04-[자료구조] 연결리스트(Linked List) - 기본 예제 %})
- [[자료구조] 연결리스트(Linked List) - 활용 - 1]({% post_url 2025-10-04-[자료구조] 연결리스트(Linked List) - 활용 - 1 %})
- [[자료구조] 연결리스트(Linked List) - 활용 - 2]({% post_url 2025-10-04-[자료구조] 연결리스트(Linked List) - 활용 - 2 %})
- [[자료구조] 연결리스트(Linked List) - 활용 - 3]({% post_url 2025-10-04-[자료구조] 연결리스트(Linked List) - 활용 - 3 %})
- [[자료구조] 스택(Stack) - 기본 예제]({% post_url 2025-10-04-[자료구조] 스택(Stack) - 기본 예제 %})
- [[자료구조] 스택(Stack) - 활용 - 1]({% post_url 2025-10-04-[자료구조] 스택(Stack) - 활용 - 1 %})
- [[자료구조] 스택(Stack) - 활용 - 2]({% post_url 2025-10-04-[자료구조] 스택(Stack) - 활용 - 2 %})
- [[자료구조] 스택(Stack) - 활용 - 3]({% post_url 2025-10-04-[자료구조] 스택(Stack) - 활용 - 3 %})
- [[자료구조] 큐(Queue) - 활용 - 1]({% post_url 2025-10-05-[자료구조] 큐(Queue) - 활용 - 1 %})
- [[자료구조] 큐(Queue) - 활용 - 2]({% post_url 2025-10-05-[자료구조] 큐(Queue) - 활용 - 2 %})
- [[자료구조] 큐(Queue) - 활용 - 3]({% post_url 2025-10-05-[자료구조] 큐(Queue) - 활용 - 3 %})

# 📝 내용

## 개요

큐(Queue)는 **FIFO(First In, First Out)** 원칙을 따르는 선형 자료구조입니다. 가장 먼저 들어온 원소가 가장 먼저 나가는 구조로, 일상생활에서 줄을 서서 기다리는 것과 비슷한 개념입니다. 큐는 컴퓨터 과학에서 매우 중요한 역할을 하며, 특히 프로세스 스케줄링, 네트워크 패킷 처리, BFS 알고리즘 등에서 널리 사용됩니다.

**큐의 주요 특징:**
- **FIFO 구조**: 가장 먼저 들어온 원소가 가장 먼저 나감
- **양방향 접근**: 뒤(rear)에서 추가, 앞(front)에서 제거
- **제한된 접근**: 맨 앞과 맨 뒤 원소에만 직접 접근 가능
- **효율적인 구현**: 배열이나 연결리스트로 간단히 구현 가능

이번 포스트에서는 큐의 기본 개념, 추상자료형 정의, 배열과 연결리스트를 이용한 구현, 그리고 큐의 시간복잡도 분석에 대해 자세히 알아보겠습니다.

## 1. 큐의 추상자료형(ADT)

**추상자료형(ADT)**으로서의 큐는 다음과 같이 정의할 수 있습니다.

**데이터**:
- `n`개의 원소 `e0, e1, ..., en-1`의 유한 시퀀스
- 모든 삽입은 한쪽 끝(rear)에서, 모든 삭제는 다른 쪽 끝(front)에서 수행

**연산**:
- `enqueue(item)`: 큐의 맨 뒤에 새로운 원소를 추가
- `dequeue()`: 큐의 맨 앞 원소를 제거하고 반환
- `front()` 또는 `peek()`: 큐의 맨 앞 원소를 제거하지 않고 반환
- `isEmpty()`: 큐가 비어있는지 확인
- `size()`: 큐에 저장된 원소의 개수 반환

### 1-1 큐의 시각적 표현

```
    front                    rear
      ↓                       ↓
    ┌─────┬─────┬─────┬─────┬─────┐
    │  10 │  20 │  30 │  40 │  50 │
    └─────┴─────┴─────┴─────┴─────┘
```

**큐 동작 예시:**
```
1. enqueue(10): [10]           (front=10, rear=10)
2. enqueue(20): [10, 20]       (front=10, rear=20)
3. enqueue(30): [10, 20, 30]   (front=10, rear=30)
4. dequeue():   [20, 30]       (10 반환, front=20, rear=30)
5. dequeue():   [30]           (20 반환, front=30, rear=30)
6. front():     [30]           (30 반환, 제거하지 않음)
```

## 2. 배열을 이용한 큐 구현

가장 직관적인 큐 구현 방법이지만, 고정 크기 배열을 사용할 때는 순환 큐(Circular Queue)를 고려해야 합니다.

### 2-1 기본 배열 큐 구현

```python
class ArrayQueue:
    """
    배열(리스트)을 이용한 기본 큐 구현
    """
    def __init__(self):
        self._items = []  # Python 리스트를 큐로 사용
        self._size = 0    # 큐의 크기

    def __len__(self):
        """큐의 크기 반환"""
        return self._size

    def __str__(self):
        """큐를 문자열로 표현 (디버깅용)"""
        return f"Queue({self._items[:self._size]})"

    def isEmpty(self):
        """큐가 비어있는지 확인 O(1)"""
        return self._size == 0

    def enqueue(self, item):
        """
        큐의 맨 뒤에 원소 추가 O(1)
        Args:
            item: 추가할 원소
        """
        self._items.append(item)
        self._size += 1

    def dequeue(self):
        """
        큐의 맨 앞 원소 제거 및 반환 O(n)
        Returns:
            any: 제거된 원소
        Raises:
            IndexError: 큐가 비어있을 때
        """
        if self.isEmpty():
            raise IndexError("Queue is empty")
        
        self._size -= 1
        return self._items.pop(0)  # 첫 번째 원소 제거 (O(n))

    def front(self):
        """
        큐의 맨 앞 원소 확인 (제거하지 않음) O(1)
        Returns:
            any: 맨 앞 원소
        Raises:
            IndexError: 큐가 비어있을 때
        """
        if self.isEmpty():
            raise IndexError("Queue is empty")
        
        return self._items[0]

    def rear(self):
        """
        큐의 맨 뒤 원소 확인 (제거하지 않음) O(1)
        Returns:
            any: 맨 뒤 원소
        Raises:
            IndexError: 큐가 비어있을 때
        """
        if self.isEmpty():
            raise IndexError("Queue is empty")
        
        return self._items[self._size - 1]

    def size(self):
        """큐의 크기 반환 O(1)"""
        return self._size

    def display(self):
        """큐의 모든 원소를 출력 (디버깅용)"""
        print(f"Queue contents (front to rear): {self._items[:self._size]}")

# 테스트
queue = ArrayQueue()
print(f"초기 상태: {queue}")
print(f"비어있는가? {queue.isEmpty()}")

# 원소 추가
queue.enqueue(10)
queue.enqueue(20)
queue.enqueue(30)
print(f"3개 원소 추가 후: {queue}")
print(f"크기: {len(queue)}")

# 맨 앞 원소 확인
print(f"맨 앞 원소: {queue.front()}")
print(f"맨 뒤 원소: {queue.rear()}")

# 원소 제거
print(f"제거된 원소: {queue.dequeue()}")
print(f"제거 후: {queue}")
print(f"최종 크기: {len(queue)}")

queue.display()
```

### 2-2 순환 큐(Circular Queue) 구현

고정 크기 배열을 효율적으로 사용하기 위한 순환 큐입니다.

```python
class CircularQueue:
    """
    순환 큐 구현 (고정 크기 배열 사용)
    """
    def __init__(self, capacity):
        """
        Args:
            capacity (int): 큐의 최대 용량
        """
        self._capacity = capacity
        self._items = [None] * capacity
        self._front = 0      # 맨 앞 원소의 인덱스
        self._rear = 0       # 다음에 추가할 위치의 인덱스
        self._size = 0       # 현재 저장된 원소의 개수

    def __len__(self):
        """큐의 크기 반환"""
        return self._size

    def __str__(self):
        """큐를 문자열로 표현"""
        if self.isEmpty():
            return "Queue([])"
        
        items = []
        for i in range(self._size):
            idx = (self._front + i) % self._capacity
            items.append(self._items[idx])
        
        return f"Queue({items})"

    def isEmpty(self):
        """큐가 비어있는지 확인 O(1)"""
        return self._size == 0

    def isFull(self):
        """큐가 가득 찼는지 확인 O(1)"""
        return self._size == self._capacity

    def enqueue(self, item):
        """
        큐의 맨 뒤에 원소 추가 O(1)
        Args:
            item: 추가할 원소
        Raises:
            OverflowError: 큐가 가득 찬 경우
        """
        if self.isFull():
            raise OverflowError("Queue is full")
        
        self._items[self._rear] = item
        self._rear = (self._rear + 1) % self._capacity  # 순환
        self._size += 1

    def dequeue(self):
        """
        큐의 맨 앞 원소 제거 및 반환 O(1)
        Returns:
            any: 제거된 원소
        Raises:
            IndexError: 큐가 비어있을 때
        """
        if self.isEmpty():
            raise IndexError("Queue is empty")
        
        item = self._items[self._front]
        self._items[self._front] = None  # 메모리 정리
        self._front = (self._front + 1) % self._capacity  # 순환
        self._size -= 1
        return item

    def front(self):
        """
        큐의 맨 앞 원소 확인 (제거하지 않음) O(1)
        Returns:
            any: 맨 앞 원소
        Raises:
            IndexError: 큐가 비어있을 때
        """
        if self.isEmpty():
            raise IndexError("Queue is empty")
        
        return self._items[self._front]

    def rear(self):
        """
        큐의 맨 뒤 원소 확인 (제거하지 않음) O(1)
        Returns:
            any: 맨 뒤 원소
        Raises:
            IndexError: 큐가 비어있을 때
        """
        if self.isEmpty():
            raise IndexError("Queue is empty")
        
        rear_idx = (self._rear - 1) % self._capacity
        return self._items[rear_idx]

    def size(self):
        """큐의 크기 반환 O(1)"""
        return self._size

    def capacity(self):
        """큐의 최대 용량 반환 O(1)"""
        return self._capacity

    def display(self):
        """큐의 모든 원소를 출력 (디버깅용)"""
        if self.isEmpty():
            print("Queue is empty")
            return
        
        items = []
        for i in range(self._size):
            idx = (self._front + i) % self._capacity
            items.append(self._items[idx])
        
        print(f"Queue contents (front to rear): {items}")
        print(f"Front index: {self._front}, Rear index: {self._rear}")

# 테스트
print("=== 순환 큐 테스트 ===")
circular_queue = CircularQueue(5)
print(f"초기 상태: {circular_queue}")
print(f"용량: {circular_queue.capacity()}")

# 원소 추가
for i in range(5):
    circular_queue.enqueue(f"item_{i+1}")
    print(f"추가 후: {circular_queue}")

# 가득 찬 상태 확인
try:
    circular_queue.enqueue("overflow")
except OverflowError as e:
    print(f"오버플로우 방지: {e}")

# 원소 제거
for i in range(3):
    removed = circular_queue.dequeue()
    print(f"{removed} 제거 후: {circular_queue}")

# 다시 추가 (순환 확인)
circular_queue.enqueue("new_item")
print(f"새 원소 추가 후: {circular_queue}")
circular_queue.display()
```

## 3. 연결리스트를 이용한 큐 구현

연결리스트를 사용하면 동적 크기 조절이 더욱 유연하며, 메모리 효율성도 좋습니다.

```python
class QueueNode:
    """큐 노드 클래스"""
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

class LinkedListQueue:
    """
    연결리스트를 이용한 큐 구현
    """
    def __init__(self):
        self._front = None  # 큐의 맨 앞 노드를 가리키는 포인터
        self._rear = None   # 큐의 맨 뒤 노드를 가리키는 포인터
        self._size = 0      # 큐의 크기

    def __len__(self):
        """큐의 크기 반환"""
        return self._size

    def __str__(self):
        """큐를 문자열로 표현 (디버깅용)"""
        if self.isEmpty():
            return "Queue([])"
        
        items = []
        current = self._front
        while current:
            items.append(current.val)
            current = current.next
        
        return f"Queue({items})"

    def isEmpty(self):
        """큐가 비어있는지 확인 O(1)"""
        return self._front is None

    def enqueue(self, item):
        """
        큐의 맨 뒤에 원소 추가 O(1)
        Args:
            item: 추가할 원소
        """
        new_node = QueueNode(item)
        
        if self.isEmpty():
            # 첫 번째 원소인 경우
            self._front = self._rear = new_node
        else:
            # 기존 원소가 있는 경우
            self._rear.next = new_node
            self._rear = new_node
        
        self._size += 1

    def dequeue(self):
        """
        큐의 맨 앞 원소 제거 및 반환 O(1)
        Returns:
            any: 제거된 원소
        Raises:
            IndexError: 큐가 비어있을 때
        """
        if self.isEmpty():
            raise IndexError("Queue is empty")
        
        # 제거할 원소 저장
        removed_item = self._front.val
        
        # front 포인터 업데이트
        self._front = self._front.next
        
        # 큐가 비어있게 되면 rear도 None으로 설정
        if self._front is None:
            self._rear = None
        
        self._size -= 1
        return removed_item

    def front(self):
        """
        큐의 맨 앞 원소 확인 (제거하지 않음) O(1)
        Returns:
            any: 맨 앞 원소
        Raises:
            IndexError: 큐가 비어있을 때
        """
        if self.isEmpty():
            raise IndexError("Queue is empty")
        
        return self._front.val

    def rear(self):
        """
        큐의 맨 뒤 원소 확인 (제거하지 않음) O(1)
        Returns:
            any: 맨 뒤 원소
        Raises:
            IndexError: 큐가 비어있을 때
        """
        if self.isEmpty():
            raise IndexError("Queue is empty")
        
        return self._rear.val

    def size(self):
        """큐의 크기 반환 O(1)"""
        return self._size

    def display(self):
        """큐의 모든 원소를 출력 (디버깅용)"""
        if self.isEmpty():
            print("Queue is empty")
            return
        
        items = []
        current = self._front
        while current:
            items.append(current.val)
            current = current.next
        
        print(f"Queue contents (front to rear): {items}")

# 테스트
linked_queue = LinkedListQueue()
print(f"초기 상태: {linked_queue}")
print(f"비어있는가? {linked_queue.isEmpty()}")

# 원소 추가
linked_queue.enqueue("첫번째")
linked_queue.enqueue("두번째")
linked_queue.enqueue("세번째")
print(f"3개 원소 추가 후: {linked_queue}")
print(f"크기: {len(linked_queue)}")

# 맨 앞과 맨 뒤 원소 확인
print(f"맨 앞 원소: {linked_queue.front()}")
print(f"맨 뒤 원소: {linked_queue.rear()}")

# 원소 제거
print(f"제거된 원소: {linked_queue.dequeue()}")
print(f"제거 후: {linked_queue}")
linked_queue.display()
```

## 4. Python 내장 자료구조 활용

Python에서는 `collections.deque`를 사용하면 양방향 큐를 효율적으로 구현할 수 있습니다.

```python
from collections import deque

# deque를 큐로 사용
def demonstrate_deque_as_queue():
    """deque를 큐로 사용하는 예시"""
    queue = deque()
    
    # enqueue 연산 (append 사용)
    queue.append(1)
    queue.append(2)
    queue.append(3)
    print(f"deque enqueue 후: {list(queue)}")
    
    # front 확인
    if queue:
        print(f"맨 앞 원소: {queue[0]}")
        print(f"맨 뒤 원소: {queue[-1]}")
    
    # dequeue 연산 (popleft 사용)
    while queue:
        dequeued = queue.popleft()
        print(f"deque dequeue: {dequeued}, 남은 큐: {list(queue)}")

demonstrate_deque_as_queue()

# queue 모듈 사용 (스레드 안전)
import queue

def demonstrate_queue_module():
    """queue 모듈을 사용하는 예시 (스레드 안전)"""
    q = queue.Queue(maxsize=3)  # 최대 크기 설정 가능
    
    # 원소 추가
    for i in range(3):
        q.put(i)
        print(f"큐에 {i} 추가")
    
    # 큐가 가득 찬 상태에서 추가 시도
    try:
        q.put(4, timeout=1)  # 1초 타임아웃
    except queue.Full:
        print("큐가 가득 참")
    
    # 원소 제거
    while not q.empty():
        item = q.get()
        print(f"큐에서 {item} 제거")

demonstrate_queue_module()

# 우선순위 큐 (heapq 모듈)
import heapq

def demonstrate_priority_queue():
    """우선순위 큐 예시"""
    priority_queue = []
    
    # 원소 추가 (우선순위, 값) 형태
    heapq.heappush(priority_queue, (3, "높은 우선순위"))
    heapq.heappush(priority_queue, (1, "가장 높은 우선순위"))
    heapq.heappush(priority_queue, (2, "중간 우선순위"))
    
    print("우선순위 큐 내용:")
    while priority_queue:
        priority, value = heapq.heappop(priority_queue)
        print(f"우선순위 {priority}: {value}")

demonstrate_priority_queue()
```

## 5. 큐의 시간복잡도 분석

큐의 주요 연산별 시간복잡도는 다음과 같습니다.

| 연산 | 기본 배열 구현 | 순환 큐 | 연결리스트 구현 | Python deque | 설명 |
|------|----------------|---------|-----------------|---------------|------|
| `enqueue()` | O(1) | O(1) | O(1) | O(1) | 맨 뒤에 원소 추가 |
| `dequeue()` | O(n) | O(1) | O(1) | O(1) | 맨 앞 원소 제거 |
| `front()` | O(1) | O(1) | O(1) | O(1) | 맨 앞 원소 확인 |
| `rear()` | O(1) | O(1) | O(1) | O(1) | 맨 뒤 원소 확인 |
| `isEmpty()` | O(1) | O(1) | O(1) | O(1) | 비어있는지 확인 |
| `size()` | O(1) | O(1) | O(1) | O(1) | 크기 반환 |

**공간복잡도:**
- **기본 배열 구현**: O(n) - 동적 배열 사용
- **순환 큐**: O(n) - 고정 크기 배열 사용
- **연결리스트 구현**: O(n) - 노드당 추가 메모리 오버헤드
- **Python deque**: O(n) - 이중 연결리스트 기반

## 6. 큐 vs 다른 자료구조 비교

### 6-1 큐 vs 스택

| 특성 | 큐 (Queue) | 스택 (Stack) |
|------|------------|--------------|
| **구조** | FIFO (First In, First Out) | LIFO (Last In, First Out) |
| **접근 방식** | 양쪽 끝 (front, rear) | 한쪽 끝 (top) |
| **주요 연산** | enqueue, dequeue, front | push, pop, peek |
| **사용 예시** | 대기열, BFS, 프로세스 스케줄링 | 함수 호출, 괄호 매칭, DFS |

### 6-2 큐 vs 배열

| 특성 | 큐 | 배열 |
|------|----|----|
| **접근 제한** | front와 rear에서만 접근 | 인덱스로 임의 접근 |
| **연산 제한** | enqueue, dequeue만 가능 | 임의 위치 삽입/삭제 |
| **용도** | 순서가 중요한 데이터 처리 | 일반적인 데이터 저장 |
| **구현** | 배열이나 연결리스트로 구현 | 직접적인 자료구조 |

### 6-3 다양한 큐 구현 방식 비교

| 구현 방식 | 장점 | 단점 | 사용 상황 |
|-----------|------|------|-----------|
| **기본 배열** | 구현 간단 | dequeue가 O(n) | 작은 데이터셋 |
| **순환 큐** | 모든 연산 O(1) | 고정 크기 | 크기가 예측 가능한 경우 |
| **연결리스트** | 동적 크기, 모든 연산 O(1) | 메모리 오버헤드 | 크기가 변동적인 경우 |
| **deque** | 양방향 접근, 최적화됨 | 외부 라이브러리 의존 | 일반적인 사용 |

## 정리

이번 포스트에서는 큐의 기본 개념과 다양한 구현 방법에 대해 알아보았습니다.

**핵심 개념 정리**
1. **FIFO 구조**: 가장 먼저 들어온 원소가 가장 먼저 나가는 구조
2. **양방향 접근**: front에서 제거, rear에서 추가
3. **효율적인 연산**: 적절한 구현으로 모든 기본 연산이 O(1)
4. **다양한 구현**: 배열, 순환 큐, 연결리스트, Python 내장 자료구조 활용
5. **스택과의 차이**: FIFO vs LIFO, 접근 방식의 차이

**다음 학습 계획**
다음 포스트에서는 큐를 활용한 다양한 문제 해결 방법과 알고리즘에 대해 알아보겠습니다:
- [[자료구조] 큐(Queue) - 활용 - 1]({% post_url 2025-10-05-[자료구조] 큐(Queue) - 활용 - 1 %}) - BFS, 레벨 순회 등 기본 문제들
- [[자료구조] 큐(Queue) - 활용 - 2]({% post_url 2025-10-05-[자료구조] 큐(Queue) - 활용 - 2 %}) - 우선순위 큐, 이중 큐, 스레드 풀 등
- [[자료구조] 큐(Queue) - 활용 - 3]({% post_url 2025-10-05-[자료구조] 큐(Queue) - 활용 - 3 %}) - 메시지 큐, 작업 큐, 이벤트 시스템 등

# 📚 레퍼런스
- [Queue Data Structure - Wikipedia](https://en.wikipedia.org/wiki/Queue_(abstract_data_type))
- [GeeksforGeeks - Queue Data Structure](https://www.geeksforgeeks.org/queue-data-structure/)
- [Python Collections - deque](https://docs.python.org/3/library/collections.html#collections.deque)
- [Python Queue Module](https://docs.python.org/3/library/queue.html)

---
*이 포스트는 자료구조 학습 과정을 정리한 내용입니다.*
