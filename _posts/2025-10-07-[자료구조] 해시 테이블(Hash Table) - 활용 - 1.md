---
layout: post
title: "[자료구조] 해시 테이블(Hash Table) - 활용 - 1"
date: 2025-10-07 16:00:00 +0900
categories: [자료구조, 해시테이블]
tags: [자료구조, 해시테이블, 문제해결, 알고리즘, 중복체크, 빈도계산, 두수의합]
author: LimJongHan
toc: true
---

# 📖 관련된 내 포스팅
- [[자료구조] 자료구조와 알고리즘 개요]({% post_url 2025-10-02-[자료구조] 자료구조와 알고리즘 개요 %})
- [[자료구조] 해시 테이블(Hash Table) - 기본 예제]({% post_url 2025-10-07-[자료구조] 해시 테이블(Hash Table) - 기본 예제 %})

# 📝 내용

## 개요

해시 테이블의 O(1) 시간복잡도 특성은 다양한 문제 해결에 매우 유용합니다. 이번 포스트에서는 해시 테이블을 활용한 실전 문제 해결 예제들을 살펴보겠습니다.

**다룰 예제들:**
- **중복 검사**: 배열에서 중복 원소 찾기
- **빈도 계산**: 원소의 출현 빈도 세기
- **두 수의 합**: 합이 특정 값이 되는 두 수 찾기
- **그룹 애너그램**: 애너그램 그룹화
- **부분 배열의 합**: 누적 합을 이용한 문제 해결

## 1. 중복 검사

### 1-1 배열에서 중복 원소 찾기

```python
def contains_duplicate(nums):
    """
    배열에 중복 원소가 있는지 확인
    Args:
        nums (list): 정수 배열
    Returns:
        bool: 중복이 있으면 True
    """
    seen = set()
    
    for num in nums:
        if num in seen:
            return True
        seen.add(num)
    
    return False

# 테스트
test_cases = [
    [1, 2, 3, 1],      # True (1이 중복)
    [1, 2, 3, 4],      # False
    [1, 1, 1, 3, 3, 4, 3, 2, 4, 2],  # True
]

for nums in test_cases:
    result = contains_duplicate(nums)
    print(f"{nums} -> 중복: {result}")
```

### 1-2 첫 번째 중복 원소 찾기

```python
def find_first_duplicate(nums):
    """
    배열에서 처음 중복되는 원소 찾기
    Args:
        nums (list): 정수 배열
    Returns:
        int: 첫 번째 중복 원소, 없으면 None
    """
    seen = set()
    
    for num in nums:
        if num in seen:
            return num
        seen.add(num)
    
    return None

# 테스트
nums = [2, 5, 1, 2, 3, 5, 1, 2, 4]
result = find_first_duplicate(nums)
print(f"배열: {nums}")
print(f"첫 번째 중복 원소: {result}")
```

### 1-3 모든 중복 원소 찾기

```python
def find_all_duplicates(nums):
    """
    배열에서 모든 중복 원소 찾기
    Args:
        nums (list): 정수 배열
    Returns:
        list: 중복된 원소들의 리스트
    """
    count = {}
    duplicates = []
    
    for num in nums:
        count[num] = count.get(num, 0) + 1
    
    for num, freq in count.items():
        if freq > 1:
            duplicates.append(num)
    
    return duplicates

# 테스트
nums = [4, 3, 2, 7, 8, 2, 3, 1]
result = find_all_duplicates(nums)
print(f"배열: {nums}")
print(f"중복 원소들: {result}")
```

## 2. 빈도 계산

### 2-1 원소의 출현 빈도 세기

```python
def frequency_count(arr):
    """
    배열의 각 원소 출현 빈도 계산
    Args:
        arr (list): 배열
    Returns:
        dict: 원소별 출현 빈도
    """
    freq = {}
    
    for item in arr:
        freq[item] = freq.get(item, 0) + 1
    
    return freq

# Counter 사용
from collections import Counter

def frequency_count_counter(arr):
    """Counter를 이용한 빈도 계산"""
    return dict(Counter(arr))

# 테스트
arr = ['apple', 'banana', 'apple', 'orange', 'banana', 'apple']

freq1 = frequency_count(arr)
freq2 = frequency_count_counter(arr)

print(f"배열: {arr}")
print(f"빈도 (딕셔너리): {freq1}")
print(f"빈도 (Counter): {freq2}")
```

### 2-2 가장 빈번한 원소 찾기

```python
def most_frequent(arr):
    """
    가장 빈번하게 나타나는 원소 찾기
    Args:
        arr (list): 배열
    Returns:
        tuple: (원소, 빈도)
    """
    if not arr:
        return None, 0
    
    freq = {}
    max_freq = 0
    max_element = None
    
    for item in arr:
        freq[item] = freq.get(item, 0) + 1
        
        if freq[item] > max_freq:
            max_freq = freq[item]
            max_element = item
    
    return max_element, max_freq

# 테스트
arr = [1, 3, 2, 1, 4, 1, 5, 2, 1]
element, frequency = most_frequent(arr)
print(f"배열: {arr}")
print(f"가장 빈번한 원소: {element} (빈도: {frequency})")
```

### 2-3 빈도 기준 정렬

```python
def sort_by_frequency(arr):
    """
    빈도 순으로 배열 정렬 (빈도가 높은 것부터)
    Args:
        arr (list): 배열
    Returns:
        list: 빈도순으로 정렬된 배열
    """
    freq = {}
    
    for item in arr:
        freq[item] = freq.get(item, 0) + 1
    
    # 빈도순으로 정렬 (빈도 내림차순, 값 오름차순)
    sorted_items = sorted(freq.items(), key=lambda x: (-x[1], x[0]))
    
    result = []
    for item, count in sorted_items:
        result.extend([item] * count)
    
    return result

# 테스트
arr = [1, 1, 2, 2, 2, 3, 4, 4, 4, 4]
sorted_arr = sort_by_frequency(arr)
print(f"원본: {arr}")
print(f"빈도순 정렬: {sorted_arr}")
```

## 3. 두 수의 합 (Two Sum)

### 3-1 기본 두 수의 합

```python
def two_sum(nums, target):
    """
    합이 target이 되는 두 수의 인덱스 찾기
    Args:
        nums (list): 정수 배열
        target (int): 목표 합
    Returns:
        list: 두 수의 인덱스, 없으면 None
    """
    num_map = {}
    
    for i, num in enumerate(nums):
        complement = target - num
        
        if complement in num_map:
            return [num_map[complement], i]
        
        num_map[num] = i
    
    return None

# 테스트
nums = [2, 7, 11, 15]
target = 9

result = two_sum(nums, target)
print(f"배열: {nums}, 목표: {target}")
print(f"인덱스: {result}")
if result:
    print(f"값: [{nums[result[0]]}, {nums[result[1]]}]")
```

### 3-2 모든 두 수의 합 쌍 찾기

```python
def two_sum_all_pairs(nums, target):
    """
    합이 target이 되는 모든 두 수의 쌍 찾기
    Args:
        nums (list): 정수 배열
        target (int): 목표 합
    Returns:
        list: 두 수 쌍들의 리스트
    """
    num_map = {}
    pairs = []
    seen_pairs = set()
    
    for num in nums:
        complement = target - num
        
        if complement in num_map:
            pair = tuple(sorted([num, complement]))
            if pair not in seen_pairs:
                pairs.append(list(pair))
                seen_pairs.add(pair)
        
        num_map[num] = num_map.get(num, 0) + 1
    
    return pairs

# 테스트
nums = [1, 5, 3, 2, 4, 3, 5, 1]
target = 6

pairs = two_sum_all_pairs(nums, target)
print(f"배열: {nums}, 목표: {target}")
print(f"모든 쌍: {pairs}")
```

### 3-3 세 수의 합 (Three Sum)

```python
def three_sum(nums, target=0):
    """
    합이 target이 되는 세 수의 조합 찾기
    Args:
        nums (list): 정수 배열
        target (int): 목표 합 (기본값 0)
    Returns:
        list: 세 수 조합들의 리스트
    """
    nums.sort()
    result = []
    
    for i in range(len(nums) - 2):
        # 중복 건너뛰기
        if i > 0 and nums[i] == nums[i-1]:
            continue
        
        left = i + 1
        right = len(nums) - 1
        
        while left < right:
            current_sum = nums[i] + nums[left] + nums[right]
            
            if current_sum == target:
                result.append([nums[i], nums[left], nums[right]])
                
                # 중복 건너뛰기
                while left < right and nums[left] == nums[left + 1]:
                    left += 1
                while left < right and nums[right] == nums[right - 1]:
                    right -= 1
                
                left += 1
                right -= 1
            elif current_sum < target:
                left += 1
            else:
                right -= 1
    
    return result

# 테스트
nums = [-1, 0, 1, 2, -1, -4]
result = three_sum(nums, 0)
print(f"배열: {nums}")
print(f"합이 0인 세 수 조합: {result}")
```

## 4. 그룹 애너그램

애너그램은 같은 문자를 재배열하여 만들 수 있는 단어들입니다.

```python
def group_anagrams(strs):
    """
    애너그램 그룹화
    Args:
        strs (list): 문자열 배열
    Returns:
        list: 애너그램 그룹들의 리스트
    """
    anagram_map = {}
    
    for s in strs:
        # 정렬된 문자열을 키로 사용
        key = ''.join(sorted(s))
        
        if key not in anagram_map:
            anagram_map[key] = []
        
        anagram_map[key].append(s)
    
    return list(anagram_map.values())

def group_anagrams_optimized(strs):
    """
    최적화된 애너그램 그룹화 (문자 카운트 사용)
    """
    from collections import defaultdict
    
    anagram_map = defaultdict(list)
    
    for s in strs:
        # 각 문자의 빈도를 키로 사용
        count = [0] * 26
        for char in s:
            count[ord(char) - ord('a')] += 1
        
        key = tuple(count)
        anagram_map[key].append(s)
    
    return list(anagram_map.values())

# 테스트
strs = ["eat", "tea", "tan", "ate", "nat", "bat"]

groups1 = group_anagrams(strs)
groups2 = group_anagrams_optimized(strs)

print(f"문자열: {strs}")
print(f"애너그램 그룹 (정렬): {groups1}")
print(f"애너그램 그룹 (카운트): {groups2}")
```

## 5. 부분 배열의 합

### 5-1 누적 합을 이용한 부분 배열 합 계산

```python
def subarray_sum_equals_k(nums, k):
    """
    합이 k인 부분 배열의 개수 찾기
    Args:
        nums (list): 정수 배열
        k (int): 목표 합
    Returns:
        int: 부분 배열의 개수
    """
    count = 0
    current_sum = 0
    sum_freq = {0: 1}  # 누적 합의 빈도
    
    for num in nums:
        current_sum += num
        
        # current_sum - k가 이전에 나온 적이 있다면
        # 그 지점부터 현재까지의 부분 배열 합이 k
        if current_sum - k in sum_freq:
            count += sum_freq[current_sum - k]
        
        # 현재 누적 합의 빈도 증가
        sum_freq[current_sum] = sum_freq.get(current_sum, 0) + 1
    
    return count

# 테스트
nums = [1, 1, 1]
k = 2

result = subarray_sum_equals_k(nums, k)
print(f"배열: {nums}, k: {k}")
print(f"합이 {k}인 부분 배열 개수: {result}")

# 더 복잡한 예제
nums2 = [1, 2, 3, -3, 1, 1, 1, 4, 2, -3]
k2 = 3

result2 = subarray_sum_equals_k(nums2, k2)
print(f"\n배열: {nums2}, k: {k2}")
print(f"합이 {k2}인 부분 배열 개수: {result2}")
```

### 5-2 최장 부분 배열 찾기

```python
def longest_subarray_sum_k(nums, k):
    """
    합이 k인 가장 긴 부분 배열의 길이 찾기
    Args:
        nums (list): 정수 배열
        k (int): 목표 합
    Returns:
        int: 최장 부분 배열의 길이
    """
    max_length = 0
    current_sum = 0
    sum_index = {}
    
    for i, num in enumerate(nums):
        current_sum += num
        
        # 처음부터 현재까지의 합이 k인 경우
        if current_sum == k:
            max_length = i + 1
        
        # current_sum - k가 이전에 나온 적이 있다면
        if current_sum - k in sum_index:
            max_length = max(max_length, i - sum_index[current_sum - k])
        
        # 누적 합이 처음 나온 경우에만 인덱스 저장
        if current_sum not in sum_index:
            sum_index[current_sum] = i
    
    return max_length

# 테스트
nums = [1, -1, 5, -2, 3]
k = 3

result = longest_subarray_sum_k(nums, k)
print(f"배열: {nums}, k: {k}")
print(f"합이 {k}인 최장 부분 배열 길이: {result}")
```

## 정리

이번 포스트에서는 해시 테이블을 활용한 실전 문제 해결 예제들을 살펴보았습니다.

**핵심 예제 정리**
1. **중복 검사**: O(n) 시간으로 효율적인 중복 찾기
2. **빈도 계산**: 원소의 출현 빈도를 빠르게 계산
3. **두 수의 합**: O(n) 시간복잡도로 쌍 찾기
4. **그룹 애너그램**: 문자열을 효율적으로 그룹화
5. **부분 배열의 합**: 누적 합과 해시 테이블의 조합

**해시 테이블 활용의 핵심 원칙**
- **빠른 검색**: O(1) 검색으로 시간복잡도 최적화
- **중복 제거**: Set을 이용한 효율적인 중복 처리
- **빈도 추적**: Dictionary로 출현 빈도 관리
- **보완 값 찾기**: target - current 패턴 활용
- **누적 합 저장**: 부분 배열 문제의 최적화

**다음 학습 계획**
다음 포스트에서는 해시 테이블의 고급 활용과 알고리즘 최적화를 알아보겠습니다:
- [[자료구조] 해시 테이블 활용 - 2]({% post_url 2025-10-07-[자료구조] 해시 테이블(Hash Table) - 활용 - 2 %}) - 블룸 필터, 일관성 해싱, LRU 캐시 등
- [[자료구조] 해시 테이블 활용 - 3]({% post_url 2025-10-07-[자료구조] 해시 테이블(Hash Table) - 활용 - 3 %}) - 데이터베이스 인덱싱, 세션 관리 등

# 📚 레퍼런스
- [Two Sum - LeetCode](https://leetcode.com/problems/two-sum/)
- [Group Anagrams - LeetCode](https://leetcode.com/problems/group-anagrams/)
- [Subarray Sum Equals K - LeetCode](https://leetcode.com/problems/subarray-sum-equals-k/)
- [Hash Table Problems - GeeksforGeeks](https://www.geeksforgeeks.org/hashing-data-structure/)

---
*이 포스트는 자료구조 학습 과정을 정리한 내용입니다.*
