---
layout: post
title: "[학습] [자료구조] 배열(Array) 활용 - 3. 실무 활용"
date: 2025-10-03 01:55:00 +0900
categories: [학습, 자료구조]
tags: [배열, Array, 실무활용, 웹개발, 데이터분석, 게임개발, 시스템설계]
author: LimJongHan
toc: true
---

# 📖 관련된 내 포스팅
- [[학습] [자료구조] 배열(Array)]({% post_url 2025-10-03-[학습][자료구조] 배열(Array) %})
- [[학습] [자료구조] 배열(Array) 활용 - 1. 예제]({% post_url 2025-10-03-[학습][자료구조] 배열(Array) 활용 - 1. 예제 %})
- [[학습] [자료구조] 배열(Array) 활용 - 2. 알고리즘 활용]({% post_url 2025-10-03-[학습][자료구조] 배열(Array) 활용 - 2. 알고리즘 활용 %})

# 📝 내용

## 개요

이전 포스트들에서 배열의 기본 개념, 문제 해결 예제, 그리고 고급 알고리즘 기법들을 다뤘습니다. 이번 포스트에서는 이러한 지식들을 실제 프로젝트와 실무 상황에 적용하는 방법을 알아보겠습니다.

**이번 포스트에서 다룰 실무 활용 분야:**
- 🌐 **웹 개발**: 사용자 세션 관리, 캐시 시스템, 데이터 처리
- 📊 **데이터 분석**: 통계 계산, 이상치 탐지, 시계열 분석
- 🎮 **게임 개발**: 게임 보드, 인벤토리 시스템, 점수 관리
- 🏗️ **시스템 설계**: 메모리 관리, 성능 최적화, 확장성 고려

실무에서는 단순한 알고리즘 구현을 넘어서 비즈니스 요구사항과 성능을 모두 고려한 설계가 필요합니다.

## 핵심 내용

### 1. 웹 개발에서의 배열 활용

#### 1-1 사용자 세션 관리 시스템

```python
import time
from typing import Dict, List, Optional
from dataclasses import dataclass

@dataclass
class UserSession:
    """사용자 세션 데이터 클래스"""
    user_id: str
    session_id: str
    created_at: float
    last_activity: float
    ip_address: str
    user_agent: str
    data: Dict

class SessionManager:
    """사용자 세션을 배열로 관리하는 클래스"""
    
    def __init__(self, max_sessions: int = 10000):
        self.sessions: List[Optional[UserSession]] = []
        self.session_map: Dict[str, int] = {}  # session_id -> index
        self.user_map: Dict[str, List[int]] = {}  # user_id -> session_indices
        self.max_sessions = max_sessions
        self.next_index = 0
    
    def create_session(self, user_id: str, ip_address: str, user_agent: str, data: Dict = None) -> str:
        """새 세션 생성"""
        if data is None:
            data = {}
        
        session_id = f"session_{int(time.time())}_{user_id}"
        current_time = time.time()
        
        session = UserSession(
            user_id=user_id,
            session_id=session_id,
            created_at=current_time,
            last_activity=current_time,
            ip_address=ip_address,
            user_agent=user_agent,
            data=data
        )
        
        # 배열에 세션 저장
        if self.next_index < len(self.sessions):
            # 기존 슬롯 재사용
            self.sessions[self.next_index] = session
        else:
            # 새 슬롯 추가
            self.sessions.append(session)
        
        # 인덱스 매핑 업데이트
        self.session_map[session_id] = self.next_index
        
        if user_id not in self.user_map:
            self.user_map[user_id] = []
        self.user_map[user_id].append(self.next_index)
        
        # 다음 인덱스 찾기
        self._find_next_available_index()
        
        return session_id
    
    def get_session(self, session_id: str) -> Optional[UserSession]:
        """세션 정보 조회 및 활동 시간 업데이트"""
        if session_id not in self.session_map:
            return None
        
        index = self.session_map[session_id]
        session = self.sessions[index]
        
        if session is None:
            # 세션이 이미 삭제됨
            del self.session_map[session_id]
            return None
        
        # 활동 시간 업데이트
        session.last_activity = time.time()
        return session
    
    def invalidate_session(self, session_id: str) -> bool:
        """세션 무효화"""
        if session_id not in self.session_map:
            return False
        
        index = self.session_map[session_id]
        session = self.sessions[index]
        
        if session is None:
            return False
        
        # 사용자 매핑에서 제거
        user_id = session.user_id
        if user_id in self.user_map:
            self.user_map[user_id].remove(index)
            if not self.user_map[user_id]:
                del self.user_map[user_id]
        
        # 세션 삭제
        self.sessions[index] = None
        del self.session_map[session_id]
        
        return True
    
    def get_user_sessions(self, user_id: str) -> List[UserSession]:
        """특정 사용자의 모든 세션 조회"""
        if user_id not in self.user_map:
            return []
        
        sessions = []
        for index in self.user_map[user_id]:
            session = self.sessions[index]
            if session is not None:
                sessions.append(session)
        
        return sessions
    
    def cleanup_expired_sessions(self, timeout: int = 3600) -> int:
        """만료된 세션 정리"""
        current_time = time.time()
        cleaned_count = 0
        
        for i, session in enumerate(self.sessions):
            if session is None:
                continue
            
            if current_time - session.last_activity > timeout:
                self.invalidate_session(session.session_id)
                cleaned_count += 1
        
        return cleaned_count
    
    def get_active_users(self) -> List[str]:
        """활성 사용자 목록 반환"""
        return list(self.user_map.keys())
    
    def get_session_statistics(self) -> Dict:
        """세션 통계 정보"""
        total_sessions = len(self.session_map)
        total_users = len(self.user_map)
        active_sessions = sum(1 for s in self.sessions if s is not None)
        
        return {
            'total_sessions': total_sessions,
            'total_users': total_users,
            'active_sessions': active_sessions,
            'session_utilization': active_sessions / len(self.sessions) if self.sessions else 0
        }
    
    def _find_next_available_index(self):
        """다음 사용 가능한 인덱스 찾기"""
        for i in range(len(self.sessions)):
            if self.sessions[i] is None:
                self.next_index = i
                return
        
        self.next_index = len(self.sessions)

# 사용 예시
if __name__ == "__main__":
    session_mgr = SessionManager()
    
    # 세션 생성
    session1 = session_mgr.create_session("user1", "192.168.1.1", "Chrome", {"role": "admin"})
    session2 = session_mgr.create_session("user2", "192.168.1.2", "Firefox", {"role": "user"})
    session3 = session_mgr.create_session("user1", "192.168.1.3", "Safari", {"role": "admin"})
    
    print(f"생성된 세션: {session1}, {session2}, {session3}")
    
    # 세션 조회
    session_info = session_mgr.get_session(session1)
    print(f"세션 정보: {session_info}")
    
    # 사용자 세션 목록
    user_sessions = session_mgr.get_user_sessions("user1")
    print(f"user1의 세션 수: {len(user_sessions)}")
    
    # 통계 정보
    stats = session_mgr.get_session_statistics()
    print(f"세션 통계: {stats}")
```

#### 1-2 캐시 시스템 구현

```python
from collections import OrderedDict
import time
from typing import Any, Optional

class LRUCache:
    """Least Recently Used 캐시 구현"""
    
    def __init__(self, capacity: int):
        self.capacity = capacity
        self.cache = OrderedDict()
        self.access_times = {}
    
    def get(self, key: str) -> Optional[Any]:
        """캐시에서 값 조회"""
        if key in self.cache:
            # 접근 시간 업데이트 및 순서 변경
            self.access_times[key] = time.time()
            self.cache.move_to_end(key)
            return self.cache[key]
        return None
    
    def put(self, key: str, value: Any) -> None:
        """캐시에 값 저장"""
        if key in self.cache:
            # 기존 키 업데이트
            self.cache[key] = value
            self.access_times[key] = time.time()
            self.cache.move_to_end(key)
        else:
            # 새 키 추가
            if len(self.cache) >= self.capacity:
                # 가장 오래된 항목 제거
                oldest_key = next(iter(self.cache))
                del self.cache[oldest_key]
                del self.access_times[oldest_key]
            
            self.cache[key] = value
            self.access_times[key] = time.time()
    
    def invalidate(self, key: str) -> bool:
        """캐시에서 특정 키 제거"""
        if key in self.cache:
            del self.cache[key]
            del self.access_times[key]
            return True
        return False
    
    def clear(self) -> None:
        """캐시 전체 초기화"""
        self.cache.clear()
        self.access_times.clear()
    
    def get_statistics(self) -> Dict:
        """캐시 통계 정보"""
        current_time = time.time()
        recent_accesses = sum(1 for access_time in self.access_times.values() 
                            if current_time - access_time < 300)  # 5분 이내
        
        return {
            'size': len(self.cache),
            'capacity': self.capacity,
            'utilization': len(self.cache) / self.capacity,
            'recent_accesses': recent_accesses
        }

class CacheManager:
    """여러 캐시를 관리하는 클래스"""
    
    def __init__(self):
        self.caches = {}
    
    def create_cache(self, name: str, capacity: int) -> LRUCache:
        """새 캐시 생성"""
        cache = LRUCache(capacity)
        self.caches[name] = cache
        return cache
    
    def get_cache(self, name: str) -> Optional[LRUCache]:
        """캐시 조회"""
        return self.caches.get(name)
    
    def get_all_statistics(self) -> Dict:
        """모든 캐시의 통계 정보"""
        stats = {}
        for name, cache in self.caches.items():
            stats[name] = cache.get_statistics()
        return stats

# 사용 예시
if __name__ == "__main__":
    # 캐시 생성
    cache = LRUCache(3)
    
    # 데이터 저장
    cache.put("user:1", {"name": "Alice", "email": "alice@example.com"})
    cache.put("user:2", {"name": "Bob", "email": "bob@example.com"})
    cache.put("user:3", {"name": "Charlie", "email": "charlie@example.com"})
    
    # 캐시 조회
    user_data = cache.get("user:1")
    print(f"사용자 데이터: {user_data}")
    
    # 캐시 통계
    stats = cache.get_statistics()
    print(f"캐시 통계: {stats}")
```

### 2. 데이터 분석에서의 배열 활용

#### 2-1 고급 데이터 분석 클래스

```python
import statistics
import math
from typing import List, Tuple, Optional
from dataclasses import dataclass

@dataclass
class DataPoint:
    """데이터 포인트 클래스"""
    value: float
    timestamp: float
    metadata: dict = None

class AdvancedDataAnalyzer:
    """고급 데이터 분석을 위한 클래스"""
    
    def __init__(self):
        self.data: List[DataPoint] = []
        self.statistics_cache = None
    
    def add_data_point(self, value: float, timestamp: float = None, metadata: dict = None):
        """데이터 포인트 추가"""
        if timestamp is None:
            timestamp = time.time()
        
        data_point = DataPoint(value, timestamp, metadata or {})
        self.data.append(data_point)
        
        # 통계 캐시 무효화
        self.statistics_cache = None
    
    def get_basic_statistics(self) -> dict:
        """기본 통계 정보 계산"""
        if not self.data:
            return None
        
        values = [dp.value for dp in self.data]
        
        return {
            'count': len(values),
            'mean': statistics.mean(values),
            'median': statistics.median(values),
            'mode': statistics.mode(values) if len(set(values)) < len(values) else None,
            'min': min(values),
            'max': max(values),
            'range': max(values) - min(values),
            'std_dev': statistics.stdev(values) if len(values) > 1 else 0,
            'variance': statistics.variance(values) if len(values) > 1 else 0
        }
    
    def detect_outliers(self, method: str = 'iqr', threshold: float = 1.5) -> List[Tuple[int, DataPoint, float]]:
        """
        이상치 탐지
        
        Args:
            method: 'iqr', 'zscore', 'modified_zscore'
            threshold: 임계값
        """
        if len(self.data) < 3:
            return []
        
        values = [dp.value for dp in self.data]
        outliers = []
        
        if method == 'iqr':
            # IQR 방법
            q1 = statistics.quantiles(values, n=4)[0]
            q3 = statistics.quantiles(values, n=4)[2]
            iqr = q3 - q1
            lower_bound = q1 - threshold * iqr
            upper_bound = q3 + threshold * iqr
            
            for i, dp in enumerate(self.data):
                if dp.value < lower_bound or dp.value > upper_bound:
                    outliers.append((i, dp, dp.value))
        
        elif method == 'zscore':
            # Z-score 방법
            mean = statistics.mean(values)
            std_dev = statistics.stdev(values)
            
            for i, dp in enumerate(self.data):
                z_score = abs((dp.value - mean) / std_dev)
                if z_score > threshold:
                    outliers.append((i, dp, z_score))
        
        elif method == 'modified_zscore':
            # Modified Z-score 방법
            median = statistics.median(values)
            mad = statistics.median([abs(x - median) for x in values])
            
            for i, dp in enumerate(self.data):
                modified_z_score = 0.6745 * (dp.value - median) / mad
                if abs(modified_z_score) > threshold:
                    outliers.append((i, dp, modified_z_score))
        
        return outliers
    
    def moving_average(self, window_size: int, method: str = 'simple') -> List[float]:
        """
        이동평균 계산
        
        Args:
            window_size: 윈도우 크기
            method: 'simple', 'exponential', 'weighted'
        """
        if len(self.data) < window_size:
            return []
        
        values = [dp.value for dp in self.data]
        moving_averages = []
        
        if method == 'simple':
            # 단순 이동평균
            for i in range(window_size - 1, len(values)):
                window_sum = sum(values[i - window_size + 1:i + 1])
                moving_averages.append(window_sum / window_size)
        
        elif method == 'weighted':
            # 가중 이동평균 (최근 데이터에 더 높은 가중치)
            weights = list(range(1, window_size + 1))
            weight_sum = sum(weights)
            
            for i in range(window_size - 1, len(values)):
                window_values = values[i - window_size + 1:i + 1]
                weighted_sum = sum(val * weight for val, weight in zip(window_values, weights))
                moving_averages.append(weighted_sum / weight_sum)
        
        elif method == 'exponential':
            # 지수 이동평균
            alpha = 2 / (window_size + 1)
            ema = values[0]
            moving_averages.append(ema)
            
            for i in range(1, len(values)):
                ema = alpha * values[i] + (1 - alpha) * ema
                moving_averages.append(ema)
        
        return moving_averages
    
    def find_trends(self, window_size: int = 10) -> List[str]:
        """트렌드 분석"""
        if len(self.data) < window_size * 2:
            return []
        
        moving_avg = self.moving_average(window_size)
        trends = []
        
        for i in range(1, len(moving_avg)):
            if moving_avg[i] > moving_avg[i-1] * 1.02:  # 2% 이상 증가
                trends.append('increasing')
            elif moving_avg[i] < moving_avg[i-1] * 0.98:  # 2% 이상 감소
                trends.append('decreasing')
            else:
                trends.append('stable')
        
        return trends
    
    def get_time_series_data(self, start_time: float = None, end_time: float = None) -> List[DataPoint]:
        """시간 범위에 따른 데이터 조회"""
        filtered_data = []
        
        for dp in self.data:
            if start_time and dp.timestamp < start_time:
                continue
            if end_time and dp.timestamp > end_time:
                continue
            filtered_data.append(dp)
        
        return filtered_data
    
    def export_to_csv(self, filename: str) -> None:
        """CSV 파일로 데이터 내보내기"""
        import csv
        
        with open(filename, 'w', newline='') as csvfile:
            fieldnames = ['timestamp', 'value', 'metadata']
            writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
            
            writer.writeheader()
            for dp in self.data:
                writer.writerow({
                    'timestamp': dp.timestamp,
                    'value': dp.value,
                    'metadata': str(dp.metadata) if dp.metadata else ''
                })

# 사용 예시
if __name__ == "__main__":
    analyzer = AdvancedDataAnalyzer()
    
    # 샘플 데이터 추가
    import random
    base_value = 100
    for i in range(100):
        # 정상 데이터 + 노이즈 + 이상치
        if i == 50:  # 이상치
            value = base_value + 50
        else:
            value = base_value + random.gauss(0, 5)
        
        analyzer.add_data_point(value, time.time() + i, {"source": "sensor1"})
    
    # 통계 정보
    stats = analyzer.get_basic_statistics()
    print("기본 통계:")
    for key, value in stats.items():
        print(f"  {key}: {value:.2f}")
    
    # 이상치 탐지
    outliers = analyzer.detect_outliers(method='iqr')
    print(f"\n이상치 개수: {len(outliers)}")
    for i, dp, score in outliers:
        print(f"  인덱스 {i}: 값 {dp.value:.2f}, 점수 {score:.2f}")
    
    # 이동평균
    ma = analyzer.moving_average(10, method='weighted')
    print(f"\n가중 이동평균 (처음 5개): {ma[:5]}")
    
    # 트렌드 분석
    trends = analyzer.find_trends()
    print(f"\n트렌드 분석 (처음 10개): {trends[:10]}")
```

### 3. 게임 개발에서의 배열 활용

#### 3-1 게임 보드 시스템

```python
from enum import Enum
from typing import List, Tuple, Optional
import random

class CellState(Enum):
    """셀 상태 열거형"""
    EMPTY = 0
    PLAYER1 = 1
    PLAYER2 = 2
    BLOCKED = -1

class GameBoard:
    """게임 보드를 배열로 구현"""
    
    def __init__(self, rows: int, cols: int):
        self.rows = rows
        self.cols = cols
        self.board = [[CellState.EMPTY for _ in range(cols)] for _ in range(rows)]
        self.move_history = []
    
    def get_cell(self, row: int, col: int) -> CellState:
        """셀 상태 조회"""
        if not self._is_valid_position(row, col):
            raise IndexError("잘못된 보드 위치입니다")
        return self.board[row][col]
    
    def set_cell(self, row: int, col: int, state: CellState) -> bool:
        """셀 상태 설정"""
        if not self._is_valid_position(row, col):
            return False
        
        if self.board[row][col] != CellState.EMPTY:
            return False
        
        self.board[row][col] = state
        self.move_history.append((row, col, state))
        return True
    
    def clear_cell(self, row: int, col: int) -> bool:
        """셀 초기화"""
        if not self._is_valid_position(row, col):
            return False
        
        self.board[row][col] = CellState.EMPTY
        return True
    
    def get_empty_cells(self) -> List[Tuple[int, int]]:
        """빈 셀들의 위치 반환"""
        empty_cells = []
        for row in range(self.rows):
            for col in range(self.cols):
                if self.board[row][col] == CellState.EMPTY:
                    empty_cells.append((row, col))
        return empty_cells
    
    def check_line(self, start_row: int, start_col: int, direction: str, length: int, player: CellState) -> bool:
        """
        연속된 같은 상태가 있는지 확인
        
        Args:
            start_row: 시작 행
            start_col: 시작 열
            direction: 방향 ('horizontal', 'vertical', 'diagonal_down', 'diagonal_up')
            length: 연속 길이
            player: 확인할 플레이어 상태
        """
        row, col = start_row, start_col
        
        for _ in range(length):
            if (not self._is_valid_position(row, col) or 
                self.board[row][col] != player):
                return False
            
            # 방향에 따라 다음 위치 계산
            if direction == 'horizontal':
                col += 1
            elif direction == 'vertical':
                row += 1
            elif direction == 'diagonal_down':
                row += 1
                col += 1
            elif direction == 'diagonal_up':
                row -= 1
                col += 1
        
        return True
    
    def check_winner(self, player: CellState, win_length: int = 3) -> bool:
        """승리 조건 확인"""
        directions = ['horizontal', 'vertical', 'diagonal_down', 'diagonal_up']
        
        for row in range(self.rows):
            for col in range(self.cols):
                for direction in directions:
                    if self.check_line(row, col, direction, win_length, player):
                        return True
        
        return False
    
    def get_board_state(self) -> List[List[int]]:
        """보드 상태를 정수 배열로 반환"""
        return [[cell.value for cell in row] for row in self.board]
    
    def display(self):
        """보드 출력"""
        print("  " + " ".join(str(i) for i in range(self.cols)))
        for i, row in enumerate(self.board):
            row_str = str(i) + " "
            for cell in row:
                if cell == CellState.EMPTY:
                    row_str += " . "
                elif cell == CellState.PLAYER1:
                    row_str += " X "
                elif cell == CellState.PLAYER2:
                    row_str += " O "
                elif cell == CellState.BLOCKED:
                    row_str += " # "
            print(row_str)
    
    def _is_valid_position(self, row: int, col: int) -> bool:
        """위치가 유효한지 확인"""
        return 0 <= row < self.rows and 0 <= col < self.cols

class TicTacToe:
    """틱택토 게임 클래스"""
    
    def __init__(self, size: int = 3):
        self.board = GameBoard(size, size)
        self.current_player = CellState.PLAYER1
        self.game_over = False
        self.winner = None
    
    def make_move(self, row: int, col: int) -> Tuple[bool, str]:
        """게임 진행"""
        if self.game_over:
            return False, "게임이 이미 종료되었습니다"
        
        if not self.board.set_cell(row, col, self.current_player):
            return False, "잘못된 위치입니다"
        
        # 승리 조건 확인
        if self.board.check_winner(self.current_player, 3):
            self.game_over = True
            self.winner = self.current_player
            return True, f"플레이어 {self.current_player.value} 승리!"
        
        # 무승부 확인
        if not self.board.get_empty_cells():
            self.game_over = True
            return True, "무승부!"
        
        # 다음 플레이어로 변경
        self.current_player = CellState.PLAYER2 if self.current_player == CellState.PLAYER1 else CellState.PLAYER1
        return True, "계속 진행"
    
    def get_available_moves(self) -> List[Tuple[int, int]]:
        """가능한 수 목록 반환"""
        return self.board.get_empty_cells()
    
    def get_game_state(self) -> dict:
        """게임 상태 반환"""
        return {
            'board': self.board.get_board_state(),
            'current_player': self.current_player.value,
            'game_over': self.game_over,
            'winner': self.winner.value if self.winner else None,
            'available_moves': len(self.board.get_empty_cells())
        }

# 사용 예시
if __name__ == "__main__":
    game = TicTacToe(3)
    
    print("틱택토 게임을 시작합니다!")
    print("플레이어 1: X, 플레이어 2: O")
    
    while not game.game_over:
        game.board.display()
        print(f"플레이어 {game.current_player.value}의 차례입니다")
        
        available_moves = game.get_available_moves()
        print(f"가능한 수: {available_moves}")
        
        # 간단한 AI 또는 사용자 입력
        if available_moves:
            move = random.choice(available_moves)
            success, message = game.make_move(move[0], move[1])
            print(f"수: {move}, 결과: {message}")
    
    game.board.display()
    print(f"게임 종료! 결과: {message}")
```

### 4. 시스템 설계에서의 고려사항

#### 4-1 메모리 효율성과 성능 최적화

```python
import sys
from typing import Any, Optional

class OptimizedArray:
    """메모리 효율성을 고려한 배열 클래스"""
    
    def __init__(self, initial_capacity: int = 10, growth_factor: float = 1.5):
        self._capacity = initial_capacity
        self._size = 0
        self._data = [None] * self._capacity
        self._growth_factor = growth_factor
        self._shrink_threshold = 0.25  # 25% 미만이면 축소
    
    def append(self, item: Any) -> None:
        """아이템 추가"""
        if self._size >= self._capacity:
            self._resize()
        
        self._data[self._size] = item
        self._size += 1
    
    def pop(self) -> Optional[Any]:
        """마지막 아이템 제거"""
        if self._size == 0:
            return None
        
        self._size -= 1
        item = self._data[self._size]
        self._data[self._size] = None  # 메모리 해제
        
        # 축소 조건 확인
        if (self._size > 0 and 
            self._size < self._capacity * self._shrink_threshold and
            self._capacity > 10):  # 최소 크기 유지
            self._resize(shrink=True)
        
        return item
    
    def _resize(self, shrink: bool = False) -> None:
        """배열 크기 조정"""
        if shrink:
            new_capacity = max(10, int(self._capacity / self._growth_factor))
        else:
            new_capacity = int(self._capacity * self._growth_factor)
        
        new_data = [None] * new_capacity
        
        # 기존 데이터 복사
        for i in range(self._size):
            new_data[i] = self._data[i]
        
        self._capacity = new_capacity
        self._data = new_data
    
    def get_memory_info(self) -> dict:
        """메모리 사용 정보"""
        data_size = sys.getsizeof(self._data)
        total_size = sys.getsizeof(self)
        
        return {
            'capacity': self._capacity,
            'size': self._size,
            'utilization': self._size / self._capacity if self._capacity > 0 else 0,
            'data_memory': data_size,
            'total_memory': total_size,
            'waste_ratio': (self._capacity - self._size) / self._capacity if self._capacity > 0 else 0
        }
    
    def compact(self) -> None:
        """메모리 압축 (None 값 제거)"""
        compacted_data = []
        for i in range(self._size):
            if self._data[i] is not None:
                compacted_data.append(self._data[i])
        
        self._size = len(compacted_data)
        self._data = compacted_data + [None] * (self._capacity - self._size)
    
    def __len__(self) -> int:
        return self._size
    
    def __getitem__(self, index: int) -> Any:
        if 0 <= index < self._size:
            return self._data[index]
        raise IndexError("인덱스가 범위를 벗어났습니다")
    
    def __str__(self) -> str:
        return f"OptimizedArray({[self._data[i] for i in range(self._size)]})"

# 성능 테스트
def performance_test():
    """성능 테스트"""
    import time
    
    # 일반 리스트와 비교
    sizes = [1000, 10000, 100000]
    
    for size in sizes:
        print(f"\n배열 크기: {size}")
        
        # 일반 리스트
        start = time.time()
        normal_list = []
        for i in range(size):
            normal_list.append(i)
        normal_time = time.time() - start
        
        # 최적화된 배열
        start = time.time()
        opt_array = OptimizedArray()
        for i in range(size):
            opt_array.append(i)
        opt_time = time.time() - start
        
        print(f"일반 리스트: {normal_time:.6f}초")
        print(f"최적화된 배열: {opt_time:.6f}초")
        
        # 메모리 정보
        mem_info = opt_array.get_memory_info()
        print(f"메모리 사용률: {mem_info['utilization']:.2%}")
        print(f"메모리 낭비율: {mem_info['waste_ratio']:.2%}")

if __name__ == "__main__":
    # 기본 테스트
    arr = OptimizedArray(5)
    
    for i in range(10):
        arr.append(i)
        print(f"추가 후: {arr}, 메모리: {arr.get_memory_info()}")
    
    # 성능 테스트
    performance_test()
```

## 정리

이번 포스트에서는 배열을 실제 프로젝트와 실무 상황에 적용하는 방법을 다뤘습니다:

**실무 적용 분야**
1. **웹 개발**: 세션 관리, 캐시 시스템으로 확장성과 성능 고려
2. **데이터 분석**: 고급 통계 분석, 이상치 탐지, 시계열 분석
3. **게임 개발**: 게임 보드 시스템, 상태 관리, 승리 조건 검사
4. **시스템 설계**: 메모리 효율성, 성능 최적화, 확장성 고려

**실무 설계 원칙**
- 🏗️ **모듈화**: 기능별로 분리된 클래스와 메서드 설계
- ⚡ **성능 최적화**: 메모리 사용량과 실행 시간의 균형
- 🔒 **데이터 무결성**: 유효성 검사와 오류 처리
- 📊 **모니터링**: 통계 정보와 성능 메트릭 수집

**확장성 고려사항**
- **메모리 관리**: 동적 크기 조정과 메모리 낭비 최소화
- **성능 모니터링**: 실시간 통계와 성능 지표 추적
- **오류 처리**: 예외 상황에 대한 적절한 처리
- **API 설계**: 사용하기 쉬운 인터페이스 제공

**배열 학습 완성**
이제 배열에 대한 완전한 학습 경로를 완성했습니다:
1. **기본 개념**: 배열의 정의와 특징
2. **예제 문제**: 실전 문제 해결 방법
3. **알고리즘 기법**: 고급 최적화 기법
4. **실무 활용**: 실제 프로젝트 적용 방법

# 📚 레퍼런스
- [System Design Interview - High Scalability](https://highscalability.com/)
- [Python Performance Tips - Python.org](https://wiki.python.org/moin/PythonSpeed/PerformanceTips)
- [Data Structures and Algorithms in Python - Goodrich](https://www.amazon.com/Data-Structures-Algorithms-Python-Goodrich/dp/1118290275)

---
*이 포스트는 자료구조 학습 과정을 정리한 내용입니다.*
