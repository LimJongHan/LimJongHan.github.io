---
layout: post
title: "[í•™ìŠµ] [ìë£Œêµ¬ì¡°] ë°°ì—´(Array) í™œìš© - 3. ì‹¤ë¬´ í™œìš©"
date: 2025-10-03 01:55:00 +0900
categories: [í•™ìŠµ, ìë£Œêµ¬ì¡°]
tags: [ë°°ì—´, Array, ì‹¤ë¬´í™œìš©, ì›¹ê°œë°œ, ë°ì´í„°ë¶„ì„, ê²Œì„ê°œë°œ, ì‹œìŠ¤í…œì„¤ê³„]
author: LimJongHan
toc: true
---

# ğŸ“– ê´€ë ¨ëœ ë‚´ í¬ìŠ¤íŒ…
- [[í•™ìŠµ] [ìë£Œêµ¬ì¡°] ë°°ì—´(Array)]({% post_url 2025-10-03-[í•™ìŠµ][ìë£Œêµ¬ì¡°] ë°°ì—´(Array) %})
- [[í•™ìŠµ] [ìë£Œêµ¬ì¡°] ë°°ì—´(Array) í™œìš© - 1. ì˜ˆì œ]({% post_url 2025-10-03-[í•™ìŠµ][ìë£Œêµ¬ì¡°] ë°°ì—´(Array) í™œìš© - 1. ì˜ˆì œ %})
- [[í•™ìŠµ] [ìë£Œêµ¬ì¡°] ë°°ì—´(Array) í™œìš© - 2. ì•Œê³ ë¦¬ì¦˜ í™œìš©]({% post_url 2025-10-03-[í•™ìŠµ][ìë£Œêµ¬ì¡°] ë°°ì—´(Array) í™œìš© - 2. ì•Œê³ ë¦¬ì¦˜ í™œìš© %})

# ğŸ“ ë‚´ìš©

## ê°œìš”

ì´ì „ í¬ìŠ¤íŠ¸ë“¤ì—ì„œ ë°°ì—´ì˜ ê¸°ë³¸ ê°œë…, ë¬¸ì œ í•´ê²° ì˜ˆì œ, ê·¸ë¦¬ê³  ê³ ê¸‰ ì•Œê³ ë¦¬ì¦˜ ê¸°ë²•ë“¤ì„ ë‹¤ë¤˜ìŠµë‹ˆë‹¤. ì´ë²ˆ í¬ìŠ¤íŠ¸ì—ì„œëŠ” ì´ëŸ¬í•œ ì§€ì‹ë“¤ì„ ì‹¤ì œ í”„ë¡œì íŠ¸ì™€ ì‹¤ë¬´ ìƒí™©ì— ì ìš©í•˜ëŠ” ë°©ë²•ì„ ì•Œì•„ë³´ê² ìŠµë‹ˆë‹¤.

**ì´ë²ˆ í¬ìŠ¤íŠ¸ì—ì„œ ë‹¤ë£° ì‹¤ë¬´ í™œìš© ë¶„ì•¼:**
- ğŸŒ **ì›¹ ê°œë°œ**: ì‚¬ìš©ì ì„¸ì…˜ ê´€ë¦¬, ìºì‹œ ì‹œìŠ¤í…œ, ë°ì´í„° ì²˜ë¦¬
- ğŸ“Š **ë°ì´í„° ë¶„ì„**: í†µê³„ ê³„ì‚°, ì´ìƒì¹˜ íƒì§€, ì‹œê³„ì—´ ë¶„ì„
- ğŸ® **ê²Œì„ ê°œë°œ**: ê²Œì„ ë³´ë“œ, ì¸ë²¤í† ë¦¬ ì‹œìŠ¤í…œ, ì ìˆ˜ ê´€ë¦¬
- ğŸ—ï¸ **ì‹œìŠ¤í…œ ì„¤ê³„**: ë©”ëª¨ë¦¬ ê´€ë¦¬, ì„±ëŠ¥ ìµœì í™”, í™•ì¥ì„± ê³ ë ¤

ì‹¤ë¬´ì—ì„œëŠ” ë‹¨ìˆœí•œ ì•Œê³ ë¦¬ì¦˜ êµ¬í˜„ì„ ë„˜ì–´ì„œ ë¹„ì¦ˆë‹ˆìŠ¤ ìš”êµ¬ì‚¬í•­ê³¼ ì„±ëŠ¥ì„ ëª¨ë‘ ê³ ë ¤í•œ ì„¤ê³„ê°€ í•„ìš”í•©ë‹ˆë‹¤.

## í•µì‹¬ ë‚´ìš©

### 1. ì›¹ ê°œë°œì—ì„œì˜ ë°°ì—´ í™œìš©

#### 1-1 ì‚¬ìš©ì ì„¸ì…˜ ê´€ë¦¬ ì‹œìŠ¤í…œ

```python
import time
from typing import Dict, List, Optional
from dataclasses import dataclass

@dataclass
class UserSession:
    """ì‚¬ìš©ì ì„¸ì…˜ ë°ì´í„° í´ë˜ìŠ¤"""
    user_id: str
    session_id: str
    created_at: float
    last_activity: float
    ip_address: str
    user_agent: str
    data: Dict

class SessionManager:
    """ì‚¬ìš©ì ì„¸ì…˜ì„ ë°°ì—´ë¡œ ê´€ë¦¬í•˜ëŠ” í´ë˜ìŠ¤"""
    
    def __init__(self, max_sessions: int = 10000):
        self.sessions: List[Optional[UserSession]] = []
        self.session_map: Dict[str, int] = {}  # session_id -> index
        self.user_map: Dict[str, List[int]] = {}  # user_id -> session_indices
        self.max_sessions = max_sessions
        self.next_index = 0
    
    def create_session(self, user_id: str, ip_address: str, user_agent: str, data: Dict = None) -> str:
        """ìƒˆ ì„¸ì…˜ ìƒì„±"""
        if data is None:
            data = {}
        
        session_id = f"session_{int(time.time())}_{user_id}"
        current_time = time.time()
        
        session = UserSession(
            user_id=user_id,
            session_id=session_id,
            created_at=current_time,
            last_activity=current_time,
            ip_address=ip_address,
            user_agent=user_agent,
            data=data
        )
        
        # ë°°ì—´ì— ì„¸ì…˜ ì €ì¥
        if self.next_index < len(self.sessions):
            # ê¸°ì¡´ ìŠ¬ë¡¯ ì¬ì‚¬ìš©
            self.sessions[self.next_index] = session
        else:
            # ìƒˆ ìŠ¬ë¡¯ ì¶”ê°€
            self.sessions.append(session)
        
        # ì¸ë±ìŠ¤ ë§¤í•‘ ì—…ë°ì´íŠ¸
        self.session_map[session_id] = self.next_index
        
        if user_id not in self.user_map:
            self.user_map[user_id] = []
        self.user_map[user_id].append(self.next_index)
        
        # ë‹¤ìŒ ì¸ë±ìŠ¤ ì°¾ê¸°
        self._find_next_available_index()
        
        return session_id
    
    def get_session(self, session_id: str) -> Optional[UserSession]:
        """ì„¸ì…˜ ì •ë³´ ì¡°íšŒ ë° í™œë™ ì‹œê°„ ì—…ë°ì´íŠ¸"""
        if session_id not in self.session_map:
            return None
        
        index = self.session_map[session_id]
        session = self.sessions[index]
        
        if session is None:
            # ì„¸ì…˜ì´ ì´ë¯¸ ì‚­ì œë¨
            del self.session_map[session_id]
            return None
        
        # í™œë™ ì‹œê°„ ì—…ë°ì´íŠ¸
        session.last_activity = time.time()
        return session
    
    def invalidate_session(self, session_id: str) -> bool:
        """ì„¸ì…˜ ë¬´íš¨í™”"""
        if session_id not in self.session_map:
            return False
        
        index = self.session_map[session_id]
        session = self.sessions[index]
        
        if session is None:
            return False
        
        # ì‚¬ìš©ì ë§¤í•‘ì—ì„œ ì œê±°
        user_id = session.user_id
        if user_id in self.user_map:
            self.user_map[user_id].remove(index)
            if not self.user_map[user_id]:
                del self.user_map[user_id]
        
        # ì„¸ì…˜ ì‚­ì œ
        self.sessions[index] = None
        del self.session_map[session_id]
        
        return True
    
    def get_user_sessions(self, user_id: str) -> List[UserSession]:
        """íŠ¹ì • ì‚¬ìš©ìì˜ ëª¨ë“  ì„¸ì…˜ ì¡°íšŒ"""
        if user_id not in self.user_map:
            return []
        
        sessions = []
        for index in self.user_map[user_id]:
            session = self.sessions[index]
            if session is not None:
                sessions.append(session)
        
        return sessions
    
    def cleanup_expired_sessions(self, timeout: int = 3600) -> int:
        """ë§Œë£Œëœ ì„¸ì…˜ ì •ë¦¬"""
        current_time = time.time()
        cleaned_count = 0
        
        for i, session in enumerate(self.sessions):
            if session is None:
                continue
            
            if current_time - session.last_activity > timeout:
                self.invalidate_session(session.session_id)
                cleaned_count += 1
        
        return cleaned_count
    
    def get_active_users(self) -> List[str]:
        """í™œì„± ì‚¬ìš©ì ëª©ë¡ ë°˜í™˜"""
        return list(self.user_map.keys())
    
    def get_session_statistics(self) -> Dict:
        """ì„¸ì…˜ í†µê³„ ì •ë³´"""
        total_sessions = len(self.session_map)
        total_users = len(self.user_map)
        active_sessions = sum(1 for s in self.sessions if s is not None)
        
        return {
            'total_sessions': total_sessions,
            'total_users': total_users,
            'active_sessions': active_sessions,
            'session_utilization': active_sessions / len(self.sessions) if self.sessions else 0
        }
    
    def _find_next_available_index(self):
        """ë‹¤ìŒ ì‚¬ìš© ê°€ëŠ¥í•œ ì¸ë±ìŠ¤ ì°¾ê¸°"""
        for i in range(len(self.sessions)):
            if self.sessions[i] is None:
                self.next_index = i
                return
        
        self.next_index = len(self.sessions)

# ì‚¬ìš© ì˜ˆì‹œ
if __name__ == "__main__":
    session_mgr = SessionManager()
    
    # ì„¸ì…˜ ìƒì„±
    session1 = session_mgr.create_session("user1", "192.168.1.1", "Chrome", {"role": "admin"})
    session2 = session_mgr.create_session("user2", "192.168.1.2", "Firefox", {"role": "user"})
    session3 = session_mgr.create_session("user1", "192.168.1.3", "Safari", {"role": "admin"})
    
    print(f"ìƒì„±ëœ ì„¸ì…˜: {session1}, {session2}, {session3}")
    
    # ì„¸ì…˜ ì¡°íšŒ
    session_info = session_mgr.get_session(session1)
    print(f"ì„¸ì…˜ ì •ë³´: {session_info}")
    
    # ì‚¬ìš©ì ì„¸ì…˜ ëª©ë¡
    user_sessions = session_mgr.get_user_sessions("user1")
    print(f"user1ì˜ ì„¸ì…˜ ìˆ˜: {len(user_sessions)}")
    
    # í†µê³„ ì •ë³´
    stats = session_mgr.get_session_statistics()
    print(f"ì„¸ì…˜ í†µê³„: {stats}")
```

#### 1-2 ìºì‹œ ì‹œìŠ¤í…œ êµ¬í˜„

```python
from collections import OrderedDict
import time
from typing import Any, Optional

class LRUCache:
    """Least Recently Used ìºì‹œ êµ¬í˜„"""
    
    def __init__(self, capacity: int):
        self.capacity = capacity
        self.cache = OrderedDict()
        self.access_times = {}
    
    def get(self, key: str) -> Optional[Any]:
        """ìºì‹œì—ì„œ ê°’ ì¡°íšŒ"""
        if key in self.cache:
            # ì ‘ê·¼ ì‹œê°„ ì—…ë°ì´íŠ¸ ë° ìˆœì„œ ë³€ê²½
            self.access_times[key] = time.time()
            self.cache.move_to_end(key)
            return self.cache[key]
        return None
    
    def put(self, key: str, value: Any) -> None:
        """ìºì‹œì— ê°’ ì €ì¥"""
        if key in self.cache:
            # ê¸°ì¡´ í‚¤ ì—…ë°ì´íŠ¸
            self.cache[key] = value
            self.access_times[key] = time.time()
            self.cache.move_to_end(key)
        else:
            # ìƒˆ í‚¤ ì¶”ê°€
            if len(self.cache) >= self.capacity:
                # ê°€ì¥ ì˜¤ë˜ëœ í•­ëª© ì œê±°
                oldest_key = next(iter(self.cache))
                del self.cache[oldest_key]
                del self.access_times[oldest_key]
            
            self.cache[key] = value
            self.access_times[key] = time.time()
    
    def invalidate(self, key: str) -> bool:
        """ìºì‹œì—ì„œ íŠ¹ì • í‚¤ ì œê±°"""
        if key in self.cache:
            del self.cache[key]
            del self.access_times[key]
            return True
        return False
    
    def clear(self) -> None:
        """ìºì‹œ ì „ì²´ ì´ˆê¸°í™”"""
        self.cache.clear()
        self.access_times.clear()
    
    def get_statistics(self) -> Dict:
        """ìºì‹œ í†µê³„ ì •ë³´"""
        current_time = time.time()
        recent_accesses = sum(1 for access_time in self.access_times.values() 
                            if current_time - access_time < 300)  # 5ë¶„ ì´ë‚´
        
        return {
            'size': len(self.cache),
            'capacity': self.capacity,
            'utilization': len(self.cache) / self.capacity,
            'recent_accesses': recent_accesses
        }

class CacheManager:
    """ì—¬ëŸ¬ ìºì‹œë¥¼ ê´€ë¦¬í•˜ëŠ” í´ë˜ìŠ¤"""
    
    def __init__(self):
        self.caches = {}
    
    def create_cache(self, name: str, capacity: int) -> LRUCache:
        """ìƒˆ ìºì‹œ ìƒì„±"""
        cache = LRUCache(capacity)
        self.caches[name] = cache
        return cache
    
    def get_cache(self, name: str) -> Optional[LRUCache]:
        """ìºì‹œ ì¡°íšŒ"""
        return self.caches.get(name)
    
    def get_all_statistics(self) -> Dict:
        """ëª¨ë“  ìºì‹œì˜ í†µê³„ ì •ë³´"""
        stats = {}
        for name, cache in self.caches.items():
            stats[name] = cache.get_statistics()
        return stats

# ì‚¬ìš© ì˜ˆì‹œ
if __name__ == "__main__":
    # ìºì‹œ ìƒì„±
    cache = LRUCache(3)
    
    # ë°ì´í„° ì €ì¥
    cache.put("user:1", {"name": "Alice", "email": "alice@example.com"})
    cache.put("user:2", {"name": "Bob", "email": "bob@example.com"})
    cache.put("user:3", {"name": "Charlie", "email": "charlie@example.com"})
    
    # ìºì‹œ ì¡°íšŒ
    user_data = cache.get("user:1")
    print(f"ì‚¬ìš©ì ë°ì´í„°: {user_data}")
    
    # ìºì‹œ í†µê³„
    stats = cache.get_statistics()
    print(f"ìºì‹œ í†µê³„: {stats}")
```

### 2. ë°ì´í„° ë¶„ì„ì—ì„œì˜ ë°°ì—´ í™œìš©

#### 2-1 ê³ ê¸‰ ë°ì´í„° ë¶„ì„ í´ë˜ìŠ¤

```python
import statistics
import math
from typing import List, Tuple, Optional
from dataclasses import dataclass

@dataclass
class DataPoint:
    """ë°ì´í„° í¬ì¸íŠ¸ í´ë˜ìŠ¤"""
    value: float
    timestamp: float
    metadata: dict = None

class AdvancedDataAnalyzer:
    """ê³ ê¸‰ ë°ì´í„° ë¶„ì„ì„ ìœ„í•œ í´ë˜ìŠ¤"""
    
    def __init__(self):
        self.data: List[DataPoint] = []
        self.statistics_cache = None
    
    def add_data_point(self, value: float, timestamp: float = None, metadata: dict = None):
        """ë°ì´í„° í¬ì¸íŠ¸ ì¶”ê°€"""
        if timestamp is None:
            timestamp = time.time()
        
        data_point = DataPoint(value, timestamp, metadata or {})
        self.data.append(data_point)
        
        # í†µê³„ ìºì‹œ ë¬´íš¨í™”
        self.statistics_cache = None
    
    def get_basic_statistics(self) -> dict:
        """ê¸°ë³¸ í†µê³„ ì •ë³´ ê³„ì‚°"""
        if not self.data:
            return None
        
        values = [dp.value for dp in self.data]
        
        return {
            'count': len(values),
            'mean': statistics.mean(values),
            'median': statistics.median(values),
            'mode': statistics.mode(values) if len(set(values)) < len(values) else None,
            'min': min(values),
            'max': max(values),
            'range': max(values) - min(values),
            'std_dev': statistics.stdev(values) if len(values) > 1 else 0,
            'variance': statistics.variance(values) if len(values) > 1 else 0
        }
    
    def detect_outliers(self, method: str = 'iqr', threshold: float = 1.5) -> List[Tuple[int, DataPoint, float]]:
        """
        ì´ìƒì¹˜ íƒì§€
        
        Args:
            method: 'iqr', 'zscore', 'modified_zscore'
            threshold: ì„ê³„ê°’
        """
        if len(self.data) < 3:
            return []
        
        values = [dp.value for dp in self.data]
        outliers = []
        
        if method == 'iqr':
            # IQR ë°©ë²•
            q1 = statistics.quantiles(values, n=4)[0]
            q3 = statistics.quantiles(values, n=4)[2]
            iqr = q3 - q1
            lower_bound = q1 - threshold * iqr
            upper_bound = q3 + threshold * iqr
            
            for i, dp in enumerate(self.data):
                if dp.value < lower_bound or dp.value > upper_bound:
                    outliers.append((i, dp, dp.value))
        
        elif method == 'zscore':
            # Z-score ë°©ë²•
            mean = statistics.mean(values)
            std_dev = statistics.stdev(values)
            
            for i, dp in enumerate(self.data):
                z_score = abs((dp.value - mean) / std_dev)
                if z_score > threshold:
                    outliers.append((i, dp, z_score))
        
        elif method == 'modified_zscore':
            # Modified Z-score ë°©ë²•
            median = statistics.median(values)
            mad = statistics.median([abs(x - median) for x in values])
            
            for i, dp in enumerate(self.data):
                modified_z_score = 0.6745 * (dp.value - median) / mad
                if abs(modified_z_score) > threshold:
                    outliers.append((i, dp, modified_z_score))
        
        return outliers
    
    def moving_average(self, window_size: int, method: str = 'simple') -> List[float]:
        """
        ì´ë™í‰ê·  ê³„ì‚°
        
        Args:
            window_size: ìœˆë„ìš° í¬ê¸°
            method: 'simple', 'exponential', 'weighted'
        """
        if len(self.data) < window_size:
            return []
        
        values = [dp.value for dp in self.data]
        moving_averages = []
        
        if method == 'simple':
            # ë‹¨ìˆœ ì´ë™í‰ê· 
            for i in range(window_size - 1, len(values)):
                window_sum = sum(values[i - window_size + 1:i + 1])
                moving_averages.append(window_sum / window_size)
        
        elif method == 'weighted':
            # ê°€ì¤‘ ì´ë™í‰ê·  (ìµœê·¼ ë°ì´í„°ì— ë” ë†’ì€ ê°€ì¤‘ì¹˜)
            weights = list(range(1, window_size + 1))
            weight_sum = sum(weights)
            
            for i in range(window_size - 1, len(values)):
                window_values = values[i - window_size + 1:i + 1]
                weighted_sum = sum(val * weight for val, weight in zip(window_values, weights))
                moving_averages.append(weighted_sum / weight_sum)
        
        elif method == 'exponential':
            # ì§€ìˆ˜ ì´ë™í‰ê· 
            alpha = 2 / (window_size + 1)
            ema = values[0]
            moving_averages.append(ema)
            
            for i in range(1, len(values)):
                ema = alpha * values[i] + (1 - alpha) * ema
                moving_averages.append(ema)
        
        return moving_averages
    
    def find_trends(self, window_size: int = 10) -> List[str]:
        """íŠ¸ë Œë“œ ë¶„ì„"""
        if len(self.data) < window_size * 2:
            return []
        
        moving_avg = self.moving_average(window_size)
        trends = []
        
        for i in range(1, len(moving_avg)):
            if moving_avg[i] > moving_avg[i-1] * 1.02:  # 2% ì´ìƒ ì¦ê°€
                trends.append('increasing')
            elif moving_avg[i] < moving_avg[i-1] * 0.98:  # 2% ì´ìƒ ê°ì†Œ
                trends.append('decreasing')
            else:
                trends.append('stable')
        
        return trends
    
    def get_time_series_data(self, start_time: float = None, end_time: float = None) -> List[DataPoint]:
        """ì‹œê°„ ë²”ìœ„ì— ë”°ë¥¸ ë°ì´í„° ì¡°íšŒ"""
        filtered_data = []
        
        for dp in self.data:
            if start_time and dp.timestamp < start_time:
                continue
            if end_time and dp.timestamp > end_time:
                continue
            filtered_data.append(dp)
        
        return filtered_data
    
    def export_to_csv(self, filename: str) -> None:
        """CSV íŒŒì¼ë¡œ ë°ì´í„° ë‚´ë³´ë‚´ê¸°"""
        import csv
        
        with open(filename, 'w', newline='') as csvfile:
            fieldnames = ['timestamp', 'value', 'metadata']
            writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
            
            writer.writeheader()
            for dp in self.data:
                writer.writerow({
                    'timestamp': dp.timestamp,
                    'value': dp.value,
                    'metadata': str(dp.metadata) if dp.metadata else ''
                })

# ì‚¬ìš© ì˜ˆì‹œ
if __name__ == "__main__":
    analyzer = AdvancedDataAnalyzer()
    
    # ìƒ˜í”Œ ë°ì´í„° ì¶”ê°€
    import random
    base_value = 100
    for i in range(100):
        # ì •ìƒ ë°ì´í„° + ë…¸ì´ì¦ˆ + ì´ìƒì¹˜
        if i == 50:  # ì´ìƒì¹˜
            value = base_value + 50
        else:
            value = base_value + random.gauss(0, 5)
        
        analyzer.add_data_point(value, time.time() + i, {"source": "sensor1"})
    
    # í†µê³„ ì •ë³´
    stats = analyzer.get_basic_statistics()
    print("ê¸°ë³¸ í†µê³„:")
    for key, value in stats.items():
        print(f"  {key}: {value:.2f}")
    
    # ì´ìƒì¹˜ íƒì§€
    outliers = analyzer.detect_outliers(method='iqr')
    print(f"\nì´ìƒì¹˜ ê°œìˆ˜: {len(outliers)}")
    for i, dp, score in outliers:
        print(f"  ì¸ë±ìŠ¤ {i}: ê°’ {dp.value:.2f}, ì ìˆ˜ {score:.2f}")
    
    # ì´ë™í‰ê· 
    ma = analyzer.moving_average(10, method='weighted')
    print(f"\nê°€ì¤‘ ì´ë™í‰ê·  (ì²˜ìŒ 5ê°œ): {ma[:5]}")
    
    # íŠ¸ë Œë“œ ë¶„ì„
    trends = analyzer.find_trends()
    print(f"\níŠ¸ë Œë“œ ë¶„ì„ (ì²˜ìŒ 10ê°œ): {trends[:10]}")
```

### 3. ê²Œì„ ê°œë°œì—ì„œì˜ ë°°ì—´ í™œìš©

#### 3-1 ê²Œì„ ë³´ë“œ ì‹œìŠ¤í…œ

```python
from enum import Enum
from typing import List, Tuple, Optional
import random

class CellState(Enum):
    """ì…€ ìƒíƒœ ì—´ê±°í˜•"""
    EMPTY = 0
    PLAYER1 = 1
    PLAYER2 = 2
    BLOCKED = -1

class GameBoard:
    """ê²Œì„ ë³´ë“œë¥¼ ë°°ì—´ë¡œ êµ¬í˜„"""
    
    def __init__(self, rows: int, cols: int):
        self.rows = rows
        self.cols = cols
        self.board = [[CellState.EMPTY for _ in range(cols)] for _ in range(rows)]
        self.move_history = []
    
    def get_cell(self, row: int, col: int) -> CellState:
        """ì…€ ìƒíƒœ ì¡°íšŒ"""
        if not self._is_valid_position(row, col):
            raise IndexError("ì˜ëª»ëœ ë³´ë“œ ìœ„ì¹˜ì…ë‹ˆë‹¤")
        return self.board[row][col]
    
    def set_cell(self, row: int, col: int, state: CellState) -> bool:
        """ì…€ ìƒíƒœ ì„¤ì •"""
        if not self._is_valid_position(row, col):
            return False
        
        if self.board[row][col] != CellState.EMPTY:
            return False
        
        self.board[row][col] = state
        self.move_history.append((row, col, state))
        return True
    
    def clear_cell(self, row: int, col: int) -> bool:
        """ì…€ ì´ˆê¸°í™”"""
        if not self._is_valid_position(row, col):
            return False
        
        self.board[row][col] = CellState.EMPTY
        return True
    
    def get_empty_cells(self) -> List[Tuple[int, int]]:
        """ë¹ˆ ì…€ë“¤ì˜ ìœ„ì¹˜ ë°˜í™˜"""
        empty_cells = []
        for row in range(self.rows):
            for col in range(self.cols):
                if self.board[row][col] == CellState.EMPTY:
                    empty_cells.append((row, col))
        return empty_cells
    
    def check_line(self, start_row: int, start_col: int, direction: str, length: int, player: CellState) -> bool:
        """
        ì—°ì†ëœ ê°™ì€ ìƒíƒœê°€ ìˆëŠ”ì§€ í™•ì¸
        
        Args:
            start_row: ì‹œì‘ í–‰
            start_col: ì‹œì‘ ì—´
            direction: ë°©í–¥ ('horizontal', 'vertical', 'diagonal_down', 'diagonal_up')
            length: ì—°ì† ê¸¸ì´
            player: í™•ì¸í•  í”Œë ˆì´ì–´ ìƒíƒœ
        """
        row, col = start_row, start_col
        
        for _ in range(length):
            if (not self._is_valid_position(row, col) or 
                self.board[row][col] != player):
                return False
            
            # ë°©í–¥ì— ë”°ë¼ ë‹¤ìŒ ìœ„ì¹˜ ê³„ì‚°
            if direction == 'horizontal':
                col += 1
            elif direction == 'vertical':
                row += 1
            elif direction == 'diagonal_down':
                row += 1
                col += 1
            elif direction == 'diagonal_up':
                row -= 1
                col += 1
        
        return True
    
    def check_winner(self, player: CellState, win_length: int = 3) -> bool:
        """ìŠ¹ë¦¬ ì¡°ê±´ í™•ì¸"""
        directions = ['horizontal', 'vertical', 'diagonal_down', 'diagonal_up']
        
        for row in range(self.rows):
            for col in range(self.cols):
                for direction in directions:
                    if self.check_line(row, col, direction, win_length, player):
                        return True
        
        return False
    
    def get_board_state(self) -> List[List[int]]:
        """ë³´ë“œ ìƒíƒœë¥¼ ì •ìˆ˜ ë°°ì—´ë¡œ ë°˜í™˜"""
        return [[cell.value for cell in row] for row in self.board]
    
    def display(self):
        """ë³´ë“œ ì¶œë ¥"""
        print("  " + " ".join(str(i) for i in range(self.cols)))
        for i, row in enumerate(self.board):
            row_str = str(i) + " "
            for cell in row:
                if cell == CellState.EMPTY:
                    row_str += " . "
                elif cell == CellState.PLAYER1:
                    row_str += " X "
                elif cell == CellState.PLAYER2:
                    row_str += " O "
                elif cell == CellState.BLOCKED:
                    row_str += " # "
            print(row_str)
    
    def _is_valid_position(self, row: int, col: int) -> bool:
        """ìœ„ì¹˜ê°€ ìœ íš¨í•œì§€ í™•ì¸"""
        return 0 <= row < self.rows and 0 <= col < self.cols

class TicTacToe:
    """í‹±íƒí†  ê²Œì„ í´ë˜ìŠ¤"""
    
    def __init__(self, size: int = 3):
        self.board = GameBoard(size, size)
        self.current_player = CellState.PLAYER1
        self.game_over = False
        self.winner = None
    
    def make_move(self, row: int, col: int) -> Tuple[bool, str]:
        """ê²Œì„ ì§„í–‰"""
        if self.game_over:
            return False, "ê²Œì„ì´ ì´ë¯¸ ì¢…ë£Œë˜ì—ˆìŠµë‹ˆë‹¤"
        
        if not self.board.set_cell(row, col, self.current_player):
            return False, "ì˜ëª»ëœ ìœ„ì¹˜ì…ë‹ˆë‹¤"
        
        # ìŠ¹ë¦¬ ì¡°ê±´ í™•ì¸
        if self.board.check_winner(self.current_player, 3):
            self.game_over = True
            self.winner = self.current_player
            return True, f"í”Œë ˆì´ì–´ {self.current_player.value} ìŠ¹ë¦¬!"
        
        # ë¬´ìŠ¹ë¶€ í™•ì¸
        if not self.board.get_empty_cells():
            self.game_over = True
            return True, "ë¬´ìŠ¹ë¶€!"
        
        # ë‹¤ìŒ í”Œë ˆì´ì–´ë¡œ ë³€ê²½
        self.current_player = CellState.PLAYER2 if self.current_player == CellState.PLAYER1 else CellState.PLAYER1
        return True, "ê³„ì† ì§„í–‰"
    
    def get_available_moves(self) -> List[Tuple[int, int]]:
        """ê°€ëŠ¥í•œ ìˆ˜ ëª©ë¡ ë°˜í™˜"""
        return self.board.get_empty_cells()
    
    def get_game_state(self) -> dict:
        """ê²Œì„ ìƒíƒœ ë°˜í™˜"""
        return {
            'board': self.board.get_board_state(),
            'current_player': self.current_player.value,
            'game_over': self.game_over,
            'winner': self.winner.value if self.winner else None,
            'available_moves': len(self.board.get_empty_cells())
        }

# ì‚¬ìš© ì˜ˆì‹œ
if __name__ == "__main__":
    game = TicTacToe(3)
    
    print("í‹±íƒí†  ê²Œì„ì„ ì‹œì‘í•©ë‹ˆë‹¤!")
    print("í”Œë ˆì´ì–´ 1: X, í”Œë ˆì´ì–´ 2: O")
    
    while not game.game_over:
        game.board.display()
        print(f"í”Œë ˆì´ì–´ {game.current_player.value}ì˜ ì°¨ë¡€ì…ë‹ˆë‹¤")
        
        available_moves = game.get_available_moves()
        print(f"ê°€ëŠ¥í•œ ìˆ˜: {available_moves}")
        
        # ê°„ë‹¨í•œ AI ë˜ëŠ” ì‚¬ìš©ì ì…ë ¥
        if available_moves:
            move = random.choice(available_moves)
            success, message = game.make_move(move[0], move[1])
            print(f"ìˆ˜: {move}, ê²°ê³¼: {message}")
    
    game.board.display()
    print(f"ê²Œì„ ì¢…ë£Œ! ê²°ê³¼: {message}")
```

### 4. ì‹œìŠ¤í…œ ì„¤ê³„ì—ì„œì˜ ê³ ë ¤ì‚¬í•­

#### 4-1 ë©”ëª¨ë¦¬ íš¨ìœ¨ì„±ê³¼ ì„±ëŠ¥ ìµœì í™”

```python
import sys
from typing import Any, Optional

class OptimizedArray:
    """ë©”ëª¨ë¦¬ íš¨ìœ¨ì„±ì„ ê³ ë ¤í•œ ë°°ì—´ í´ë˜ìŠ¤"""
    
    def __init__(self, initial_capacity: int = 10, growth_factor: float = 1.5):
        self._capacity = initial_capacity
        self._size = 0
        self._data = [None] * self._capacity
        self._growth_factor = growth_factor
        self._shrink_threshold = 0.25  # 25% ë¯¸ë§Œì´ë©´ ì¶•ì†Œ
    
    def append(self, item: Any) -> None:
        """ì•„ì´í…œ ì¶”ê°€"""
        if self._size >= self._capacity:
            self._resize()
        
        self._data[self._size] = item
        self._size += 1
    
    def pop(self) -> Optional[Any]:
        """ë§ˆì§€ë§‰ ì•„ì´í…œ ì œê±°"""
        if self._size == 0:
            return None
        
        self._size -= 1
        item = self._data[self._size]
        self._data[self._size] = None  # ë©”ëª¨ë¦¬ í•´ì œ
        
        # ì¶•ì†Œ ì¡°ê±´ í™•ì¸
        if (self._size > 0 and 
            self._size < self._capacity * self._shrink_threshold and
            self._capacity > 10):  # ìµœì†Œ í¬ê¸° ìœ ì§€
            self._resize(shrink=True)
        
        return item
    
    def _resize(self, shrink: bool = False) -> None:
        """ë°°ì—´ í¬ê¸° ì¡°ì •"""
        if shrink:
            new_capacity = max(10, int(self._capacity / self._growth_factor))
        else:
            new_capacity = int(self._capacity * self._growth_factor)
        
        new_data = [None] * new_capacity
        
        # ê¸°ì¡´ ë°ì´í„° ë³µì‚¬
        for i in range(self._size):
            new_data[i] = self._data[i]
        
        self._capacity = new_capacity
        self._data = new_data
    
    def get_memory_info(self) -> dict:
        """ë©”ëª¨ë¦¬ ì‚¬ìš© ì •ë³´"""
        data_size = sys.getsizeof(self._data)
        total_size = sys.getsizeof(self)
        
        return {
            'capacity': self._capacity,
            'size': self._size,
            'utilization': self._size / self._capacity if self._capacity > 0 else 0,
            'data_memory': data_size,
            'total_memory': total_size,
            'waste_ratio': (self._capacity - self._size) / self._capacity if self._capacity > 0 else 0
        }
    
    def compact(self) -> None:
        """ë©”ëª¨ë¦¬ ì••ì¶• (None ê°’ ì œê±°)"""
        compacted_data = []
        for i in range(self._size):
            if self._data[i] is not None:
                compacted_data.append(self._data[i])
        
        self._size = len(compacted_data)
        self._data = compacted_data + [None] * (self._capacity - self._size)
    
    def __len__(self) -> int:
        return self._size
    
    def __getitem__(self, index: int) -> Any:
        if 0 <= index < self._size:
            return self._data[index]
        raise IndexError("ì¸ë±ìŠ¤ê°€ ë²”ìœ„ë¥¼ ë²—ì–´ë‚¬ìŠµë‹ˆë‹¤")
    
    def __str__(self) -> str:
        return f"OptimizedArray({[self._data[i] for i in range(self._size)]})"

# ì„±ëŠ¥ í…ŒìŠ¤íŠ¸
def performance_test():
    """ì„±ëŠ¥ í…ŒìŠ¤íŠ¸"""
    import time
    
    # ì¼ë°˜ ë¦¬ìŠ¤íŠ¸ì™€ ë¹„êµ
    sizes = [1000, 10000, 100000]
    
    for size in sizes:
        print(f"\në°°ì—´ í¬ê¸°: {size}")
        
        # ì¼ë°˜ ë¦¬ìŠ¤íŠ¸
        start = time.time()
        normal_list = []
        for i in range(size):
            normal_list.append(i)
        normal_time = time.time() - start
        
        # ìµœì í™”ëœ ë°°ì—´
        start = time.time()
        opt_array = OptimizedArray()
        for i in range(size):
            opt_array.append(i)
        opt_time = time.time() - start
        
        print(f"ì¼ë°˜ ë¦¬ìŠ¤íŠ¸: {normal_time:.6f}ì´ˆ")
        print(f"ìµœì í™”ëœ ë°°ì—´: {opt_time:.6f}ì´ˆ")
        
        # ë©”ëª¨ë¦¬ ì •ë³´
        mem_info = opt_array.get_memory_info()
        print(f"ë©”ëª¨ë¦¬ ì‚¬ìš©ë¥ : {mem_info['utilization']:.2%}")
        print(f"ë©”ëª¨ë¦¬ ë‚­ë¹„ìœ¨: {mem_info['waste_ratio']:.2%}")

if __name__ == "__main__":
    # ê¸°ë³¸ í…ŒìŠ¤íŠ¸
    arr = OptimizedArray(5)
    
    for i in range(10):
        arr.append(i)
        print(f"ì¶”ê°€ í›„: {arr}, ë©”ëª¨ë¦¬: {arr.get_memory_info()}")
    
    # ì„±ëŠ¥ í…ŒìŠ¤íŠ¸
    performance_test()
```

## ì •ë¦¬

ì´ë²ˆ í¬ìŠ¤íŠ¸ì—ì„œëŠ” ë°°ì—´ì„ ì‹¤ì œ í”„ë¡œì íŠ¸ì™€ ì‹¤ë¬´ ìƒí™©ì— ì ìš©í•˜ëŠ” ë°©ë²•ì„ ë‹¤ë¤˜ìŠµë‹ˆë‹¤:

**ì‹¤ë¬´ ì ìš© ë¶„ì•¼**
1. **ì›¹ ê°œë°œ**: ì„¸ì…˜ ê´€ë¦¬, ìºì‹œ ì‹œìŠ¤í…œìœ¼ë¡œ í™•ì¥ì„±ê³¼ ì„±ëŠ¥ ê³ ë ¤
2. **ë°ì´í„° ë¶„ì„**: ê³ ê¸‰ í†µê³„ ë¶„ì„, ì´ìƒì¹˜ íƒì§€, ì‹œê³„ì—´ ë¶„ì„
3. **ê²Œì„ ê°œë°œ**: ê²Œì„ ë³´ë“œ ì‹œìŠ¤í…œ, ìƒíƒœ ê´€ë¦¬, ìŠ¹ë¦¬ ì¡°ê±´ ê²€ì‚¬
4. **ì‹œìŠ¤í…œ ì„¤ê³„**: ë©”ëª¨ë¦¬ íš¨ìœ¨ì„±, ì„±ëŠ¥ ìµœì í™”, í™•ì¥ì„± ê³ ë ¤

**ì‹¤ë¬´ ì„¤ê³„ ì›ì¹™**
- ğŸ—ï¸ **ëª¨ë“ˆí™”**: ê¸°ëŠ¥ë³„ë¡œ ë¶„ë¦¬ëœ í´ë˜ìŠ¤ì™€ ë©”ì„œë“œ ì„¤ê³„
- âš¡ **ì„±ëŠ¥ ìµœì í™”**: ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ê³¼ ì‹¤í–‰ ì‹œê°„ì˜ ê· í˜•
- ğŸ”’ **ë°ì´í„° ë¬´ê²°ì„±**: ìœ íš¨ì„± ê²€ì‚¬ì™€ ì˜¤ë¥˜ ì²˜ë¦¬
- ğŸ“Š **ëª¨ë‹ˆí„°ë§**: í†µê³„ ì •ë³´ì™€ ì„±ëŠ¥ ë©”íŠ¸ë¦­ ìˆ˜ì§‘

**í™•ì¥ì„± ê³ ë ¤ì‚¬í•­**
- **ë©”ëª¨ë¦¬ ê´€ë¦¬**: ë™ì  í¬ê¸° ì¡°ì •ê³¼ ë©”ëª¨ë¦¬ ë‚­ë¹„ ìµœì†Œí™”
- **ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§**: ì‹¤ì‹œê°„ í†µê³„ì™€ ì„±ëŠ¥ ì§€í‘œ ì¶”ì 
- **ì˜¤ë¥˜ ì²˜ë¦¬**: ì˜ˆì™¸ ìƒí™©ì— ëŒ€í•œ ì ì ˆí•œ ì²˜ë¦¬
- **API ì„¤ê³„**: ì‚¬ìš©í•˜ê¸° ì‰¬ìš´ ì¸í„°í˜ì´ìŠ¤ ì œê³µ

**ë°°ì—´ í•™ìŠµ ì™„ì„±**
ì´ì œ ë°°ì—´ì— ëŒ€í•œ ì™„ì „í•œ í•™ìŠµ ê²½ë¡œë¥¼ ì™„ì„±í–ˆìŠµë‹ˆë‹¤:
1. **ê¸°ë³¸ ê°œë…**: ë°°ì—´ì˜ ì •ì˜ì™€ íŠ¹ì§•
2. **ì˜ˆì œ ë¬¸ì œ**: ì‹¤ì „ ë¬¸ì œ í•´ê²° ë°©ë²•
3. **ì•Œê³ ë¦¬ì¦˜ ê¸°ë²•**: ê³ ê¸‰ ìµœì í™” ê¸°ë²•
4. **ì‹¤ë¬´ í™œìš©**: ì‹¤ì œ í”„ë¡œì íŠ¸ ì ìš© ë°©ë²•

# ğŸ“š ë ˆí¼ëŸ°ìŠ¤
- [System Design Interview - High Scalability](https://highscalability.com/)
- [Python Performance Tips - Python.org](https://wiki.python.org/moin/PythonSpeed/PerformanceTips)
- [Data Structures and Algorithms in Python - Goodrich](https://www.amazon.com/Data-Structures-Algorithms-Python-Goodrich/dp/1118290275)

---
*ì´ í¬ìŠ¤íŠ¸ëŠ” ìë£Œêµ¬ì¡° í•™ìŠµ ê³¼ì •ì„ ì •ë¦¬í•œ ë‚´ìš©ì…ë‹ˆë‹¤.*
